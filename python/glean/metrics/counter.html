<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>glean.metrics.counter API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>glean.metrics.counter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.


from typing import List, Optional


from .. import Glean
from ..testing import ErrorType
from .. import _ffi


from .lifetime import Lifetime


class CounterMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording counter metrics.

    Instances of this class type are automatically generated by the parsers at
    build time, allowing developers to record values that were previously
    registered in the metrics.yaml file.

    The counter API only exposes the `CounterMetricType.add` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_counter_metric(
            _ffi.ffi_string(category),
            _ffi.ffi_string(name),
            _ffi.ffi_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_counter_metric(self._handle)

    def add(self, amount: int = 1):
        &#34;&#34;&#34;
        Add to counter value.

        Args:
            amount (int): (default: 1) This is the amount to increment the
                counter by.
        &#34;&#34;&#34;
        if self._disabled:
            return

        # TODO: 1594033 Run on the dispatcher
        _ffi.lib.glean_counter_add(Glean._handle, self._handle, amount)

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_counter_test_has_value(
                Glean._handle, self._handle, _ffi.ffi_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; int:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (int): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return _ffi.lib.glean_counter_test_get_value(
            Glean._handle, self._handle, _ffi.ffi_string(ping_name)
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_counter_test_get_num_recorded_errors(
            Glean._handle, self._handle, error_type.value, _ffi.ffi_string(ping_name)
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="glean.metrics.counter.CounterMetricType"><code class="flex name class">
<span>class <span class="ident">CounterMetricType</span></span>
<span>(</span><span>disabled, category, lifetime, name, send_in_pings)</span>
</code></dt>
<dd>
<section class="desc"><p>This implements the developer facing API for recording counter metrics.</p>
<p>Instances of this class type are automatically generated by the parsers at
build time, allowing developers to record values that were previously
registered in the metrics.yaml file.</p>
<p>The counter API only exposes the <a title="glean.metrics.counter.CounterMetricType.add" href="#glean.metrics.counter.CounterMetricType.add"><code>CounterMetricType.add()</code></a> method, which
takes care of validating the input data and making sure that limits are
enforced.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CounterMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording counter metrics.

    Instances of this class type are automatically generated by the parsers at
    build time, allowing developers to record values that were previously
    registered in the metrics.yaml file.

    The counter API only exposes the `CounterMetricType.add` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_counter_metric(
            _ffi.ffi_string(category),
            _ffi.ffi_string(name),
            _ffi.ffi_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_counter_metric(self._handle)

    def add(self, amount: int = 1):
        &#34;&#34;&#34;
        Add to counter value.

        Args:
            amount (int): (default: 1) This is the amount to increment the
                counter by.
        &#34;&#34;&#34;
        if self._disabled:
            return

        # TODO: 1594033 Run on the dispatcher
        _ffi.lib.glean_counter_add(Glean._handle, self._handle, amount)

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_counter_test_has_value(
                Glean._handle, self._handle, _ffi.ffi_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; int:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (int): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return _ffi.lib.glean_counter_test_get_value(
            Glean._handle, self._handle, _ffi.ffi_string(ping_name)
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_counter_test_get_num_recorded_errors(
            Glean._handle, self._handle, error_type.value, _ffi.ffi_string(ping_name)
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.counter.CounterMetricType.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, amount=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Add to counter value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>(default: 1) This is the amount to increment the
counter by.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, amount: int = 1):
    &#34;&#34;&#34;
    Add to counter value.

    Args:
        amount (int): (default: 1) This is the amount to increment the
            counter by.
    &#34;&#34;&#34;
    if self._disabled:
        return

    # TODO: 1594033 Run on the dispatcher
    _ffi.lib.glean_counter_add(Glean._handle, self._handle, amount)</code></pre>
</details>
</dd>
<dt id="glean.metrics.counter.CounterMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type, ping_name=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_errors</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of errors recorded for the metric for
the given error type.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_counter_test_get_num_recorded_errors(
        Glean._handle, self._handle, error_type.value, _ffi.ffi_string(ping_name)
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.counter.CounterMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>value of the stored metric.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; int:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (int): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return _ffi.lib.glean_counter_test_get_value(
        Glean._handle, self._handle, _ffi.ffi_string(ping_name)
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.counter.CounterMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>has_value</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if the metric value exists.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_counter_test_has_value(
            Glean._handle, self._handle, _ffi.ffi_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="glean.metrics" href="index.html">glean.metrics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="glean.metrics.counter.CounterMetricType" href="#glean.metrics.counter.CounterMetricType">CounterMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.counter.CounterMetricType.add" href="#glean.metrics.counter.CounterMetricType.add">add</a></code></li>
<li><code><a title="glean.metrics.counter.CounterMetricType.test_get_num_recorded_errors" href="#glean.metrics.counter.CounterMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.counter.CounterMetricType.test_get_value" href="#glean.metrics.counter.CounterMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.counter.CounterMetricType.test_has_value" href="#glean.metrics.counter.CounterMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>