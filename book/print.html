<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Glean - Cross-platform Telemetry library</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="glean.css">
        
        <link rel="stylesheet" href="mermaid.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Glean</a></li><li class="chapter-item expanded "><a href="user/index.html"><strong aria-hidden="true">2.</strong> Using the Glean SDK</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user/adding-glean-to-your-project.html"><strong aria-hidden="true">2.1.</strong> Adding Glean to your project</a></li><li class="chapter-item expanded "><a href="user/general-api.html"><strong aria-hidden="true">2.2.</strong> The General API</a></li><li class="chapter-item expanded "><a href="user/adding-new-metrics.html"><strong aria-hidden="true">2.3.</strong> Adding new metrics</a></li><li class="chapter-item expanded "><a href="user/metric-parameters.html"><strong aria-hidden="true">2.4.</strong> Metric parameters</a></li><li class="chapter-item expanded "><a href="user/testing-metrics.html"><strong aria-hidden="true">2.5.</strong> Testing metrics</a></li><li class="chapter-item expanded "><a href="user/debugging/index.html"><strong aria-hidden="true">2.6.</strong> Debugging products using Glean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user/debugging/android.html"><strong aria-hidden="true">2.6.1.</strong> Android</a></li><li class="chapter-item expanded "><a href="user/debugging/ios.html"><strong aria-hidden="true">2.6.2.</strong> iOS</a></li><li class="chapter-item expanded "><a href="user/debugging/python.html"><strong aria-hidden="true">2.6.3.</strong> Python</a></li></ol></li><li class="chapter-item expanded "><a href="user/error-reporting.html"><strong aria-hidden="true">2.7.</strong> Error reporting</a></li><li class="chapter-item expanded "><a href="user/experiments-api.html"><strong aria-hidden="true">2.8.</strong> Using the experiments API</a></li><li class="chapter-item expanded "><a href="user/metrics/index.html"><strong aria-hidden="true">2.9.</strong> Metric types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user/metrics/boolean.html"><strong aria-hidden="true">2.9.1.</strong> Boolean</a></li><li class="chapter-item expanded "><a href="user/metrics/labeled_booleans.html"><strong aria-hidden="true">2.9.2.</strong> Labeled Booleans</a></li><li class="chapter-item expanded "><a href="user/metrics/counter.html"><strong aria-hidden="true">2.9.3.</strong> Counter</a></li><li class="chapter-item expanded "><a href="user/metrics/labeled_counters.html"><strong aria-hidden="true">2.9.4.</strong> Labeled Counters</a></li><li class="chapter-item expanded "><a href="user/metrics/string.html"><strong aria-hidden="true">2.9.5.</strong> String</a></li><li class="chapter-item expanded "><a href="user/metrics/labeled_strings.html"><strong aria-hidden="true">2.9.6.</strong> Labeled Strings</a></li><li class="chapter-item expanded "><a href="user/metrics/string_list.html"><strong aria-hidden="true">2.9.7.</strong> String List</a></li><li class="chapter-item expanded "><a href="user/metrics/timespan.html"><strong aria-hidden="true">2.9.8.</strong> Timespan</a></li><li class="chapter-item expanded "><a href="user/metrics/timing_distribution.html"><strong aria-hidden="true">2.9.9.</strong> Timing Distribution</a></li><li class="chapter-item expanded "><a href="user/metrics/memory_distribution.html"><strong aria-hidden="true">2.9.10.</strong> Memory Distribution</a></li><li class="chapter-item expanded "><a href="user/metrics/uuid.html"><strong aria-hidden="true">2.9.11.</strong> UUID</a></li><li class="chapter-item expanded "><a href="user/metrics/datetime.html"><strong aria-hidden="true">2.9.12.</strong> Datetime</a></li><li class="chapter-item expanded "><a href="user/metrics/event.html"><strong aria-hidden="true">2.9.13.</strong> Event</a></li><li class="chapter-item expanded "><a href="user/metrics/custom_distribution.html"><strong aria-hidden="true">2.9.14.</strong> Custom Distribution</a></li><li class="chapter-item expanded "><a href="user/metrics/quantity.html"><strong aria-hidden="true">2.9.15.</strong> Quantity</a></li></ol></li><li class="chapter-item expanded "><a href="user/pings/index.html"><strong aria-hidden="true">2.10.</strong> Pings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user/pings/ping-schedules-and-timings.html"><strong aria-hidden="true">2.10.1.</strong> Ping schedules and timings overview</a></li><li class="chapter-item expanded "><a href="user/pings/baseline.html"><strong aria-hidden="true">2.10.2.</strong> Baseline Ping</a></li><li class="chapter-item expanded "><a href="user/pings/deletion_request.html"><strong aria-hidden="true">2.10.3.</strong> Deletion Request Ping</a></li><li class="chapter-item expanded "><a href="user/pings/metrics.html"><strong aria-hidden="true">2.10.4.</strong> Metrics Ping</a></li><li class="chapter-item expanded "><a href="user/pings/events.html"><strong aria-hidden="true">2.10.5.</strong> Events Ping</a></li><li class="chapter-item expanded "><a href="user/pings/custom.html"><strong aria-hidden="true">2.10.6.</strong> Custom Pings</a></li><li class="chapter-item expanded "><a href="user/pings/testing-custom-pings.html"><strong aria-hidden="true">2.10.7.</strong> Testing custom pings</a></li></ol></li><li class="chapter-item expanded "><a href="user/android-build-configuration-options.html"><strong aria-hidden="true">2.11.</strong> Android build configuration options</a></li><li class="chapter-item expanded "><a href="user/focused-use-cases.html"><strong aria-hidden="true">2.12.</strong> Focused Use Cases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user/instrument-android-crashes-example.html"><strong aria-hidden="true">2.12.1.</strong> Instrumenting Android Crashes With Glean</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="user/collected-metrics/metrics.html"><strong aria-hidden="true">3.</strong> Metrics collected by the Glean SDK</a></li><li class="chapter-item expanded "><a href="dev/index.html"><strong aria-hidden="true">4.</strong> Developing the Glean SDK</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/testing.html"><strong aria-hidden="true">4.1.</strong> Testing</a></li><li class="chapter-item expanded "><a href="dev/docs.html"><strong aria-hidden="true">4.2.</strong> Developing documentation</a></li><li class="chapter-item expanded "><a href="dev/android/index.html"><strong aria-hidden="true">4.3.</strong> Android bindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/android/setup-android-build-environment.html"><strong aria-hidden="true">4.3.1.</strong> Setup Build Environment</a></li></ol></li><li class="chapter-item expanded "><a href="dev/ios/index.html"><strong aria-hidden="true">4.4.</strong> iOS bindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/ios/setup-ios-build-environment.html"><strong aria-hidden="true">4.4.1.</strong> Setup Build Environment</a></li><li class="chapter-item expanded "><a href="dev/ios/debug-glean-on-ios.html"><strong aria-hidden="true">4.4.2.</strong> Debugging Different Versions of Glean</a></li></ol></li><li class="chapter-item expanded "><a href="dev/python/index.html"><strong aria-hidden="true">4.5.</strong> Python bindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/python/setting-up-python-build-environment.html"><strong aria-hidden="true">4.5.1.</strong> Setup Build Environment</a></li></ol></li><li class="chapter-item expanded "><a href="dev/core/index.html"><strong aria-hidden="true">4.6.</strong> Rust Component</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/core/dependency-management.html"><strong aria-hidden="true">4.6.1.</strong> Dependency Management</a></li><li class="chapter-item expanded "><a href="dev/core/new-metric-type.html"><strong aria-hidden="true">4.6.2.</strong> Adding a new metric type</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/core/new-metric-type/ffi.html"><strong aria-hidden="true">4.6.2.1.</strong> FFI</a></li><li class="chapter-item expanded "><a href="dev/core/new-metric-type/kotlin.html"><strong aria-hidden="true">4.6.2.2.</strong> Kotlin</a></li><li class="chapter-item expanded "><a href="dev/core/new-metric-type/swift.html"><strong aria-hidden="true">4.6.2.3.</strong> Swift</a></li><li class="chapter-item expanded "><a href="dev/core/new-metric-type/python.html"><strong aria-hidden="true">4.6.2.4.</strong> Python</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="dev/ffi/index.html"><strong aria-hidden="true">4.7.</strong> FFI Layer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/ffi/when-to-use-what-in-the-ffi.html"><strong aria-hidden="true">4.7.1.</strong> When/How FFI</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">4.8.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="code_coverage.html"><strong aria-hidden="true">4.8.1.</strong> Code coverage</a></li></ol></li><li class="chapter-item expanded "><a href="dev/cut-a-new-release.html"><strong aria-hidden="true">4.9.</strong> Release process</a></li><li class="chapter-item expanded "><a href="dev/core/internal/index.html"><strong aria-hidden="true">4.10.</strong> Internal implementation details</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/core/internal/reserved-ping-names.html"><strong aria-hidden="true">4.10.1.</strong> Reserved ping names</a></li><li class="chapter-item expanded "><a href="dev/core/internal/clearing.html"><strong aria-hidden="true">4.10.2.</strong> Clearing metrics when disabling/enabling Glean</a></li><li class="chapter-item expanded "><a href="dev/core/internal/payload.html"><strong aria-hidden="true">4.10.3.</strong> Payload format</a></li><li class="chapter-item expanded "><a href="dev/core/internal/directory-structure.html"><strong aria-hidden="true">4.10.4.</strong> Directory structure</a></li><li class="chapter-item expanded "><a href="dev/core/internal/debug-pings.html"><strong aria-hidden="true">4.10.5.</strong> Debug Pings</a></li><li class="chapter-item expanded "><a href="dev/core/internal/upload.html"><strong aria-hidden="true">4.10.6.</strong> Upload mechanism</a></li><li class="chapter-item expanded "><a href="dev/core/internal/implementations.html"><strong aria-hidden="true">4.10.7.</strong> Implementations</a></li><li class="chapter-item expanded "><a href="dev/core/internal/sdk-ndk-versions.html"><strong aria-hidden="true">4.10.8.</strong> Android SDK/NDK versions</a></li></ol></li><li class="chapter-item expanded "><a href="dev/howtos/index.html"><strong aria-hidden="true">4.11.</strong> Howtos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/howtos/development-with-android-components.html"><strong aria-hidden="true">4.11.1.</strong> Development with android-components</a></li><li class="chapter-item expanded "><a href="dev/howtos/locally-published-components-in-fenix.html"><strong aria-hidden="true">4.11.2.</strong> Locally-published components in Fenix</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="api/index.html"><strong aria-hidden="true">5.</strong> API Documentation</a></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">6.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/glossary.html"><strong aria-hidden="true">6.1.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="appendix/changelog.html"><strong aria-hidden="true">6.2.</strong> Changelog</a></li><li class="chapter-item expanded "><a href="appendix/twig.html"><strong aria-hidden="true">6.3.</strong> This Week in Glean</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Glean - Cross-platform Telemetry library</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/mozilla/glean" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#glean-sdk" id="glean-sdk">Glean SDK</a></h1>
<p><img src="glean.jpeg" alt="Glean logo" /></p>
<p>The <code>Glean SDK</code> is a modern approach for a Telemetry library and is part of the <a href="https://docs.telemetry.mozilla.org/concepts/glean/glean.html">Glean project</a>.</p>
<p>To contact us you can:</p>
<ul>
<li>Find us in the <a href="https://chat.mozilla.org/#/room/#glean:mozilla.org">#glean channel on chat.mozilla.org</a>.</li>
<li>To report issues or request changes, file a bug in <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Data%20Platform%20and%20Tools&amp;component=Glean%3A%20SDK">Bugzilla in Data Platform &amp; Tools :: Glean: SDK</a>.</li>
<li>Send an email to <em>glean-team@mozilla.com</em>.</li>
<li>The Glean SDK team is: <em>:janerik</em>, <em>:dexter</em>, <em>:travis</em>, <em>:mdroettboom</em>, <em>:gfritzsche</em>, <em>:chutten</em>, <em>:brizental</em>.</li>
</ul>
<p>The source code is available <a href="https://github.com/mozilla/glean/">on GitHub</a>.</p>
<h2><a class="header" href="#license" id="license">License</a></h2>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="https://mozilla.org/MPL/2.0/">https://mozilla.org/MPL/2.0/</a>.</p>
<h1><a class="header" href="#using-the-glean-sdk" id="using-the-glean-sdk">Using the Glean SDK</a></h1>
<p>In this chapter we describe how to use the Glean SDK in your own libraries and applications.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#adding-glean-to-your-project" id="adding-glean-to-your-project">Adding Glean to your project</a></h1>
<h2><a class="header" href="#before-using-glean" id="before-using-glean">Before using Glean</a></h2>
<p>Products using the Glean SDK to collect telemetry <strong>must</strong>:</p>
<ul>
<li>add documentation for any new metric collected with the library in its repository (see <a href="user/pings/index.html">an example</a>);</li>
<li>include the markdown-formatted documentation generated from the <code>metrics.yaml</code> and <code>pings.yaml</code> files in the project's documentation;</li>
<li>go through data review for the newly collected data by following <a href="https://wiki.mozilla.org/Firefox/Data_Collection">this process</a>;</li>
<li>provide a way for users to turn data collection off (e.g. providing settings to control
<code>Glean.setUploadEnabled()</code>).</li>
</ul>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<h3><a class="header" href="#integrating-with-your-project" id="integrating-with-your-project">Integrating with your project</a></h3>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<h4><a class="header" href="#setting-up-the-dependency" id="setting-up-the-dependency">Setting up the dependency</a></h4>
<p>Glean is published on <a href="https://maven.mozilla.org/">maven.mozilla.org</a>.
To use it, you need to add the following to your project's top-level build file,
in the <code>allprojects</code> block (see e.g. <a href="https://github.com/mozilla/glean/blob/master/build.gradle">Glean's own <code>build.gradle</code></a>):</p>
<pre><code class="language-Groovy">repositories {
    maven {
       url &quot;https://maven.mozilla.org/maven2&quot;
    }
}
</code></pre>
<p>Each module that uses Glean needs to specify it in its build file, in the <code>dependencies</code> block.
Add this to your Gradle configuration:</p>
<pre><code class="language-Groovy">implementation &quot;org.mozilla.components:service-glean:{latest-version}&quot;
</code></pre>
<blockquote>
<p><strong>Important:</strong> the <code>{latest-version}</code> placeholder in the above link should be replaced with the version of Android Components used by the project.</p>
</blockquote>
<p>The Glean SDK is released as part of <a href="https://github.com/mozilla-mobile/android-components">android-components</a>.  Therefore, it follows android-components' versions.
The <a href="https://github.com/mozilla-mobile/android-components/releases/">android-components release page</a> can be used to determine the latest version.</p>
<p>For example, if version <em>33.0.0</em> is used, then the include directive becomes:</p>
<pre><code class="language-Groovy">implementation &quot;org.mozilla.components:service-glean:33.0.0&quot;
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<h4><a class="header" href="#setting-up-the-dependency-1" id="setting-up-the-dependency-1">Setting up the dependency</a></h4>
<p>Glean can be consumed through <a href="https://github.com/Carthage/Carthage">Carthage</a>, a dependency manager for macOS and iOS.
For consuming the latest version of Glean, add the following line to your <code>Cartfile</code>:</p>
<pre><code>github &quot;mozilla/glean&quot; &quot;{latest-version}&quot;
</code></pre>
<blockquote>
<p><strong>Important:</strong> the <code>{latest-version}</code> placeholder should be replaced with the version number of the latest Glean SDK release.
You can find the version number on the <a href="https://github.com/mozilla/glean/releases/latest">release page</a>.</p>
</blockquote>
<p>Then check out and build the new dependency:</p>
<pre><code>carthage update --platform iOS
</code></pre>
<h4><a class="header" href="#integrating-with-the-build-system" id="integrating-with-the-build-system">Integrating with the build system</a></h4>
<p>For integration with the build system you can follow the <a href="https://github.com/Carthage/Carthage#quick-start">Carthage Quick Start steps</a>.</p>
<ol>
<li>
<p>After building the dependency one drag the built <code>.framework</code> binaries from <code>Carthage/Build/iOS</code> into your application's Xcode project.</p>
</li>
<li>
<p>On your application targets' Build Phases settings tab, click the <code>+</code> icon and choose <code>New Run Script Phase</code>.
If you already use Carthage for other dependencies, extend the existing step.
Create a Run Script in which you specify your shell (ex: <code>/bin/sh</code>), add the following contents to the script area below the shell:</p>
<pre><code>/usr/local/bin/carthage copy-frameworks
</code></pre>
</li>
<li>
<p>Add the path to the Glean framework under &quot;Input Files&quot;:</p>
<pre><code>$(SRCROOT)/Carthage/Build/iOS/Glean.framework
</code></pre>
</li>
<li>
<p>Add the paths to the copied framework to the &quot;Output Files&quot;:</p>
<pre><code>$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/Glean.framework
</code></pre>
</li>
</ol>
</div>
<div data-lang="Python" class="tab">
<p>We recommend using a virtual environment for your work to isolate the dependencies for your project. There are many popular abstractions on top of virtual environments in the Python ecosystem which can help manage your project dependencies.</p>
<p>The Python Glean bindings currently have <a href="https://pypi.org/project/glean-sdk/#files">prebuilt wheels on PyPI for x86_64 Windows, Linux and macOS</a>.</p>
<p>If you're running one of those platforms and have your virtual environment set up and activated, you can install Glean into it using:</p>
<pre><code class="language-bash">$ python -m pip install glean_sdk
</code></pre>
<p>If you are not on one of these platforms, you will need to build the Glean Python bindings from source using <a href="user/../dev/python/setting-up-python-build-environment.html">these instructions</a>.</p>
</div>
</div>
</div>
<h3><a class="header" href="#adding-new-metrics" id="adding-new-metrics">Adding new metrics</a></h3>
<p>All metrics that your project collects must be defined in a <code>metrics.yaml</code> file.</p>
<p>The format of that file is documented <a href="https://mozilla.github.io/glean_parser/metrics-yaml.html">with <code>glean_parser</code></a>.
To learn more, see <a href="user/adding-new-metrics.html">adding new metrics</a>.</p>
<blockquote>
<p><strong>Important</strong>: as stated <a href="user/adding-glean-to-your-project.html#before-using-glean">before</a>, any new data collection requires documentation and data-review.
This is also required for any new metric automatically collected by the Glean SDK.</p>
</blockquote>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<p>In order for the Glean SDK to generate an API for your metrics, two Gradle plugins must be included in your build:</p>
<ul>
<li>The <a href="https://github.com/mozilla/glean/tree/master/gradle-plugin/">Glean Gradle plugin</a></li>
<li>JetBrains' <a href="https://github.com/JetBrains/gradle-python-envs/">Python envs plugin</a></li>
</ul>
<p>The Glean Gradle plugin is distributed through Mozilla's Maven, so we need to tell your build where to look for it by adding the following to the top of your <code>build.gradle</code>:</p>
<pre><code>buildscript {
    repositories {
        // Include the next clause if you are tracking snapshots of android components
        maven {
            url &quot;https://snapshots.maven.mozilla.org/maven2&quot;
        }
        maven {
            url &quot;https://maven.mozilla.org/maven2&quot;
        }

        dependencies {
            classpath &quot;org.mozilla.components:tooling-gradle-plugin:{android-components-version}&quot;
        }
    }
}
</code></pre>
<blockquote>
<p><strong>Important:</strong> as above, the <code>{android-components-version}</code> placeholder in the above link should be replaced with the version number of android components used in your project.</p>
</blockquote>
<p>The JetBrains Python plugin is distributed in the Gradle plugin repository, so it can be included with:</p>
<pre><code class="language-Groovy">plugins {
    id &quot;com.jetbrains.python.envs&quot; version &quot;0.0.26&quot;
}
</code></pre>
<p>Right before the end of the same file, we need to apply the Glean Gradle plugin.
Set any <a href="user/android-build-configuration-options.html">additional parameters</a> to control the behavior of the Glean Gradle plugin before calling <code>apply plugin</code>.</p>
<pre><code class="language-Groovy">// Optionally, set any parameters to send to the plugin.
ext.gleanGenerateMarkdownDocs = true
apply plugin: &quot;org.mozilla.telemetry.glean-gradle-plugin&quot;
</code></pre>
<blockquote>
<p><strong>Note:</strong> Earlier versions of Glean used a Gradle script (<code>sdk_generator.gradle</code>) rather than a Gradle plugin. Its use is deprecated and projects should be updated to use the Gradle plugin as described above.</p>
</blockquote>
</div>
<div data-lang="Swift" class="tab">
<p>The <code>metrics.yaml</code> file is parsed at build time and Swift code is generated.
Add a new <code>metrics.yaml</code> file to your Xcode project.</p>
<p>Follow these steps to automatically run the parser at build time:</p>
<ol>
<li>
<p>Download the <code>sdk_generator.sh</code> script from the Glean repository:</p>
<pre><code>https://raw.githubusercontent.com/mozilla/glean/{latest-release}/glean-core/ios/sdk_generator.sh
</code></pre>
<blockquote>
<p><strong>Important:</strong> as above, the <code>{latest-version}</code> placeholder should be replaced with the version number of Glean SDK release used in this project.</p>
</blockquote>
</li>
<li>
<p>Add the <code>sdk_generator.sh</code> file to your Xcode project.</p>
</li>
<li>
<p>On your application targets' Build Phases settings tab, click the <code>+</code> icon and choose <code>New Run Script Phase</code>.
Create a Run Script in which you specify your shell (ex: <code>/bin/sh</code>), add the following contents to the script area below the shell:</p>
<pre><code>bash $PWD/sdk_generator.sh
</code></pre>
</li>
<li>
<p>Add the path to your <code>metrics.yaml</code> and (optionally) <code>pings.yaml</code> under &quot;Input files&quot;:</p>
<pre><code>$(SRCROOT)/{project-name}/metrics.yaml
$(SRCROOT)/{project-name}/pings.yaml
</code></pre>
</li>
<li>
<p>Add the paths to the generated code files to the &quot;Output Files&quot;:</p>
<pre><code>$(SRCROOT)/{project-name}/Generated/{YourCategory}.swift
</code></pre>
<blockquote>
<p><strong>Important</strong>: The parser generates one file per category.
If you are unsure which files those are, skip this step and add the files after they are generated for the first time.</p>
</blockquote>
</li>
<li>
<p>If you are using Git, add the following lines to your <code>.gitignore</code> file:</p>
<pre><code>.venv/
{project-name}/Generated
</code></pre>
<p>This will ignore files that are generated at build time by the <code>sdk_generator.sh</code> script.
They don't need to be kept in version control, as they can be re-generated from your <code>metrics.yaml</code> and <code>pings.yaml</code> files.</p>
</li>
</ol>
</div>
<div data-lang="Python" class="tab">
<p>For Python, the <code>metrics.yaml</code> file must be available and loaded at runtime.</p>
<p>If your project is a script (i.e. just Python files in a directory), you can load the <code>metrics.yaml</code> using:</p>
<pre><code class="language-Python">from glean import load_metrics

metrics = load_metrics(&quot;metrics.yaml&quot;)

# Use a metric on the returned object
metrics.your_category.your_metric.set(&quot;value&quot;)
</code></pre>
<p>If your project is a distributable Python package, you need to include the <code>metrics.yaml</code> file using <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#including-data-files">one of the myriad ways to include data in a Python package</a> and then use <a href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html#resource-extraction"><code>pkg_resources.resource_filename()</code></a> to get the filename at runtime.</p>
<pre><code class="language-Python">from glean import load_metrics
from pkg_resources import resource_filename

metrics = load_metrics(resource_filename(__name__, &quot;metrics.yaml&quot;))

# Use a metric on the returned object
metrics.your_category.your_metric.set(&quot;value&quot;)
</code></pre>
<p>The documentation for your application or library's metrics and pings are written in <code>metrics.yaml</code> and <code>pings.yaml</code>. However, you should also provide human-readable markdown files based on this information, and this is a requirement for Mozilla projects using Glean. For other languages and platforms, this transformation is done automatically as part of the build. However, for Python the integration to automatically generate docs is an additional step.</p>
<p>Glean provides a commandline tool for automatically generating markdown documentation from your <code>metrics.yaml</code> and <code>pings.yaml</code> files. To perform that translation, run <code>glean_parser</code>'s <code>translate</code> command:</p>
<pre><code class="language-sh">python3 -m glean_parser translate -f markdown -o docs metrics.yaml pings.yaml
</code></pre>
<p>To get more help about the commandline options:</p>
<pre><code class="language-sh">python3 -m glean_parser translate --help
</code></pre>
<p>We recommend integrating this step into your project's documentation build. The details of that integration is left to you, since it depends on the documentation tool being used and how your project is set up.</p>
</div>
</div>
</div>
<h3><a class="header" href="#adding-custom-pings" id="adding-custom-pings">Adding custom pings</a></h3>
<p>Please refer to the <a href="user/pings/custom.html">custom pings documentation</a>.</p>
<blockquote>
<p><strong>Important</strong>: as stated <a href="user/adding-glean-to-your-project.html#before-using-glean">before</a>, any new data collection requires documentation and data-review.
This is also required for any new metric automatically collected by the Glean SDK.</p>
</blockquote>
<h3><a class="header" href="#parallelism" id="parallelism">Parallelism</a></h3>
<p>All of Glean's target languages use a separate worker thread to do most of Glean's work, including any I/O. This thread is fully managed by Glean as an implementation detail. Therefore, users should be free to use the Glean API wherever it is most convenient, without worrying about the performance impact of updating metrics and sending pings.</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Python" class="tab">
When using the Python bindings, Glean's work is done on a separate thread, managed by Glean itself.
Glean releases the Global Interpreter Lock (GIL), therefore your application's threads should not be in contention with Glean's thread.
<p>Glean installs an <a href="https://docs.python.org/3/library/atexit.html"><code>atexit</code> handler</a> so the Glean thread can attempt to cleanly shut down when your application exits.
This handler will wait up to 1 second for any pending work to complete.</p>
<p>In addition, by default ping uploading is performed in a separate child process. This process will continue to upload any pending pings even after the main process shuts down.</p>
<p>Note that this approach may not work with applications built using <a href="https://www.pyinstaller.org/"><code>PyInstaller</code></a> or similar tools which bundle an application together with a Python interpreter. For these cases (and any others which we haven't thought of), there is an option to ensure that ping uploading occurs in the main process. To do this, set the <code>allow_multiprocessing</code> parameter on the <code>glean.Configuration</code> object to <code>False</code>.</p>
</div>
</div>
</div>
<h3><a class="header" href="#testing-metrics" id="testing-metrics">Testing metrics</a></h3>
<p>In order to make testing metrics easier 'out of the box', all metrics include a set of test API functions in order to facilitate unit testing.  These include functions to test whether a value has been stored, and functions to retrieve the stored value for validation.  For more information, please refer to <a href="user/testing-metrics.html">Unit testing Glean metrics</a>.</p>
<h3><a class="header" href="#adding-metadata-about-your-project-to-the-pipeline" id="adding-metadata-about-your-project-to-the-pipeline">Adding metadata about your project to the pipeline</a></h3>
<p>In order for data to be collected from your project, its application id must be registered in the pipeline.</p>
<p><a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Data%20Platform%20and%20Tools&amp;component=General&amp;short_desc=Glean:%20Enable%20application%20id%20org.mozilla.myProduct&amp;comment=%2A%2A%20Please%20needinfo%20mreid%40mozilla.com%20when%20filing%20this%20bug%20for%20the%20fastest%20response%20%2A%2A">File a data engineering bug</a> to enable your product's application id.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/adding-glean-to-your-project.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#the-general-api" id="the-general-api">The General API</a></h1>
<p>Glean has a minimal API available on its top-level <code>Glean</code> object.
This API allows one to enable and disable upload, register <a href="user/pings/custom.html">custom pings</a> and set <a href="user/experiments-api.html">experiment data</a>.</p>
<blockquote>
<p><strong>Important:</strong> The Glean SDK should only be initialized from the main application, not individual libraries.</p>
</blockquote>
<p>If you are adding Glean support to a library, you can safely skip this section.</p>
<h2><a class="header" href="#the-api" id="the-api">The API</a></h2>
<p>The Glean SDK provides a general API that supports the following operations. See below for language-specific details.</p>
<table><thead><tr><th>Operation</th><th>Description</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>initialize</code></td><td>Configure and initialize the Glean SDK.</td><td><a href="user/general-api.html#initializing-the-glean-sdk">Initializing the Glean SDK</a></td></tr>
<tr><td><code>setUploadEnabled</code></td><td>Enable or disable Glean collection and upload.</td><td><a href="user/general-api.html#enabling-and-disabling-metrics">Enabling and disabling Metrics</a></td></tr>
<tr><td><code>getUploadEnabled</code></td><td>Get whether or not Glean is allowed to record and upload data.</td><td></td></tr>
<tr><td><code>registerPings</code></td><td>Register custom pings generated from <code>pings.yaml</code>.</td><td><a href="user/pings/custom.html">Custom pings</a></td></tr>
<tr><td><code>setExperimentActive</code></td><td>Indicate that an experiment is running.</td><td><a href="user/experiments-api.html">Using the Experiments API</a></td></tr>
<tr><td><code>setExperimentInactive</code></td><td>Indicate that an experiment is no longer running..</td><td><a href="user/experiments-api.html">Using the Experiments API</a></td></tr>
</tbody></table>
<h2><a class="header" href="#initializing-the-glean-sdk" id="initializing-the-glean-sdk">Initializing the Glean SDK</a></h2>
<p>The following steps are required for applications using the Glean SDK, but not libraries.</p>
<blockquote>
<p><strong>Note</strong>: The <code>initialize</code> function <em>must</em> be called, even if telemetry upload is disabled.
Glean needs to perform maintenance tasks even when telemetry is disabled, and because Glean
does this as part of its initialization, it is <em>required</em> to always call the <code>initialize</code>
function. Otherwise, Glean won't be able to clean up collected data, disable queuing of pre-init
tasks, or perform other required operations.</p>
</blockquote>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<blockquote>
<p><strong>Note</strong>: The Glean SDK does not support use across multiple processes, and must only be initialized on the application's main process. Initializing in other processes is a no-op.
Additionally, Glean must be initialized on the main (UI) thread of the applications main process. Failure to do so will throw an <code>IllegalThreadStateException</code>.</p>
</blockquote>
<p>An excellent place to initialize Glean is within the <code>onCreate</code> method of the class that extends Android's <code>Application</code> class.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Pings

class SampleApplication : Application() {

    override fun onCreate() {
        super.onCreate()

        // If you have custom pings in your application, you must register them
        // using the following command. This command should be omitted for
        // applications not using custom pings.
        Glean.registerPings(Pings)

        // Initialize the Glean library.
        Glean.initialize(
            applicationContext, 
            // Here, `settings()` is a method to get user preferences, specific to
            // your application and not part of the Glean SDK API.
            uploadEnabled = settings().isTelemetryEnabled
        )
    }
}
</code></pre>
<p>Once initialized, if <code>uploadEnabled</code> is true, the Glean SDK will automatically start collecting <a href="user/pings/metrics.html">baseline metrics</a> and sending its <a href="user/pings/index.html">pings</a>, according to their respective schedules.<br />
If <code>uploadEnabled</code> is false, any persisted metrics, events and pings (other than <code>first_run_date</code>) are cleared, and subsequent calls to record metrics will be no-ops.</p>
<p>The Glean SDK should be initialized as soon as possible, and importantly, before any other libraries in the application start using Glean.
Library code should never call <code>Glean.initialize</code>, since it should be called exactly once per application.</p>
<blockquote>
<p><strong>Note</strong>: if the application has the concept of release channels and knows which channel it is on at run-time, then it can provide the Glean SDK with this information by setting it as part of the <code>Configuration</code> object parameter of the <code>Glean.initialize</code> method. For example:</p>
</blockquote>
<pre><code class="language-Kotlin">Glean.initialize(applicationContext, Configuration(channel = &quot;beta&quot;))
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<blockquote>
<p><strong>Note</strong>: The Glean SDK does not support use across multiple processes, and must only be initialized on the application's main process.</p>
</blockquote>
<p>An excellent place to initialize Glean is within the <code>application(_:)</code> method of the class that extends the <code>UIApplicationDelegate</code> class.</p>
<pre><code class="language-Swift">import Glean
import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(_: UIApplication, didFinishLaunchingWithOptions _: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
        // If you have custom pings in your application, you must register them
        // using the following command. This command should be omitted for
        // applications not using custom pings.
        Glean.shared.registerPings(GleanMetrics.Pings)

        // Initialize the Glean library.
        Glean.shared.initialize(
            // Here, `Settings` is a method to get user preferences specific to
            // your application, and not part of the Glean SDK API.
            uploadEnabled = Settings.isTelemetryEnabled
        )
    }
}
</code></pre>
<p>Once initialized, if <code>uploadEnabled</code> is true, the Glean SDK will automatically start collecting <a href="user/pings/metrics.html">baseline metrics</a> and sending its <a href="user/pings/index.html">pings</a>, according to their respective schedules.<br />
If <code>uploadEnabled</code> is false, any persisted metrics, events and pings (other than <code>first_run_date</code>) are cleared, and subsequent calls to record metrics will be no-ops.</p>
<p>The Glean SDK should be initialized as soon as possible, and importantly, before any other libraries in the application start using Glean.
Library code should never call <code>Glean.shared.initialize</code>, since it should be called exactly once per application.</p>
<blockquote>
<p><strong>Note</strong>: if the application has the concept of release channels and knows which channel it is on at run-time,
then it can provide the Glean SDK with this information by setting it as part of the <code>Configuration</code> object parameter of the <code>Glean.shared.initialize</code> method. For example:</p>
</blockquote>
<pre><code class="language-Swift">Glean.shared.initialize(Configuration(channel: &quot;beta&quot;))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<p>The main control for Glean is on the <code>glean.Glean</code> singleton.</p>
<p>The Glean SDK should be initialized as soon as possible, and importantly, before any other libraries in the application start using Glean.
Library code should never call <code>Glean.initialize</code>, since it should be called exactly once per application.</p>
<pre><code class="language-python">from glean import Glean

Glean.initialize(
    application_id=&quot;my-app-id&quot;,
    application_version=&quot;0.1.0&quot;,
    upload_enabled=True,
)
</code></pre>
<p>Once initialized, if <code>upload_enabled</code> is true, the Glean SDK will automatically start collecting <a href="user/pings/metrics.html">baseline metrics</a> and sending its <a href="user/pings/index.html">pings</a>, according to their respective schedules.<br />
If <code>upload_enabled</code> is false, any persisted metrics, events and pings (other than <code>first_run_date</code>) are cleared, and subsequent calls to record metrics will be no-ops.</p>
<p>Additional configuration is available on the <code>glean.Configuration</code> object, which can be passed into <code>Glean.initialize()</code>.</p>
<p>Unlike Android and Swift, the Python bindings do not automatically send any pings.
See the <a href="user/pings/custom.html">custom pings documentation</a> about adding custom pings and sending them.</p>
</div>
</div>
</div>
<h2><a class="header" href="#behavior-when-uninitialized" id="behavior-when-uninitialized">Behavior when uninitialized</a></h2>
<p>Metric recording that happens before Glean is initialized is queued and applied when Glean is initialized.
To avoid unbounded memory growth the queue is bounded (currently to a maximum of 100 tasks).
Further recordings are dropped.
The number of recordings dropped, if any, is recorded in the <code>glean.error.preinit_tasks_overflow</code> metric.</p>
<p>Custom ping submission will not fail before initialization.
Collection and upload of the custom ping is delayed until Glean is initialized.
Built-in pings are only available after initialization.</p>
<h2><a class="header" href="#enabling-and-disabling-metrics" id="enabling-and-disabling-metrics">Enabling and disabling metrics</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<p><code>Glean.setUploadEnabled()</code> should be called in response to the user enabling or disabling telemetry.</p>
</div>
<div data-lang="Swift" class="tab">
<p><code>Glean.shared.setUploadEnabled()</code> should be called in response to the user enabling or disabling telemetry.</p>
</div>
<div data-lang="Python" class="tab">
<p><code>Glean.set_upload_enabled()</code> should be called in response to the user enabling or disabling telemetry.</p>
</div>
</div>
</div>
<p>The application should provide some form of user interface to call this method.</p>
<p>When going from enabled to disabled, all pending events, metrics and pings are cleared, except for <a href="user/pings/index.html#the-client_info-section"><code>first_run_date</code></a>.
When re-enabling, core Glean metrics will be recomputed at that time.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/general-api.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#adding-new-metrics-1" id="adding-new-metrics-1">Adding new metrics</a></h1>
<p>When adding a new metric, the workflow is:</p>
<ul>
<li>Consider the question you are trying to answer with this data, and choose the <a href="user/metrics/index.html">metric type</a> and parameters to use.</li>
<li>Add a new entry to <a href="user/adding-new-metrics.html#The-metricsyaml-file"><code>metrics.yaml</code></a>.</li>
<li>Add code to your project to record into the metric by calling the Glean SDK.</li>
</ul>
<blockquote>
<p><strong>Important</strong>: Any new data collection requires documentation and data-review.
This is also required for any new metric automatically collected by the Glean SDK.</p>
</blockquote>
<h2><a class="header" href="#choosing-a-metric-type" id="choosing-a-metric-type">Choosing a metric type</a></h2>
<p>The following is a set of questions to ask about the data being collected to help better determine which metric type to use.</p>
<h3><a class="header" href="#is-it-a-single-measurement" id="is-it-a-single-measurement">Is it a single measurement?</a></h3>
<p>If the value is true or false, use a <a href="user/metrics/boolean.html">boolean metric</a>.</p>
<p>If the value is a string, use a <a href="user/metrics/string.html">string metric</a>. For example, to record the name of the default search engine. Beware: string metrics are exceedingly general, and you are probably best served by selecting the most specific metric for the job, since you'll get better error checking and richer analysis tools for free. For example, avoid storing a number in a string metric --- you probably want a <a href="user/metrics/counter.html">counter metric</a> instead.</p>
<p>If you need to store multiple string values in a metric, use a <a href="user/metrics/string_list.html">string list metric</a>. For example, you may want to record the list of other Mozilla products installed on the device.</p>
<!-- TODO: If you do know the list of values you might store and you just want to record their presence, consider using a [labeled boolean](metrics/labeled_boolean.html) instead. -->
<!-- If you have a related set of metrics that you want to record strings for, and you don't know the things the strings relate to at build time, use a [labeled string metric](metrics/labeled_strings.html). -->
<p>For all of the simple metric types in this section that measure single values, it is especially important to consider how the lifetime of the value relates to the ping it is being sent in. Since these metrics don't perform any aggregation on the client side, when a ping containing the metric is submitted, it will contain only the &quot;last known&quot; value for the metric, potentially resulting in <strong>data loss</strong>.  There is further discussion of <a href="user/adding-new-metrics.html#When-should-Glean-automatically-reset-the-measurement">metric lifetimes</a> below.</p>
<h3><a class="header" href="#are-you-counting-things" id="are-you-counting-things">Are you counting things?</a></h3>
<p>If you want to know how many times something happened, use a <a href="user/metrics/counter.html">counter metric</a>.  If you are counting a group of related things, or you don't know what all of the things to count are at build time, use a <a href="user/metrics/labeled_counters.html">labeled counter metric</a>.</p>
<p>If you need to know when the things being counted happened relative to other things, consider using an <a href="user/metrics/event.html">event</a>.</p>
<h3><a class="header" href="#are-you-measuring-time" id="are-you-measuring-time">Are you measuring time?</a></h3>
<p>If you need to record an absolute time, use a <a href="user/metrics/datetime.html">datetime metric</a>. Datetimes are recorded in the user's local time, according to their device's real time clock, along with a timezone offset from UTC. Datetime metrics allow specifying the resolution they are collected at, and to stay <a href="https://www.mozilla.org/en-US/about/policy/lean-data/stay-lean/">lean</a>, they should only be collected at the minimum resolution required to answer your question.</p>
<p>If you need to record how long something takes you have a few options. </p>
<p>If you need to measure the total time spent doing a particular task, look to the <a href="user/metrics/timespan.html">timespan metric</a>. Timespan metrics allow specifying the resolution they are collected at, and to stay <a href="https://www.mozilla.org/en-US/about/policy/lean-data/stay-lean/">lean</a>, they should only be collected at the minimum resolution required to answer your question.
Note that this metric should only be used to measure time on a single thread. If multiple overlapping timespans are measured for the same metric, an invalid state error is recorded. </p>
<p>If you need to measure the relative occurrences of many timings, use a <a href="user/metrics/timing_distribution.html">timing distribution</a>. It builds a histogram of timing measurements, and is safe to record multiple concurrent timespans on different threads.</p>
<p>If you need to know the time between multiple distinct actions that aren't a simple &quot;begin&quot; and &quot;end&quot; pair, consider using an <a href="user/metrics/event.html">event</a>.</p>
<h3><a class="header" href="#do-you-need-to-know-the-order-of-events-relative-to-other-events" id="do-you-need-to-know-the-order-of-events-relative-to-other-events">Do you need to know the order of events relative to other events?</a></h3>
<p>If you need to know the order of actions relative to other actions, such as, the user performed tasks A, B, and then C, and this is meaningfully different from the user performing tasks A, C and then B, (in other words, the order is meaningful beyond just the <em>fact</em> that a set of tasks were performed), use an <a href="user/metrics/event.html">event metric</a>.</p>
<p>Importantly, events are the most expensive metric type to record, transmit, store and analyze, so they should be used sparingly, and only when none of the other metric types are sufficient for answering your question.</p>
<h3><a class="header" href="#for-how-long-do-you-need-to-collect-this-data" id="for-how-long-do-you-need-to-collect-this-data">For how long do you need to collect this data?</a></h3>
<p>Think carefully about how long the metric will be needed, and set the <code>expires</code> parameter to disable the metric at the earliest possible time. 
This is an important component of Mozilla's <a href="https://www.mozilla.org/en-US/about/policy/lean-data/stay-lean/">lean data practices</a>.</p>
<p>When the metric passes its expiration date (determined at build time), it will automatically stop collecting data.</p>
<p>When a metric's expiration is within in 14 days, emails will be sent from <code>telemetry-alerts@mozilla.com</code> to the <code>notification_emails</code> addresses associated with the metric.
At that time, the metric should be removed, which involves removing it from the <code>metrics.yaml</code> file and removing uses of it in the source code.
Removing a metric does not affect the availability of data already collected by the pipeline.</p>
<p>If the metric is still needed after its expiration date, it should go back for <a href="https://wiki.mozilla.org/Firefox/Data_Collection">another round of data review</a> to have its expiration date extended.</p>
<h3><a class="header" href="#when-should-glean-automatically-clear-the-measurement" id="when-should-glean-automatically-clear-the-measurement">When should Glean automatically clear the measurement?</a></h3>
<p>The <code>lifetime</code> parameter of a metric defines when its value will be cleared. There are three lifetime options available:</p>
<ul>
<li><code>ping</code> (default): The metric is cleared each time it is submitted in the ping. This is the most common case, and should be used for metrics that are highly dynamic, such as things computed in response to the user's interaction with the application.</li>
<li><code>application</code>: The metric is related to an application run, and is cleared after the application restarts and any Glean-owned ping, due at startup, is submitted. This should be used for things that are constant during the run of an application, such as the operating system version. In practice, these metrics are generally set during application startup. A common mistake---using the ping lifetime for these type of metrics---means that they will only be included in the first ping sent during a particular run of the application.</li>
<li><code>user</code>: <strong>Reach out to the Glean team before using this.</strong>. The metric is part of the user's profile and will live as long as the profile lives. This is often not the best choice unless the metric records a value that <em>really</em> needs to be persisted for the full lifetime of the user profile, e.g. an identifier like the <code>client_id</code>, the day the product was first executed. It is rare to use this lifetime outside of some metrics that are built in to the Glean SDK.</li>
</ul>
<p>While lifetimes are important to understand for all metric types, they are particularly important for the metric types that record single values and don't aggregate on the client (<code>boolean</code>, <code>string</code>, <code>labeled_string</code>, <code>string_list</code>, <code>datetime</code> and <code>uuid</code>), since these metrics will send the &quot;last known&quot; value and missing the earlier values could be a form of unintended data loss.</p>
<h4><a class="header" href="#a-lifetime-example" id="a-lifetime-example">A lifetime example</a></h4>
<p>Let's work through an example to see how these lifetimes play out in practice. Let's suppose we have a user preference, &quot;turbo mode&quot;, which defaults to <code>false</code>, but the user can turn it to <code>true</code> at any time.  We want to know when this flag is <code>true</code> so we can measure its affect on other metrics in the same ping.  In the following diagram, we look at a time period that sends 4 pings across two separate runs of the application. We assume here, that like Glean's built-in <a href="user/pings/metrics.html">metrics ping</a>, the developer writing the metric isn't in control of when the ping is submitted. </p>
<p>In this diagram, the ping measurement windows are represented as rectangles, but the moment the ping is &quot;submitted&quot; is represented by its right edge. The user changes the &quot;turbo mode&quot; setting from <code>false</code> to <code>true</code> in the first run, and then toggles it again twice in the second run. </p>
<p><img src="user/metric-lifetime-timeline.svg" alt="Metric lifetime timeline" /></p>
<ul>
<li>
<p><strong>A. Ping lifetime, set on change</strong>: The value isn't included in Ping 1, because Glean doesn't know about it yet.  It is included in the first ping after being recorded (Ping 2), which causes it to be cleared.</p>
</li>
<li>
<p><strong>B. Ping lifetime, set on init and change</strong>: The default value is included in Ping 1, and the changed value is included in Ping 2, which causes it to be cleared.  It therefore misses Ping 3, but when the application is started, it is recorded again and it is included in Ping 4.  However, this causes it to be cleared again and it is not in Ping 5.</p>
</li>
<li>
<p><strong>C. Application lifetime, set on change</strong>: The value isn't included in Ping 1, because Glean doesn't know about it yet. After the value is changed, it is included in Pings 2 and 3, but then due to application restart it is cleared, so it is not included until the value is manually toggled again.</p>
</li>
<li>
<p><strong>D. Application, set on init and change</strong>: The default value is included in Ping 1, and the changed value is included in Pings 2 and 3. Even though the application startup causes it to be cleared, it is set again, and all subsequent pings also have the value.</p>
</li>
<li>
<p><strong>E. User, set on change</strong>: The default value is missing from Ping 1, but since <code>user</code> lifetime metrics aren't cleared unless the user profile is reset (e.g. on Android, when the product is uninstalled), it is included in all subsequent pings.</p>
</li>
<li>
<p><strong>F. User, set on init and change</strong>: Since <code>user</code> lifetime metrics aren't cleared unless the user profile is reset, it is included in all subsequent pings.  This would be true even if the &quot;turbo mode&quot; preference were never changed again.</p>
</li>
</ul>
<p>Note that for all of the metric configurations, the toggle of the preference off and on during Ping 4 is completely missed.  If you need to create a ping containing one, and only one, value for this metric, consider using a <a href="user/pings/custom.html">custom ping</a> to create a ping whose lifetime matches the lifetime of the value.</p>
<h4><a class="header" href="#what-if-none-of-these-lifetimes-are-appropriate" id="what-if-none-of-these-lifetimes-are-appropriate">What if none of these lifetimes are appropriate?</a></h4>
<p>If the timing at which the metric is sent in the ping needs to closely match the timing of the metrics value, the best option is to use a <a href="user/pings/custom.html">custom ping</a> to manually control when pings are sent.</p>
<p>This is especially useful when metrics need to be tightly related to one another, for example when you need to measure the distribution of frame paint times when a particular rendering backend is in use.  If these metrics were in different pings, with different measurement windows, it is much harder to do that kind of reasoning with much certainty.</p>
<h3><a class="header" href="#what-should-this-new-metric-be-called" id="what-should-this-new-metric-be-called">What should this new metric be called?</a></h3>
<h4><a class="header" href="#reuse-names-from-other-applications" id="reuse-names-from-other-applications">Reuse names from other applications</a></h4>
<p>There's a lot of value using the same name for analogous metrics collected across different products. For example, BigQuery makes it simple to join columns with the same name across multiple tables. Therefore, we encourage you to investigate if a similar metric is already being collected by another product. If it is, there may be an opportunity for code reuse across these products, and if all the projects are using Glean, it's easy for libraries to send their own metrics. If sharing the code doesn't make sense, at a minimum we recommend using the same metric name for similar actions and concepts whenever possible.</p>
<h4><a class="header" href="#make-names-unique-within-an-application" id="make-names-unique-within-an-application">Make names unique within an application</a></h4>
<p>Metric identifiers (the combination of a metric's category and name) must be unique across all metrics that are sent by a single application.
This includes not only the metrics defined in the app's <code>metrics.yaml</code>, but the <code>metrics.yaml</code> of any Glean-using library that the application uses, including Glean itself.
Therefore, care should be taken to name things specifically enough so as to avoid namespace collisions.
In practice, this generally involves thinking carefully about the <code>category</code> of the metric, more than the <code>name</code>.</p>
<blockquote>
<p><strong>Note:</strong> Duplicate metric identifiers are not currently detected at build time. See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1578383">bug 1578383</a> for progress on that.
However, the <a href="https://github.com/mozilla/probe-scraper">probe_scraper</a> process, which runs nightly, will detect duplicate metrics and e-mail the <code>notification_emails</code> associated with the given metrics.</p>
</blockquote>
<h4><a class="header" href="#be-as-specific-as-possible" id="be-as-specific-as-possible">Be as specific as possible</a></h4>
<p>More broadly, you should choose the names of metrics to be as specific as possible.
It is not necessary to put the type of the metric in the category or name, since this information is retained in other ways through the entire end-to-end system.</p>
<p>For example, if defining a set of events related to search, put them in a category called <code>search</code>, rather than just <code>events</code> or <code>search_events</code>. The <code>events</code> word here would be redundant.</p>
<h3><a class="header" href="#what-if-none-of-these-metric-types-is-the-right-fit" id="what-if-none-of-these-metric-types-is-the-right-fit">What if none of these metric types is the right fit?</a></h3>
<p>The current set of metrics Glean supports is based on known common use cases, but new use cases are discovered all the time.</p>
<p>Please reach out to us on <a href="https://chat.mozilla.org/#/room/#glean:mozilla.org">#glean:mozilla.org</a>. If you think you need a new metric type, we <a href="user/metrics/index.html#adding-or-changing-metric-types">have a process for that</a>.</p>
<h3><a class="header" href="#how-do-i-make-sure-my-metric-is-working" id="how-do-i-make-sure-my-metric-is-working">How do I make sure my metric is working?</a></h3>
<p>Glean has rich support for writing unit tests involving metrics. Writing a good unit test is a large topic, but in general, you should write unit tests for all new telemetry that does the following:</p>
<ul>
<li>
<p>Performs the operation being measured.</p>
</li>
<li>
<p>Asserts that metrics contain the expected data, using the <code>testGetValue</code> API on the metric.</p>
</li>
<li>
<p>Where applicable, asserts that no errors are recorded, such as when values are out of range, using the <code>testGetNumRecordedErrors</code> API.</p>
</li>
</ul>
<p>In addition to unit tests, it is good practice to validate the incoming data for the new metric on a pre-release channel to make sure things are working as expected.</p>
<!--
TODO: This will be a good place to talk about the product telemetry health
dashboard when that's ready
-->
<h2><a class="header" href="#adding-the-metric-to-the-metricsyaml-file" id="adding-the-metric-to-the-metricsyaml-file">Adding the metric to the <code>metrics.yaml</code> file</a></h2>
<p>The <a href="https://mozilla.github.io/glean_parser/metrics-yaml.html"><code>metrics.yaml</code> file</a> defines the metrics your application or library will send.
They are organized into categories.
The overall organization is:</p>
<pre><code class="language-YAML"># Required to indicate this is a `metrics.yaml` file
$schema: moz://mozilla.org/schemas/glean/metrics/1-0-0

toolbar:
  click:
    type: event
    description: |
      Event to record toolbar clicks.
    notification_emails:
      - CHANGE-ME@example.com
    bugs:
      - https://bugzilla.mozilla.org/123456789/
    data_reviews:
      - http://example.com/path/to/data-review
    expires: 2019-06-01  # &lt;-- Update to a date in the future

  double_click:
    ...

category2.subcategory:  # Categories can contain subcategories using `.`
  metric:
    ...

</code></pre>
<p>The details of the metric parameters are described in <a href="user/metric-parameters.html">metric parameters</a>.</p>
<p>The <code>metrics.yaml</code> file is used to generate code in the target language (e.g. Kotlin, Swift, ...) that becomes the public API to access your application's metrics.</p>
<h2><a class="header" href="#using-the-metric-from-your-code" id="using-the-metric-from-your-code">Using the metric from your code</a></h2>
<p>The <a href="user/metrics/index.html">reference documentation for each metric type</a> goes into detail about using each metric type from your code.</p>
<p>One thing to note is that we try to adhere to the coding conventions of each language wherever possible, to the metric name in the <code>metrics.yaml</code> (which is in <code>snake_case</code>) may be changed to some other case convention, such as <code>camelCase</code>, when used from code.</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<p>Category and metric names in the <code>metrics.yaml</code> are in <code>snake_case</code>,
but given the Kotlin coding standards defined by <a href="https://github.com/pinterest/ktlint">ktlint</a>,
these identifiers must be <code>camelCase</code> in Kotlin.
For example, the metric defined in the <code>metrics.yaml</code> as:</p>
<pre><code class="language-YAML">views:
  login_opened:
    ...
</code></pre>
<p>is accessible in Kotlin as:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Views
GleanMetrics.Views.loginOpened...
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<p>Category and metric names in the <code>metrics.yaml</code> are in <code>snake_case</code>,
but given the Swift coding standards defined by <a href="https://github.com/realm/SwiftLint">swiftlint</a>,
these identifiers must be <code>camelCase</code> in Swift.
For example, the metric defined in the <code>metrics.yaml</code> as:</p>
<pre><code class="language-YAML">views:
  login_opened:
    ...
</code></pre>
<p>is accessible in Kotlin as:</p>
<pre><code class="language-Swift">GleanMetrics.Views.loginOpened...
</code></pre>
</div>
<div data-lang="Python" class="tab">
<p>Category and metric names in the <code>metrics.yaml</code> are in <code>snake_case</code>, which matches the <a href="https://www.python.org/dev/peps/pep-0008/">PEP8</a> standard, so no translation is needed for Python.</p>
</div>
</div>
</div>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/adding-new-metrics.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#metric-parameters" id="metric-parameters">Metric parameters</a></h1>
<h2><a class="header" href="#required-metric-parameters" id="required-metric-parameters">Required metric parameters</a></h2>
<ul>
<li><code>type</code>: <strong>Required.</strong>  Specifies the type of a metric, like &quot;counter&quot; or &quot;event&quot;. This defines which operations are valid for the metric, how it is stored and how data analysis tooling displays it. See the list of <a href="user/metrics/index.html">supported metric types</a>.</li>
</ul>
<blockquote>
<p><strong>Important</strong>: Once a metric is released in a product, its <code>type</code> should not be changed. If any data was collected locally with the older <code>type</code>, and hasn't yet been sent in a ping, recording data with the new <code>type</code> may cause any old persisted data to be lost for that metric. See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1621757#c1">this comment</a> for an extended explanation of the different scenarios.</p>
</blockquote>
<ul>
<li>
<p><code>description</code>: <strong>Required.</strong> A textual description of the metric for humans. It should describe what the metric does, what it means for analysts, and its edge cases or any other helpful information.</p>
<p>The description field may contain <a href="https://www.markdownguide.org/basic-syntax/">markdown syntax</a>.</p>
</li>
<li>
<p><code>notification_emails</code>: <strong>Required.</strong> A list of email addresses to notify for important events with the metric or when people with context or ownership for the metric need to be contacted.</p>
</li>
<li>
<p><code>bugs</code>: <strong>Required.</strong> A list of bugs (e.g. Bugzilla or GitHub) that are relevant to this metric. For example, bugs that track its original implementation or later changes to it. </p>
<p>Each entry should be the full URL to the bug in an issue tracker. The use of numbers alone is deprecated and will be an error in the future.</p>
</li>
<li>
<p><code>data_reviews</code>: <strong>Required.</strong> A list of URIs to any data collection reviews <em>responses</em> relevant to the metric.</p>
</li>
<li>
<p><code>expires</code>: <strong>Required.</strong> May be one of the following values:</p>
<ul>
<li><code>&lt;build date&gt;</code>: An ISO date <code>yyyy-mm-dd</code> in UTC on which the metric expires. For example, <code>2019-03-13</code>. This date is checked at build time. Except in special cases, this form should be used so that the metric automatically &quot;sunsets&quot; after a period of time.
Emails will be sent to the <code>notification_emails</code> addresses when the metric is about to expire.
Generally, when a metric is no longer needed, it should simply be removed. This does not affect the availability of data already collected by the pipeline.</li>
<li><code>never</code>: This metric never expires.</li>
<li><code>expired</code>: This metric is manually expired.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#optional-metric-parameters" id="optional-metric-parameters">Optional metric parameters</a></h2>
<ul>
<li>
<p><code>lifetime</code>: Defines the lifetime of the metric. Different lifetimes affect when the metrics value is reset.</p>
<ul>
<li><code>ping</code> (default): The metric is cleared each time it is submitted in the ping. This is the most common case, and should be used for metrics that are highly dynamic, such as things computed in response to the user's interaction with the application.</li>
<li><code>application</code>: The metric is related to an application run, and is cleared after the application restarts and any Glean-owned ping, due at startup, is submitted. This should be used for things that are constant during the run of an application, such as the operating system version. In practice, these metrics are generally set during application startup. A common mistake---using the ping lifetime for these type of metrics---means that they will only be included in the first ping sent during a particular run of the application.</li>
<li><code>user</code>: <strong>Reach out to the Glean team before using this.</strong>. The metric is part of the user's profile and will live as long as the profile lives. This is often not the best choice unless the metric records a value that <em>really</em> needs to be persisted for the full lifetime of the user profile, e.g. an identifier like the <code>client_id</code>, the day the product was first executed. It is rare to use this lifetime outside of some metrics that are built in to the Glean SDK.</li>
</ul>
</li>
<li>
<p><code>send_in_pings</code>: Defines which pings the metric should be sent on. If not specified, the metric is sent on the &quot;default ping&quot;, which is the <code>events</code> ping for events and the <code>metrics</code> ping for everything else. Most metrics don't need to specify this unless they are sent on <a href="user/pings/custom.html">custom pings</a>.</p>
</li>
<li>
<p><code>disabled</code>: (default: <code>false</code>) Data collection for this metric is disabled.
This is useful when you want to temporarily disable the collection for a specific metric without removing references to it in your source code.
Generally, when a metric is no longer needed, it should simply be removed. This does not affect the availability of data already collected by the pipeline.</p>
</li>
<li>
<p><code>version</code>: (default: 0) The version of the metric. A monotonically increasing integer value. This should be bumped if the metric changes in a backward-incompatible way.</p>
</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metric-parameters.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#unit-testing-glean-metrics" id="unit-testing-glean-metrics">Unit testing Glean metrics</a></h1>
<p>In order to support unit testing inside of client applications using the Glean SDK, a set of testing API functions have been included.
The intent is to make the Glean SDK easier to test 'out of the box' in any client application it may be used in.
These functions expose a way to inspect and validate recorded metric values within the client application but are restricted to test code only through visibility annotations
(<code>@VisibleForTesting(otherwise = VisibleForTesting.NONE)</code> for Kotlin, <code>internal</code> methods for Swift).</p>
<h2><a class="header" href="#general-test-api-method-semantics" id="general-test-api-method-semantics">General test API method semantics</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<p>In order to prevent issues with async calls when unit testing Glean,
it is important to put the Glean SDK into testing mode by applying the JUnit <code>GleanTestRule</code> to your test class.
When the Glean SDK is in testing mode, it enables uploading and clears the recorded metrics at the beginning of each test run.
The rule can be used as shown below:</p>
<pre><code class="language-kotlin">@RunWith(AndroidJUnit4::class)
class ActivityCollectingDataTest {
    // Apply the GleanTestRule to set up a disposable Glean instance.
    // Please note that this clears the Glean data across tests.
    @get:Rule
    val gleanRule = GleanTestRule(ApplicationProvider.getApplicationContext())

    @Test
    fun checkCollectedData() {
      // The Glean SDK testing API can be called here.
    }
}
</code></pre>
<p>This will ensure that metrics are done recording when the other test functions are used.</p>
<p>To check if a value exists (i.e. it has been recorded), there is a <code>testHasValue()</code> function on each of the metric instances:</p>
<pre><code class="language-kotlin">assertTrue(GleanMetrics.Search.defaultSearchEngineUrl.testHasValue())
</code></pre>
<p>To check the actual values, there is a <code>testGetValue()</code> function on each of the metric instances.
It is important to check that the values are recorded as expected, since many of the metric types may truncate or error-correct the value.
This function will return a datatype appropriate to the specific type of the metric it is being used with:</p>
<pre><code class="language-kotlin">assertEquals(&quot;https://example.com/search?&quot;, GleanMetrics.Search.defaultSearchEngineUrl.testGetValue())
</code></pre>
<p>Note that each of these functions has its visibility limited to the scope of unit tests by making use of the <code>@VisibleForTesting</code> annotation,
so the IDE should complain if you attempt to use them inside of client code.</p>
</div>
<div data-lang="Swift" class="tab">
<blockquote>
<p><strong>NOTE</strong>: There's no automatic test rule for Glean tests implemented.</p>
</blockquote>
<p>In order to prevent issues with async calls when unit testing Glean, it is important to put the Glean SDK into testing mode.
When the Glean SDK is in testing mode, it enables uploading and clears the recorded metrics at the beginning of each test run.</p>
<p>Activate it by resetting Glean in your test's setup:</p>
<pre><code class="language-swift">@testable import Glean
import XCTest

class GleanUsageTests: XCTestCase {
    override func setUp() {
        Glean.shared.resetGlean(clearStores: true)
    }

    // ...
}
</code></pre>
<p>This will ensure that metrics are done recording when the other test functions are used.</p>
<p>To check if a value exists (i.e. it has been recorded), there is a <code>testHasValue()</code> function on each of the metric instances:</p>
<pre><code class="language-Swift">XCTAssertTrue(GleanMetrics.Search.defaultSearchEngineUrl.testHasValue())
</code></pre>
<p>To check the actual values, there is a <code>testGetValue()</code> function on each of the metric instances.
It is important to check that the values are recorded as expected, since many of the metric types may truncate or error-correct the value.
This function will return a datatype appropriate to the specific type of the metric it is being used with:</p>
<pre><code class="language-Swift">XCTAssertEqual(&quot;https://example.com/search?&quot;, try GleanMetrics.Search.defaultSearchEngineUrl.testGetValue())
</code></pre>
<p>Note that each of these functions is marked as <code>internal</code>, you need to import <code>Glean</code> explicitly in test mode:</p>
<pre><code class="language-Swift">@testable import Glean
</code></pre>
</div>
<div data-lang="Python" class="tab">
<p>It is generally a good practice to &quot;reset&quot; Glean prior to every unit test that uses Glean, to prevent side effects of one unit test impacting others.
Glean contains a helper function <code>glean.testing.reset_glean()</code> for this purpose.
It has two required arguments: the application ID, and the application version.
Each reset of Glean will create a new temporary directory for Glean to store its data in.
This temporary directory is automatically cleaned up the next time Glean is reset or when the testing framework finishes.</p>
<p>The instructions below assume you are using <a href="https://pypi.org/project/pytest/">pytest</a> as the test runner.
Other test-running libraries have similar features, but are different in the details.</p>
<p>Create a file <code>conftest.py</code> at the root of your test directory, and add the following to reset Glean at the start of every test in your suite:</p>
<pre><code class="language-python">import pytest
from glean import testing

@pytest.fixture(name=&quot;reset_glean&quot;, scope=&quot;function&quot;, autouse=True)
def fixture_reset_glean():
    testing.reset_glean(application_id=&quot;my-app-id&quot;, application_version=&quot;0.1.0&quot;)
</code></pre>
<p>To check if a value exists (i.e. it has been recorded), there is a <code>test_has_value()</code> function on each of the metric instances:</p>
<pre><code class="language-python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

# ...

assert metrics.search.search_engine_url.test_has_value()
</code></pre>
<p>To check the actual values, there is a <code>test_get_value()</code> function on each of the metric instances.
It is important to check that the values are recorded as expected, since many of the metric types may truncate or error-correct the value.
This function will return a datatype appropriate to the specific type of the metric it is being used with:</p>
<pre><code class="language-python">assert (
    &quot;https://example.com/search?&quot; ==
    metrics.search.default_search_engine_url.test_get_value()
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#testing-metrics-for-custom-pings" id="testing-metrics-for-custom-pings">Testing metrics for custom pings</a></h2>
<p>In order to test metrics where the metric is included in more than one ping, the test functions take an optional <code>pingName</code> argument (<code>ping_name</code> in Python).
This is the name of the ping that the metric is being sent in, such as <code>&quot;events&quot;</code> for the <a href="user/pings/events.html"><code>events</code> ping</a>,
or <code>&quot;metrics&quot;</code> for the <a href="user/pings/metrics.html"><code>metrics</code> ping</a>.
This could also be a custom ping name that the metric is being sent in.
In most cases you should not have to supply the ping name to the test function and can just use the default which is the &quot;default&quot; ping that this metric is sent in.
You should only need to provide a <code>pingName</code> if the metric is being sent in more than one ping in order to identify the correct metric store.</p>
<p>You can call the <code>testHasValue()</code> and <code>testGetValue()</code> functions with <code>pingName</code> like this:</p>
<pre><code class="language-kotlin">GleanMetrics.Foo.uriCount.testHasValue(&quot;customPing&quot;)
GleanMetrics.Foo.uriCount.testGetValue(&quot;customPing&quot;)
</code></pre>
<h2><a class="header" href="#example-of-using-the-test-api" id="example-of-using-the-test-api">Example of using the test API</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<p>Here is a longer example to better illustrate the intended use of the test API:</p>
<pre><code class="language-kotlin">// Record a metric value with extra to validate against
GleanMetrics.BrowserEngagement.click.record(
    mapOf(
        BrowserEngagement.clickKeys.font to &quot;Courier&quot;
    )
)

// Record more events without extras attached
BrowserEngagement.click.record()
BrowserEngagement.click.record()

// Check if we collected any events into the 'click' metric
assertTrue(BrowserEngagement.click.testHasValue())

// Retrieve a snapshot of the recorded events
val events = BrowserEngagement.click.testGetValue()

// Check if we collected all 3 events in the snapshot
assertEquals(3, events.size)

// Check extra key/value for first event in the list
assertEquals(&quot;Courier&quot;, events.elementAt(0).extra[&quot;font&quot;])
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<p>Here is a longer example to better illustrate the intended use of the test API:</p>
<pre><code class="language-Swift">// Record a metric value with extra to validate against
GleanMetrics.BrowserEngagement.click.record([.font: &quot;Courier&quot;])

// Record more events without extras attached
BrowserEngagement.click.record()
BrowserEngagement.click.record()

// Check if we collected any events into the 'click' metric
XCTAssertTrue(BrowserEngagement.click.testHasValue())

// Retrieve a snapshot of the recorded events
let events = try! BrowserEngagement.click.testGetValue()

// Check if we collected all 3 events in the snapshot
XCTAssertEqual(3, events.count)

// Check extra key/value for first event in the list
XCTAssertEqual(&quot;Courier&quot;, events[0].extra?[&quot;font&quot;])
</code></pre>
</div>
<div data-lang="Python" class="tab">
<p>Here is a longer example to better illustrate the intended use of the test API:</p>
<pre><code class="language-python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

# Record a metric value with extra to validate against
metrics.url.visit.add(1)

# Check if we collected any events into the 'click' metric
assert metrics.url.visit.test_has_value()

# Retrieve a snapshot of the recorded events
assert 1 == metrics.url.visit.test_get_value()
</code></pre>
</div>
</div>
</div>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/testing-metrics.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#debugging-products-using-the-glean-sdk" id="debugging-products-using-the-glean-sdk">Debugging products using the Glean SDK</a></h1>
<h2><a class="header" href="#platform-specific-debugging" id="platform-specific-debugging">Platform-specific debugging</a></h2>
<ol>
<li><a href="user/debugging/android.html">Debugging Android applications using the Glean SDK</a></li>
<li><a href="user/debugging/ios.html">Debugging iOS applications using the Glean SDK</a></li>
<li><a href="user/debugging/python.html">Debugging Python applications using the Glean SDK</a></li>
</ol>
<h2><a class="header" href="#general-debugging-information" id="general-debugging-information">General debugging information</a></h2>
<h3><a class="header" href="#available-commands-and-query-format" id="available-commands-and-query-format">Available commands and query format</a></h3>
<p>There are 3 available commands that you can use with the Glean SDK debug tools</p>
<ul>
<li><code>logPings</code>: This is either true or false and will cause pings that are submitted to also be echoed to the device's log</li>
<li><code>tagPings</code>: This command will tag outgoing pings with the provided value, in order to identify them in the Glean Debug View. Tags need to be string with upper and lower case letters, numbers and dashes, with a max length of 20 characters.</li>
<li><code>sendPing</code>: This command expects a string name of a ping to force immediate collection and submission of.</li>
</ul>
<p>Different platforms have different ways to send these commands.</p>
<h3><a class="header" href="#important-considerations-when-using-glean-sdk-debug-tools" id="important-considerations-when-using-glean-sdk-debug-tools">Important considerations when using Glean SDK debug tools</a></h3>
<ul>
<li>
<p>Options that are set using the flags are not immediately reset and will persist until the application is closed or manually reset.</p>
</li>
<li>
<p>There are a couple different ways in which to send pings using the Glean SDK debug tools.</p>
<ol>
<li>You can tag pings using the debug tools and trigger them manually using the UI.  This should always produce a ping with all required fields.</li>
<li>You can tag <em>and</em> send pings using the debug tools.  This has the side effect of potentially sending a ping which does not include all fields because <code>sendPing</code> triggers pings to be sent before certain application behaviors can occur which would record that information.  For example, <code>duration</code> is not calculated or included in a baseline ping sent with <code>sendPing</code> because it forces the ping to be sent before the <code>duration</code> metric has been recorded.  Keep in mind that there may be nothing to send, in which case no ping is generated.</li>
<li>You can trigger a command while the instrumented application is still running.  This is useful for toggling commands or for triggering pings that have schedules that are difficult to trigger manually.  This is especially useful if you need to trigger a ping submission after some activity within the application, such as with the metrics ping.</li>
</ol>
</li>
</ul>
<h3><a class="header" href="#glean-log-messages" id="glean-log-messages">Glean Log messages</a></h3>
<p>Glean logs warnings and errors through the platform-specific logging frameworks.  See the platform-specific instructions for information on how to view the logs.</p>
<h3><a class="header" href="#implementation-details" id="implementation-details">Implementation details</a></h3>
<p>See <a href="user/debugging/../../dev/core/internal/debug-pings.html">Debug Pings</a>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/debugging/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#debugging-android-applications-using-the-glean-sdk" id="debugging-android-applications-using-the-glean-sdk">Debugging Android applications using the Glean SDK</a></h1>
<p>The Glean SDK exports the <code>GleanDebugActivity</code> that can be used to toggle debugging features on or off.
Users can invoke this special activity, at run-time, using the following <a href="https://developer.android.com/studio/command-line/adb"><code>adb</code></a> command:</p>
<p><code>adb shell am start -n [applicationId]/mozilla.telemetry.glean.debug.GleanDebugActivity [extra keys]</code></p>
<blockquote>
<p><strong>Note:</strong> In previous versions of Glean the activity was available with the name <code>mozilla.components.service.glean.debug.GleanDebugActivity</code>.</p>
<p>If you're debugging an old build, try running:
<code>adb shell am start -n [applicationId]/mozilla.components.service.glean.debug.GleanDebugActivity [extra keys]</code></p>
</blockquote>
<p>In the above:</p>
<ul>
<li>
<p><code>[applicationId]</code> is the product's application id as defined in the manifest file and/or build script. For the Glean sample application, this is <code>org.mozilla.samples.glean</code> for a release build and <code>org.mozilla.samples.glean.debug</code> for a debug build.</p>
</li>
<li>
<p><code>[extra keys]</code> is a list of extra keys to be passed to the debug activity. See the <a href="https://developer.android.com/studio/command-line/adb#IntentSpec">documentation</a> for the command line switches used to pass the extra keys.
These are the currently supported keys:</p>
</li>
</ul>
<table><thead><tr><th>key</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>logPings</code></td><td>boolean (<code>--ez</code>)</td><td>If set to <code>true</code>, pings are dumped to logcat; defaults to <code>false</code></td></tr>
<tr><td><code>sendPing</code></td><td>string (<code>--es</code>)</td><td>Sends the ping with the given name immediately</td></tr>
<tr><td><code>tagPings</code></td><td>string (<code>--es</code>)</td><td>Tags all outgoing pings as debug pings to make them available for real-time validation, on the <a href="https://docs.telemetry.mozilla.org/concepts/glean/debug_ping_view.html">Glean Debug View</a>. The value must match the pattern <code>[a-zA-Z0-9-]{1,20}</code></td></tr>
</tbody></table>
<blockquote>
<p><strong>Note:</strong> Due to limitations on Android logcat message size, pings larger than 4KB are broken into multiple log messages when using <code>logPings</code>.</p>
</blockquote>
<p>For example, to direct a release build of the Glean sample application to (1) dump pings to logcat, (2) tag the ping with the <code>test-metrics-ping</code> tag, and (3) send the &quot;metrics&quot; ping immediately, the following command can be used:</p>
<pre><code class="language-shell">adb shell am start -n org.mozilla.samples.glean/mozilla.telemetry.glean.debug.GleanDebugActivity \
  --ez logPings true \
  --es sendPing metrics \
  --es tagPings test-metrics-ping
</code></pre>
<p>The <code>logPings</code> command doesn't trigger ping submission and you won't see any output until a ping has been submitted. You can use the <code>sendPings</code> command to force a ping to be sent, but it could be more desirable to trigger the pings submission on their normal schedule. For instance, the <code>baseline</code> and <code>events</code> pings can be triggered by moving the app out of the foreground and the <code>metrics</code> ping can be triggered normally if it is overdue for the current calendar day. See the <a href="user/debugging/../pings/index.html">ping documentation</a> for more information on ping scheduling to learn when pings are sent.</p>
<blockquote>
<p><strong>Note:</strong> In previous versions of Glean the activity was available with the name <code>mozilla.components.service.glean.debug.GleanDebugActivity</code>.</p>
<p>If you're debugging an old build, try running:</p>
<pre><code class="language-shell">adb shell am start -n org.mozilla.samples.glean/mozilla.components.service.glean.debug.GleanDebugActivity \
  --ez logPings true \
  --es sendPing metrics \
  --es tagPings test-metrics-ping
</code></pre>
</blockquote>
<h3><a class="header" href="#glean-log-messages-1" id="glean-log-messages-1">Glean Log messages</a></h3>
<p>When running a Glean-powered app in the Android emulator or on a device connected to your computer via cable, there are several ways to read the log output.</p>
<h4><a class="header" href="#android-studio" id="android-studio">Android Studio</a></h4>
<p>Android Studio can show the logs of a connected emulator or device.
To display the log messages for an app:</p>
<ol>
<li>Run an app on your device.</li>
<li>Click <strong>View &gt; Tool Windows &gt; Logcat</strong> (or click <strong>Logcat</strong> in the tool window bar).</li>
</ol>
<p>The Logcat window will show all log messages and allows to filter those by the application ID.
Select the application ID of the product you're debugging.
You can also filter by <code>Glean</code> only.</p>
<p>More information can be found in the <a href="https://developer.android.com/studio/debug/am-logcat">View Logs with Logcat</a> help article.</p>
<h4><a class="header" href="#command-line" id="command-line">Command line</a></h4>
<p>On the command line you can show all of the log output using:</p>
<pre><code class="language-shell">adb logcat
</code></pre>
<p>This is the unfiltered output of all log messages.
You can match for <code>glean</code> using grep:</p>
<pre><code class="language-shell">adb logcat | grep -i glean
</code></pre>
<p>A simple way to filter for only the application that is being debugged is by using <a href="https://github.com/JakeWharton/pidcat">pidcat</a>, a wrapper around <code>adb</code>, which adds colors and proper filtering by application ID and log level.
Run it like this to filter for an application:</p>
<pre><code class="language-shell">pidcat [applicationId]
</code></pre>
<p>In the above <code>[applicationId]</code> is the product's application id as defined in the manifest file and/or build script. For the Glean sample application, this is <code>org.mozilla.samples.glean</code> for a release build and <code>org.mozilla.samples.glean.debug</code> for a debug build.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/debugging/android.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#debugging-ios-applications-using-the-glean-sdk" id="debugging-ios-applications-using-the-glean-sdk">Debugging iOS applications using the Glean SDK</a></h1>
<p>For debugging and validation purposes on iOS, Glean makes use of a custom URL scheme which is implemented <em>within the application</em> that is consuming Glean.  Glean provides some convenience functions to facilitate this, but it's up to the consuming application to enable this functionality.  Applications that enable this Glean SDK feature will be able to launch the application from a URL with the Glean debug commands embedded in the URL itself.</p>
<h3><a class="header" href="#available-commands-and-query-format-1" id="available-commands-and-query-format-1">Available commands and query format</a></h3>
<p>There are 3 available commands that you can use with the Glean SDK debug tools</p>
<ul>
<li><code>logPings</code>: This is either true or false and will cause pings that are submitted to also be echoed to the device's log</li>
<li><code>tagPings</code>: This command will tag outgoing pings with the provided value, in order to identify them in the Glean Debug View. Tags need to be string with upper and lower case letters, numbers and dashes, with a max length of 20 characters.</li>
<li><code>sendPing</code>: This command expects a string name of a ping to force immediate collection and submission of.</li>
</ul>
<p>The structure of the custom URL uses the following format:</p>
<p><code>&lt;protocol&gt;://glean?&lt;command 1&gt;=&lt;paramter 1&gt;&amp;&lt;command 2&gt;=&lt;parameter 2&gt; ...</code></p>
<p>Where:</p>
<ul>
<li><code>&lt;protocol&gt;</code> is the &quot;URL Scheme&quot; that has been added for your app (see Instrumenting the application below), such as <code>glean-sample-app</code>.</li>
<li>This is followed by <code>://</code> and then <code>glean</code> which is required for the Glean SDK to recognize the command is meant for it to process.</li>
<li>Following standard URL query format, the next character after <code>glean</code> is the <code>?</code> indicating the beginning of the query.</li>
<li>This is followed by one or more queries in the form of <code>&lt;command&gt;=&lt;parameter&gt;</code>, where the command is one of the commands listed above, followed by an <code>=</code> and then the value or parameter to be used with the command.</li>
</ul>
<p>There are a few things to consider when creating the custom URL:</p>
<ul>
<li>Invalid commands will log an error and cause the entire URL to be ignored.</li>
<li>Not all commands are required to be encoded in the URL, you can mix and match the commands that you need.</li>
<li>Multiple instances of commands are not allowed in the same URL and, if present, will cause the entire URL to be ignored.</li>
<li>The <code>logPings</code> command doesn't trigger ping submission and you won't see any output until a ping has been submitted. You can use the <code>sendPings</code> command to force a ping to be sent, but it could be more desirable to trigger the pings submission on their normal schedule. For instance, the <code>baseline</code> and <code>events</code> pings can be triggered by moving the app out of the foreground and the <code>metrics</code> ping can be triggered normally if it is overdue for the current calendar day. See the <a href="user/debugging/../pings/index.html">ping documentation</a> for more information on ping scheduling to learn when pings are sent.</li>
</ul>
<h3><a class="header" href="#instrumenting-the-application-for-glean-debug-functionality" id="instrumenting-the-application-for-glean-debug-functionality">Instrumenting the application for Glean debug functionality</a></h3>
<p>In order to enable the debugging features in a Glean SDK consuming iOS application, it is necessary to add some information to the application's <code>Info.plist</code>, and add a line and possibly an override for a function in the <code>AppDelegate.swift</code>.</p>
<h4><a class="header" href="#register-custom-url-scheme-in-infoplist" id="register-custom-url-scheme-in-infoplist">Register custom URL scheme in <code>Info.plist</code></a></h4>
<blockquote>
<p><strong>Note:</strong> If your application already has a custom URL scheme implemented, there is no need to implement a second scheme, you can simply use that and skip to the next section about adding the convenience method.  If the app doesn't have a custom URL scheme implemented, then you will need to perform the following instructions to register your app to receive custom URLs.</p>
</blockquote>
<p>Find and open the application's <code>Info.plist</code> and right click any blank area and select <code>Add Row</code> to create a new key.</p>
<p>You will be prompted to select a key from a drop-down menu, scroll down to and select <code>URL types</code>.  This creates an array item, which can be expanded by clicking the triangle disclosure icon.</p>
<p>Select <code>Item 0</code>, click on it and click the disclosure icon to expand it and show the <code>URL identifier</code> line.  Double-click the value field and fill in your identifier, typically the same as the bundle ID.</p>
<p>Right-click on <code>Item 0</code> and select <code>Add Row</code> from the context menu.  In the dropdown menu, select <code>URL Schemes</code> to add the item.</p>
<p>Click on the disclosure icon of <code>URL Schemes</code> to expand the item, double-click the value field of <code>Item 0</code> and key in the value for your application's custom scheme.  For instance, the Glean sample app uses <code>glean-sample-app</code>, which allows for custom URLs to be crafted using that as a protocol, for example: <code>glean-sample-app://glean?logPings=true</code></p>
<h4><a class="header" href="#add-the-gleanhandlecustomurl-convenience-function-and-necessary-overrides" id="add-the-gleanhandlecustomurl-convenience-function-and-necessary-overrides">Add the <code>Glean.handleCustomUrl()</code> convenience function and necessary overrides</a></h4>
<p>In order to handle the incoming Glean SDK debug commands, it is necessary to implement the override in the application's <code>AppDelegate.swift</code> file.  Within that function, you can make use of the convenience function provided in Glean <code>handleCustomUrl(url: URL)</code>.</p>
<p>An example of a simple implementation of this would look like this:</p>
<pre><code class="language-Swift">func application(_: UIApplication,
                 open url: URL,
                 options _: [UIApplication.OpenURLOptionsKey: Any] = [:]) -&gt; Bool {
    // ...

    // This does nothing if the url isn't meant for Glean.
    Glean.shared.handleCustomUrl(url: url)

    // ...

    return true
}
</code></pre>
<p>If you need additional help setting up a custom URL scheme in your application, please refer to <a href="https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content/defining_a_custom_url_scheme_for_your_app">Apple's documentation</a>.</p>
<h3><a class="header" href="#invoking-the-glean-ios-debug-commands" id="invoking-the-glean-ios-debug-commands">Invoking the Glean-iOS debug commands</a></h3>
<p>Now that the app has the Glean SDK debug functionality enabled, there are a few ways in which we can invoke the debug commands.</p>
<h4><a class="header" href="#using-a-web-browser" id="using-a-web-browser">Using a web browser</a></h4>
<p>Perhaps the simplest way to invoke the Glean SDK debug functionality is to open a web browser and type/paste the custom URL into the address bar.  This is especially useful on an actual device because there isn't a good way to launch from the command line and process the URL for an actual device.</p>
<p>Using the glean-sample-app as an example: to activate ping logging, tag the pings to go to the Glean Debug View, and force the <code>events</code> ping to be sent, enter the following URL in a web browser on the iOS device:</p>
<pre><code class="language-shell">glean-sample-app://glean?logPings=true&amp;tagPings=My-ping-tag&amp;sendPing=events
</code></pre>
<p>This should cause iOS to prompt you with a dialog asking if you want to open the URL in the Glean Sample App, and if you select &quot;Okay&quot; then it will launch (or resume if it's already running) the application with the indicated commands and parameters and immediately force the collection and submission of the events ping.</p>
<blockquote>
<p><strong>Note:</strong> This method does not work if the browser you are using to input the command is the same application you are attempting to pass the Glean debug commands to.  So, you couldn't use Firefox for iOS to trigger commands within Firefox for iOS.</p>
</blockquote>
<p>It is also possible to encode the URL into a 2D barcode or QR code and launch the app via the camera app.  After scanning the encoded URL, the dialog prompting to launch the app should appear as if the URL were entered into the browser address bar.</p>
<h4><a class="header" href="#using-the-command-line" id="using-the-command-line">Using the command line</a></h4>
<p>This method is useful for testing via the Simulator, which typically requires a Mac with Xcode installed, including the Xcode command line tools.  In order to perform the same command as above with using the browser to input the URL, you can use the following command in the command line terminal of the Mac:</p>
<pre><code class="language-shell">xcrun simctl openurl booted &quot;glean-sample-app://glean?logPings=true&amp;tagPings=My-ping-tag&amp;sendPing=events&quot;
</code></pre>
<p>This will launch the simulator and again prompt the user with a dialog box asking if you want to open the URL in the Glean Sample App (or whichever app you are instrumenting and testing).</p>
<h3><a class="header" href="#glean-log-messages-2" id="glean-log-messages-2">Glean log messages</a></h3>
<p>If debugging in the simulator, the logging messages can be seen in the console window within Xcode.</p>
<p>When running a Glean-powered app in the iOS Simulator or on a device connected to your computer via cable, the following steps will help in getting the logs:</p>
<ol>
<li>Plug in the device and open Xcode</li>
<li>Choose Window -&gt; Devices from the menu bar</li>
<li>Under the DEVICES section in the left column, choose the device</li>
<li>To see the device console, click the up-triangle at the bottom left of the right hand panel</li>
</ol>
<blockquote>
<p><strong>Note:</strong> It is helpful to filter the console window by adding the keyword &quot;glean&quot; to the filter box.  This will allow you to see only messages generated by the Glean SDK.</p>
</blockquote>
<p>You can refer to <a href="https://developer.apple.com/library/archive/qa/qa1747/_index.html">this Apple technical Q&amp;A</a> for more information about debugging deployed iOS apps.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/debugging/ios.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#debugging-python-applications-using-the-glean-sdk" id="debugging-python-applications-using-the-glean-sdk">Debugging Python applications using the Glean SDK</a></h1>
<p>Glean provides a couple of configuration flags to assist with debugging Python applications.</p>
<h2><a class="header" href="#tagging-pings" id="tagging-pings">Tagging pings</a></h2>
<p>The <code>Glean.configuration.ping_tag</code> property can be used to add a special flag to the HTTP header so that the ping will end up in the <a href="https://docs.telemetry.mozilla.org/concepts/glean/debug_ping_view.html">Glean Debug View</a>.</p>
<p>You can set it after <code>Glean.initialize</code> is called:</p>
<pre><code class="language-py">from Glean import Glean, Configuration
Glean.initialize(
    application_id=&quot;my-app-id&quot;,
    application_version=&quot;0.1.0&quot;,
    upload_enabled=True,
)

# ...

Glean.configuration.ping_tag = &quot;my-ping-tag&quot;
</code></pre>
<p>After doing so, something like <code>pings.custom_ping.submit()</code> will send the custom ping to the Glean Debug View.</p>
<h2><a class="header" href="#logging-pings" id="logging-pings">Logging pings</a></h2>
<p>If the <code>Glean.configuration.log_pings</code> property is set to <code>True</code>, pings are
logged to the console on <code>DEBUG</code> level whenever they are submitted. You can set
this property in a similar way as the <code>ping_tag</code> property above.</p>
<p>Make sure that when you configure logging in your application, you set the
level for the <code>glean</code> logger to <code>DEBUG</code> or higher. Otherwise pings won't be
logged even if <code>log_pings</code> is set to <code>True</code>.</p>
<p>You can set the logging level for Glean to <code>DEBUG</code> as follows:</p>
<pre><code class="language-python">import logging

logging.getLogger(&quot;glean&quot;).setLevel(logging.DEBUG)
</code></pre>
<p>See the <a href="https://docs.python.org/3.8/library/logging.html">Python logging documentation</a> for more information.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/debugging/python.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#error-reporting" id="error-reporting">Error reporting</a></h1>
<p>The Glean SDK records the number of errors that occur when metrics are passed invalid data or are otherwise used incorrectly. 
This information is reported back in special labeled counter metrics in the <code>glean.error</code> category. 
Error metrics are included in the same pings as the metric that caused the error. 
Additionally, error metrics are always sent in the <a href="user/pings/metrics.html"><code>metrics</code> ping</a> ping.</p>
<p>The following categories of errors are recorded:</p>
<ul>
<li><code>invalid_value</code>: The metric value was invalid.</li>
<li><code>invalid_label</code>: The label on a labeled metric was invalid.</li>
<li><code>invalid_state</code>: The metric caught an invalid state while recording.</li>
<li><code>invalid_overflow</code>: The metric value to be recorded overflows the metric-specific upper range.</li>
</ul>
<p>For example, if you had a string metric and passed it a string that was too long:</p>
<pre><code class="language-Kotlin">MyMetrics.stringMetric.set(&quot;this_string_is_longer_than_the_limit_for_string_metrics&quot;)
</code></pre>
<p>The following error metric counter would be incremented:</p>
<pre><code class="language-Kotlin">Glean.error.invalidValue[&quot;my_metrics.string_metric&quot;].add(1)
</code></pre>
<p>Resulting in the following keys in the ping:</p>
<pre><code class="language-json">{
  &quot;metrics&quot;: {
    &quot;labeled_counter&quot;: {
      &quot;glean.error.invalid_value&quot;: {
        &quot;my_metrics.string_metric&quot;: 1
      }
    }
  }
}
</code></pre>
<p>If you have a debug build of the Glean SDK, details about the errors being recorded are included in the logs. This detailed information is not included in Glean pings.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/error-reporting.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#using-the-experiments-api" id="using-the-experiments-api">Using the experiments API</a></h1>
<p>The Glean SDK supports tagging all its pings with experiments annotations. The annotations are useful to report that experiments were active at the time the measurement were collected. The annotations are reported in the optional <code>experiments</code> entry in the <a href="user/pings/index.html"><code>ping_info</code> section</a> of all the Glean SDK pings.</p>
<blockquote>
<p><strong>Important</strong>: the experiment annotations set through this API are not persisted by the Glean SDK.
The application or consuming library is responsible for setting the relevant experiment annotations at each run.</p>
</blockquote>
<h2><a class="header" href="#api" id="api">API</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">// Annotate Glean pings with experiments data.
Glean.setExperimentActive(
  experimentId = &quot;blue-button-effective&quot;,
  branch = &quot;branch-with-blue-button&quot;,
  extra: mapOf(
    &quot;buttonLabel&quot; to &quot;test&quot;
  )
)
// After the experiment terminates, the annotation
// can be removed.
Glean.setExperimentInactive(&quot;blue-button-effective&quot;)
</code></pre>
<blockquote>
<p><strong>Important</strong>: Experiment IDs and branch don't need to be pre-defined in the Glean SDK registry files.
Please also note that the <code>extra</code> map is non-nested arbitrary <code>String</code> to <code>String</code> map.</p>
</blockquote>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">// Was the experiment annotated in Glean pings?
assertTrue(Glean.testIsExperimentActive(&quot;blue-button-effective&quot;))
// Was the correct branch reported?
assertEquals(
  &quot;branch-with-blue-button&quot;, Glean.testGetExperimentData(&quot;blue-button-effective&quot;)?.branch
)
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">// Annotate Glean pings with experiments data.
Glean.shared.setExperimentActive(
  experimentId: &quot;blue-button-effective&quot;,
  branch: &quot;branch-with-blue-button&quot;,
  extra: [&quot;buttonLabel&quot;: &quot;test&quot;]
)
// After the experiment terminates, the annotation
// can be removed.
Glean.shared.setExperimentInactive(experimentId: &quot;blue-button-effective&quot;)
</code></pre>
<blockquote>
<p><strong>Important</strong>: Experiment IDs and branch don't need to be pre-defined in the Glean SDK registry files.
Please also note that the <code>extra</code> is a non-nested <code>Dictionary</code> of type <code>[String: String]</code>.</p>
</blockquote>
<p>There are test APIs available too:</p>
<pre><code class="language-Swift">// Was the experiment annotated in Glean pings?
XCTAssertTrue(Glean.shared.testIsExperimentActive(experimentId: &quot;blue-button-effective&quot;))
// Was the correct branch reported?
XCTAssertEqual(
  &quot;branch-with-blue-button&quot;,
  Glean.testGetExperimentData(experimentId: &quot;blue-button-effective&quot;)?.branch
)
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import Glean

# Annotate Glean pings with experiments data.
Glean.set_experiment_active(
  experiment_id=&quot;blue-button-effective&quot;,
  branch=&quot;branch-with-blue-button&quot;,
  extra={
    &quot;buttonLabel&quot;: &quot;test&quot;
  }
)

# After the experiment terminates, the annotation
# can be removed.
Glean.set_experiment_inactive(&quot;blue-button-effective&quot;)
</code></pre>
<blockquote>
<p><strong>Important</strong>: Experiment IDs and branch don't need to be pre-defined in the Glean SDK registry files.
Please also note that the <code>extra</code> dict is non-nested arbitrary <code>str</code> to <code>str</code> mapping.</p>
</blockquote>
<p>There are test APIs available too:</p>
<pre><code class="language-Python">from glean import Glean

# Was the experiment annotated in Glean pings?
assert Glean.test_is_experiment_active(&quot;blue-button-effective&quot;)
# Was the correct branch reported?
assert (
    &quot;branch-with-blue-button&quot; ==
    Glean.test_get_experiment_data(&quot;blue-button-effective&quot;).branch
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits" id="limits">Limits</a></h2>
<ul>
<li><code>experimentId</code>, <code>branch</code>, and the keys and values of the 'extra' field are fixed at a maximum length of 100 bytes. Longer strings used as ids, keys, or values are truncated to their respective maximum length. (Specifically, this is measured in the number of bytes when the string is encoded in UTF-8.)</li>
<li><code>extra</code> map is limited to 20 entries. If passed a map which contains more elements than this, it is truncated to 20 elements.  <strong>WARNING</strong> Which items are truncated is nondeterministic due to the unordered nature of maps and what's left may not necessarily be the first elements added.</li>
</ul>
<p><strong>NOTE:</strong> Any truncation that occurs when recording to the Experiments API will result in an <code>invalid_value</code> error being recorded. See <a href="user/error-reporting.html">Error Reporting</a> for more information about this type of error.</p>
<h2><a class="header" href="#reference" id="reference">Reference</a></h2>
<ul>
<li><a href="user/../../javadoc/glean/mozilla.telemetry.glean/-glean.html">Kotlin API docs</a>.</li>
<li><a href="user/../../python/glean/glean.html">Python API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/experiments-api.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#metrics" id="metrics">Metrics</a></h1>
<blockquote>
<p><strong>Not sure which metric type to use?</strong> These docs contain a <a href="user/metrics/../adding-new-metrics.html#Choosing-a-metric-type">series of questions</a> that can help. Reference information about each metric type is linked below.</p>
</blockquote>
<p>There are different metrics to choose from, depending on what you want to achieve:</p>
<ul>
<li>
<p><a href="user/metrics/boolean.html">Boolean</a>: Records a single truth value, for example &quot;is a11y enabled?&quot;</p>
</li>
<li>
<p><a href="user/metrics/counter.html">Counter</a>: Used to count how often something happens, for example, how often a certain button was pressed.</p>
</li>
<li>
<p><a href="user/metrics/labeled_counters.html">Labeled counter</a>: Used to count how often something happens, for example which kind of crash occurred (<code>&quot;uncaught_exception&quot;</code> or <code>&quot;native_code_crash&quot;</code>).</p>
</li>
<li>
<p><a href="user/metrics/string.html">String</a>: Records a single Unicode string value, for example the name of the OS.</p>
</li>
<li>
<p><a href="user/metrics/labeled_strings.html">Labeled strings</a>: Records multiple Unicode string values, for example to record which kind of error occurred in different stages of a login process.</p>
</li>
<li>
<p><a href="user/metrics/string_list.html">String List</a>: Records a list of Unicode string values, for example the list of enabled search engines.</p>
</li>
<li>
<p><a href="user/metrics/timespan.html">Timespan</a>: Used to measure how much time is spent in a single task.</p>
</li>
<li>
<p><a href="user/metrics/timing_distribution.html">Timing Distribution</a>: Used to record the distribution of multiple time measurements.</p>
</li>
<li>
<p><a href="user/metrics/memory_distribution.html">Memory Distribution</a>: Used to record the distribution of memory sizes.</p>
</li>
<li>
<p><a href="user/metrics/uuid.html">UUID</a>: Used to record universally unique identifiers (UUIDs), such as a client ID.</p>
</li>
<li>
<p><a href="user/metrics/datetime.html">Datetime</a>: Used to record an absolute date and time, such as the time the user first ran the application.</p>
</li>
<li>
<p><a href="user/metrics/event.html">Events</a>: Records events e.g. individual occurrences of user actions, say every time a view was open and from where.</p>
</li>
<li>
<p><a href="user/metrics/custom_distribution.html">Custom Distribution</a>: Used to record the distribution of a value that needs fine-grained control of how the histogram buckets are computed.  <strong>Custom distributions are only available for values that come from Gecko.</strong></p>
</li>
<li>
<p><a href="user/metrics/quantity.html">Quantity</a>: Used to record a single non-negative integer value. For example, the width of the display in pixels.  <strong>Quantities are only available for values that come from Gecko.</strong></p>
</li>
</ul>
<h2><a class="header" href="#labeled-metrics" id="labeled-metrics">Labeled metrics</a></h2>
<p>There are two types of metrics listed above - <em>labeled</em> and <em>unlabeled</em> metrics. If a metric is <em>labeled</em>, it means that for a single metric entry you define in <code>metrics.yaml</code>, you can record into multiple metrics under the same name, each of the same type and identified by a different string label.</p>
<p>This is useful when you need to break down metrics by a label known at build time or run time. For example:</p>
<ul>
<li>
<p>When you want to count a different set of sub-views that users interact with, you could use <code>viewCount[&quot;view1&quot;].add()</code> and <code>viewCount[&quot;view2&quot;].add()</code>.</p>
</li>
<li>
<p>When you want to count errors that might occur for a feature, you could use <code>errorCount[errorName].add()</code>.</p>
</li>
</ul>
<p>Labeled metrics come in two forms:</p>
<ul>
<li>
<p><strong>Static labels</strong>: The labels are specified at build time in the <code>metrics.yaml</code> file.
If a label that isn't part of this set is used at run time, it is converted to the special label <code>__other__</code>.</p>
</li>
<li>
<p><strong>Dynamic labels</strong>: The labels aren't known at build time, so are set at run time.
Only the first 16 labels seen by the Glean SDK will be tracked. After that, any additional labels are converted to the special label <code>__other__</code>.</p>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Be careful with using arbitrary strings as labels and make sure they can't accidentally contain identifying data (like directory paths or user input).</p>
</blockquote>
<h3><a class="header" href="#label-format" id="label-format">Label format</a></h3>
<p>To ensure maximum support in database columns, labels must be made up of dot-separated identifiers with lowercase ASCII alphanumerics, containing underscores and dashes.</p>
<p>Specifically, they must conform to this regular expression:</p>
<pre><code>^[a-z_][a-z0-9_-]{0,29}(\\.[a-z_][a-z0-9_-]{0,29})*$
</code></pre>
<h2><a class="header" href="#adding-or-changing-metric-types" id="adding-or-changing-metric-types">Adding or changing metric types</a></h2>
<p>Glean has a <a href="https://wiki.mozilla.org/Glean/Adding_or_changing_Glean_metric_types">well-defined process</a> for requesting changes to existing metric types or suggesting the implementation of new metric types:</p>
<ol>
<li>Glean consumers need to file a bug in the <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Data%20Platform%20and%20Tools&amp;component=Glean%20Metric%20Types">Data platforms &amp; tools::Glean Metric Types</a> component, filling in the provided form;</li>
<li>The triage owner of the Bugzilla component prioritizes this within 6 business days and kicks off the <a href="https://wiki.mozilla.org/Glean/Adding_or_changing_Glean_metric_types#The_decision_making_process">decision making process</a>.</li>
<li>Once the decision process is completed, the bug is closed with a comment outlining the decision that was made.</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#boolean" id="boolean">Boolean</a></h1>
<p>Booleans are used for simple flags, for example &quot;is a11y enabled&quot;?.</p>
<h2><a class="header" href="#configuration" id="configuration">Configuration</a></h2>
<p>Say you're adding a boolean to record whether a11y is enabled on the device. First you need to add an entry for the boolean to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">flags:
  a11y_enabled:
    type: boolean
    description: &gt;
      Records whether a11y is enabled on the device.
    lifetime: application
    ...
</code></pre>
<h2><a class="header" href="#api-1" id="api-1">API</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Flags

Flags.a11yEnabled.set(System.isAccesibilityEnabled())
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Flags

// Was anything recorded?
assertTrue(Flags.a11yEnabled.testHasValue())
// Does it have the expected value?
assertTrue(Flags.a11yEnabled.testGetValue())
</code></pre>
</div>
<div data-lang="Java" class="tab">
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.Flags;

Flags.INSTANCE.a11yEnabled.set(System.isAccessibilityEnabled());
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.Flags;

// Was anything recorded?
assertTrue(Flags.INSTANCE.a11yEnabled.testHasValue());
// Does it have the expected value?
assertTrue(Flags.INSTANCE.a11yEnabled.testGetValue());
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">Flags.a11yEnabled.set(self.isAccessibilityEnabled)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssertTrue(Flags.a11yEnabled.testHasValue())
// Does the counter have the expected value?
XCTAssertTrue(try Flags.a11yEnabled.testGetValue())
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

metrics.flags.a11y_enabled.set(is_accessibility_enabled())
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.flags.a11y_enabled.test_has_value()
# Does it have the expected value?
assert True is metrics.flags.a11y_enabled.test_get_value()
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-1" id="limits-1">Limits</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<ul>
<li>Is a11y enabled?</li>
</ul>
<h2><a class="header" href="#recorded-errors" id="recorded-errors">Recorded errors</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#reference-1" id="reference-1">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-boolean-metric-type/index.html">Kotlin API docs</a></li>
<li><a href="user/metrics/../../../swift/Classes/BooleanMetricType.html">Swift API docs</a></li>
<li><a href="user/metrics/../../../python/glean/metrics/boolean.html">Python API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/boolean.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#labeled-booleans" id="labeled-booleans">Labeled Booleans</a></h1>
<p>Labeled booleans are used to record different related boolean flags.</p>
<h2><a class="header" href="#configuration-1" id="configuration-1">Configuration</a></h2>
<p>For example, you may want to record a set of flags related to accessibility (a11y).</p>
<pre><code class="language-YAML">accessibility:
  features:
    type: labeled_boolean
    description: &gt;
      a11y features enabled on the device. ...
    labels:
      - screen_reader
      - high_contrast
    ...
</code></pre>
<blockquote>
<p><strong>Note:</strong> removing or changing labels, including their order in the registry file, is permitted. Avoid reusing labels that were removed in the past. It is best practice to add documentation about removed labels to the description field so that analysts will know of their existence and meaning in historical data. Special care must be taken when changing GeckoView metrics sent through the Glean SDK, as the index of the labels is used to report Gecko data through the Glean SDK.</p>
</blockquote>
<h2><a class="header" href="#api-2" id="api-2">API</a></h2>
<p>Now you can use the labeled boolean from the application's code:</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Accessibility
Accessibility.features[&quot;screen_reader&quot;].set(isScreenReaderEnabled())
Accessibility.features[&quot;high_contrast&quot;].set(isHighContrastEnabled())
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Accessibility
// Was anything recorded?
assertTrue(Accessibility.features[&quot;screen_reader&quot;].testHasValue())
assertTrue(Accessibility.features[&quot;high_contrast&quot;].testHasValue())
// Do the booleans have the expected values?
assertEquals(True, Accessibility.features[&quot;screen_reader&quot;].testGetValue())
assertEquals(False, Accessibility.features[&quot;high_contrast&quot;].testGetValue())
// Did we record any invalid labels?
assertEquals(0, Accessibility.features.testGetNumRecordedErrors(ErrorType.InvalidLabel))
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">Accessibility.features[&quot;screen_reader&quot;].set(isScreenReaderEnabled())
Accessibility.features[&quot;high_contrast&quot;].set(isHighContrastEnabled())
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssert(Accessibility.features[&quot;screen_reader&quot;].testHasValue())
XCTAssert(Accessibility.features[&quot;high_contrast&quot;].testHasValue())
// Do the booleans have the expected values?
XCTAssertEqual(true, try Accessibility.features[&quot;screen_reader&quot;].testGetValue())
XCTAssertEqual(false, try Accessibility.features[&quot;high_contrast&quot;].testGetValue())
// Were there any invalid labels?
XCTAssertEqual(0, Accessibility.features.testGetNumRecordedErrors(.invalidLabel))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

metrics.accessibility.features[&quot;screen_reader&quot;].set(
    is_screen_reader_enabled()
)
metrics.accessibility.features[&quot;high_contrast&quot;].set(
    is_high_contrast_enabled()
)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.accessibility.features[&quot;screen_reader&quot;].test_has_value()
assert metrics.accessibility.features[&quot;high_contrast&quot;].test_has_value()
# Do the booleans have the expected values?
assert metrics.accessibility.features[&quot;screen_reader&quot;].test_get_value()
assert not metrics.accessibility.features[&quot;high_contrast&quot;].test_get_value()
# Did we record any invalid labels?
assert 0 == metrics.accessibility.features.test_get_num_recorded_errors(
    ErrorType.INVALID_LABEL
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-2" id="limits-2">Limits</a></h2>
<ul>
<li>
<p>Labels must conform to the <a href="user/metrics/index.html#label-format">label formatting regular expression</a>.</p>
</li>
<li>
<p>Labels support lowercase alphanumeric characters; they additionally allow for dots (<code>.</code>), underscores (<code>_</code>) and/or hyphens (<code>-</code>).</p>
</li>
<li>
<p>Each label must have a maximum of 60 bytes, when encoded as UTF-8.</p>
</li>
<li>
<p>If the labels are specified in the <code>metrics.yaml</code>, using any label not listed in that file will be replaced with the special value <code>__other__</code>.</p>
</li>
<li>
<p>If the labels aren't specified in the <code>metrics.yaml</code>, only 16 different dynamic labels may be used, after which the special value <code>__other__</code> will be used.</p>
</li>
</ul>
<h2><a class="header" href="#examples-1" id="examples-1">Examples</a></h2>
<ul>
<li>Record a related set of boolean flags.</li>
</ul>
<h2><a class="header" href="#recorded-errors-1" id="recorded-errors-1">Recorded Errors</a></h2>
<ul>
<li>
<p><code>invalid_label</code>: If the label contains invalid characters.</p>
</li>
<li>
<p><code>invalid_label</code>: If the label exceeds the maximum number of allowed characters.</p>
</li>
</ul>
<h2><a class="header" href="#reference-2" id="reference-2">Reference</a></h2>
<ul>
<li>Kotlin API docs <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-labeled-metric-type/index.html"><code>LabeledMetricType</code></a>, <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-boolean-metric-type/index.html"><code>BooleanMetricType</code></a></li>
<li>Swift API docs: <a href="user/metrics/../../../swift/Classes/LabeledMetricType.html"><code>LabeledMetricType</code></a>, <a href="user/metrics/../../../swift/Classes/BooleanMetricType.html"><code>BooleanMetricType</code></a></li>
<li>Python API docs: <a href="user/metrics/../../../python/glean/metrics/labeled.html"><code>LabeledMetricBase</code></a>, <a href="user/metrics/../../../python/glean/metrics/boolean.html"><code>BooleanMetricType</code></a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/labeled_booleans.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#counter" id="counter">Counter</a></h1>
<p>Used to count how often something happens, say how often a certain button was pressed. A counter always starts from <code>0</code>. Each time you record to a counter, its value is incremented.</p>
<blockquote>
<p><strong>IMPORTANT:</strong> When using a counter metric, it is important to let the Glean metric do the counting. Using your own variable for counting and setting the counter yourself could be problematic because it will be difficult to reset the value at the exact moment that the value is sent in a ping. Instead, just use <code>counter.add</code> to increment the value and let Glean handle resetting the counter.</p>
</blockquote>
<h2><a class="header" href="#configuration-2" id="configuration-2">Configuration</a></h2>
<p>Say you're adding a new counter for how often the refresh button is pressed. First you need to add an entry for the counter to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">controls:
  refresh_pressed:
    type: counter
    description: &gt;
      Counts how often the refresh button is pressed.
    ...
</code></pre>
<h2><a class="header" href="#api-3" id="api-3">API</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Controls

Controls.refreshPressed.add() // Adds 1 to the counter.
Controls.refreshPressed.add(5) // Adds 5 to the counter.
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Controls

// Was anything recorded?
assertTrue(Controls.refreshPressed.testHasValue())
// Does the counter have the expected value?
assertEquals(6, Controls.refreshPressed.testGetValue())
// Did the counter record an negative value?
assertEquals(
    1, Controls.refreshPressed.testGetNumRecordedErrors(ErrorType.InvalidValue)
)
</code></pre>
</div>
<div data-lang="Java" class="tab">
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.Controls;

Controls.INSTANCE.refreshPressed.add(); // Adds 1 to the counter.
Controls.INSTANCE.refreshPressed.add(5); // Adds 5 to the counter.
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.Controls;

// Was anything recorded?
assertTrue(Controls.INSTANCE.refreshPressed.testHasValue());
// Does the counter have the expected value?
assertEquals(6, Controls.INSTANCE.refreshPressed.testGetValue());
// Did the counter record an negative value?
assertEquals(
    1, Controls.INSTANCE.refreshPressed.testGetNumRecordedErrors(ErrorType.InvalidValue)
);
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">Controls.refreshPressed.add() // Adds 1 to the counter.
Controls.refreshPressed.add(5) // Adds 5 to the counter.
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssert(Controls.refreshPressed.testHasValue())
// Does the counter have the expected value?
XCTAssertEqual(6, try Controls.refreshPressed.testGetValue())
// Did the counter record a negative value?
XCTAssertEqual(1, Controls.refreshPressed.testGetNumRecordedErrors(.invalidValue))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

metrics.controls.refresh_pressed.add()  # Adds 1 to the counter.
metrics.controls.refresh_pressed.add(5) # Adds 5 to the counter.
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.controls.refresh_pressed.test_has_value()
# Does the counter have the expected value?
assert 6 == metrics.controls.refresh_pressed.test_get_value()
# Did the counter record an negative value?
from glean.testing import ErrorType
assert 1 == metrics.controls.refresh_pressed.test_get_num_recorded_errors(
    ErrorType.INVALID_VALUE
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-3" id="limits-3">Limits</a></h2>
<ul>
<li>Only increments, saturates at the limits of a 32-bit signed integer.</li>
</ul>
<h2><a class="header" href="#examples-2" id="examples-2">Examples</a></h2>
<ul>
<li>How often a certain button was pressed?</li>
</ul>
<h2><a class="header" href="#recorded-errors-2" id="recorded-errors-2">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>: If the counter is incremented by a non-positive value.</li>
</ul>
<h2><a class="header" href="#reference-3" id="reference-3">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-counter-metric-type/index.html">Kotlin API docs</a></li>
<li><a href="user/metrics/../../../swift/Classes/CounterMetricType.html">Swift API docs</a></li>
<li><a href="user/metrics/../../../python/glean/metrics/counter.html">Python API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/counter.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#labeled-counters" id="labeled-counters">Labeled Counters</a></h1>
<p>Labeled counters are used to record different related counts that should sum up to a total.</p>
<h2><a class="header" href="#configuration-3" id="configuration-3">Configuration</a></h2>
<p>For example, you may want to record a count of different types of crashes for your Android application, such as native code crashes and uncaught exceptions:</p>
<pre><code class="language-YAML">stability:
  crash_count:
    type: labeled_counter
    description: &gt;
      Counts the number of crashes that occur in the application. ...
    labels:
      - uncaught_exception
      - native_code_crash
    ...
</code></pre>
<blockquote>
<p><strong>Note:</strong> removing or changing labels, including their order in the registry file, is permitted. Avoid reusing labels that were removed in the past. It is best practice to add documentation about removed labels to the description field so that analysts will know of their existence and meaning in historical data. Special care must be taken when changing GeckoView metrics sent through the Glean SDK, as the index of the labels is used to report Gecko data through the Glean SDK.</p>
</blockquote>
<h2><a class="header" href="#api-4" id="api-4">API</a></h2>
<p>Now you can use the labeled counter from the application's code:</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Stability
Stability.crashCount[&quot;uncaught_exception&quot;].add() // Adds 1 to the &quot;uncaught_exception&quot; counter.
Stability.crashCount[&quot;native_code_crash&quot;].add(3) // Adds 3 to the &quot;native_code_crash&quot; counter.
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Stability
// Was anything recorded?
assertTrue(Stability.crashCount[&quot;uncaught_exception&quot;].testHasValue())
assertTrue(Stability.crashCount[&quot;native_code_crash&quot;].testHasValue())
// Do the counters have the expected values?
assertEquals(1, Stability.crashCount[&quot;uncaught_exception&quot;].testGetValue())
assertEquals(3, Stability.crashCount[&quot;native_code_crash&quot;].testGetValue())
// Were there any invalid labels?
assertEquals(0, Stability.crashCount.testGetNumRecordedErrors(ErrorType.InvalidLabel))
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">Stability.crashCount[&quot;uncaught_exception&quot;].add() // Adds 1 to the &quot;uncaught_exception&quot; counter.
Stability.crashCount[&quot;native_code_crash&quot;].add(3) // Adds 3 to the &quot;native_code_crash&quot; counter.
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssert(Stability.crashCount[&quot;uncaught_exception&quot;].testHasValue())
XCTAssert(Stability.crashCount[&quot;native_code_crash&quot;].testHasValue())
// Do the counters have the expected values?
XCTAssertEqual(1, try Stability.crashCount[&quot;uncaught_exception&quot;].testGetValue())
XCTAssertEqual(3, try Stability.crashCount[&quot;native_code_crash&quot;].testGetValue())
// Were there any invalid labels?
XCTAssertEqual(0, Stability.crashCount.testGetNumRecordedErrors(.invalidLabel))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

# Adds 1 to the &quot;uncaught_exception&quot; counter.
metrics.stability.crash_count[&quot;uncaught_exception&quot;].add()
# Adds 3 to the &quot;native_code_crash&quot; counter.
metrics.stability.crash_count[&quot;native_code_crash&quot;].add(3)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.stability.crash_count[&quot;uncaught_exception&quot;].test_has_value()
assert metrics.stability.crash_count[&quot;native_code_crash&quot;].test_has_value()
# Do the counters have the expected values?
assert 1 == metrics.stability.crash_count[&quot;uncaught_exception&quot;].test_get_value()
assert 3 == metrics.stability.crash_count[&quot;native_code_crash&quot;].test_get_value()
# Were there any invalid labels?
assert 0 == metrics.stability.crash_count.test_get_num_recorded_errors(
    ErrorType.INVALID_LABEL
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-4" id="limits-4">Limits</a></h2>
<ul>
<li>
<p>Labels must conform to the <a href="user/metrics/index.html#label-format">label formatting regular expression</a>.</p>
</li>
<li>
<p>Labels support lowercase alphanumeric characters; they additionally allow for dots (<code>.</code>), underscores (<code>_</code>) and/or hyphens (<code>-</code>).</p>
</li>
<li>
<p>Each label must have a maximum of 60 bytes, when encoded as UTF-8.</p>
</li>
<li>
<p>If the labels are specified in the <code>metrics.yaml</code>, using any label not listed in that file will be replaced with the special value <code>__other__</code>.</p>
</li>
<li>
<p>If the labels aren't specified in the <code>metrics.yaml</code>, only 16 different dynamic labels may be used, after which the special value <code>__other__</code> will be used.</p>
</li>
</ul>
<h2><a class="header" href="#examples-3" id="examples-3">Examples</a></h2>
<ul>
<li>Record the number of times different kinds of crashes occurred.</li>
</ul>
<h2><a class="header" href="#recorded-errors-3" id="recorded-errors-3">Recorded Errors</a></h2>
<ul>
<li>
<p><code>invalid_label</code>: If the label contains invalid characters.</p>
</li>
<li>
<p><code>invalid_label</code>: If the label exceeds the maximum number of allowed characters.</p>
</li>
</ul>
<h2><a class="header" href="#reference-4" id="reference-4">Reference</a></h2>
<ul>
<li>Kotlin API docs <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-labeled-metric-type/index.html"><code>LabeledMetricType</code></a>, <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-counter-metric-type/index.html"><code>CounterMetricType</code></a></li>
<li>Swift API docs: <a href="user/metrics/../../../swift/Classes/LabeledMetricType.html"><code>LabeledMetricType</code></a>, <a href="user/metrics/../../../swift/Classes/CounterMetricType.html"><code>CounterMetricType</code></a></li>
<li>Python API docs: <a href="user/metrics/../../../python/glean/metrics/labeled.html"><code>LabeledMetricBase</code></a>, <a href="user/metrics/../../../python/glean/metrics/counter.html"><code>CounterMetricType</code></a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/labeled_counters.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#strings" id="strings">Strings</a></h1>
<p>This allows recording a Unicode string value with arbitrary content.</p>
<blockquote>
<p><strong>Note</strong>: Be careful using arbitrary strings and make sure they can't accidentally contain identifying data (like directory paths or user input).</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: This is does not support recording JSON blobs - please get in contact with the Telemetry team if you're missing a type.</p>
</blockquote>
<h2><a class="header" href="#configuration-4" id="configuration-4">Configuration</a></h2>
<p>Say you're adding a metric to find out what the default search in a browser is. First you need to add an entry for the metric to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">search.default:
  name:
    type: string
    description: &gt;
      The name of the default search engine.
    lifetime: application
    ...
</code></pre>
<h2><a class="header" href="#api-5" id="api-5">API</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.SearchDefault

// Record a value into the metric.
SearchDefault.name.set(&quot;duck duck go&quot;)
// If it changed later, you can record the new value:
SearchDefault.name.set(&quot;wikipedia&quot;)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.SearchDefault

// Was anything recorded?
assertTrue(SearchDefault.name.testHasValue())
// Does the string metric have the expected value?
// IMPORTANT: It may have been truncated -- see &quot;Limits&quot; below
assertEquals(&quot;wikipedia&quot;, SearchDefault.name.testGetValue())
// Was the string truncated, and an error reported?
assertEquals(1, SearchDefault.name.testGetNumRecordedErrors(ErrorType.InvalidValue))
</code></pre>
</div>
<div data-lang="Java" class="tab">
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.SearchDefault;

// Record a value into the metric.
SearchDefault.INSTANCE.name.set(&quot;duck duck go&quot;);
// If it changed later, you can record the new value:
SearchDefault.INSTANCE.name.set(&quot;wikipedia&quot;);
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.SearchDefault

// Was anything recorded?
assertTrue(SearchDefault.INSTANCE.name.testHasValue());
// Does the string metric have the expected value?
// IMPORTANT: It may have been truncated -- see &quot;Limits&quot; below
assertEquals(&quot;wikipedia&quot;, SearchDefault.INSTANCE.name.testGetValue());
// Was the string truncated, and an error reported?
assertEquals(
    1,
    SearchDefault.INSTANCE.name.testGetNumRecordedErrors(
        ErrorType.InvalidValue
    )
);
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">// Record a value into the metric.
SearchDefault.name.set(&quot;duck duck go&quot;)
// If it changed later, you can record the new value:
SearchDefault.name.set(&quot;wikipedia&quot;)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssert(SearchDefault.name.testHasValue())
// Does the string metric have the expected value?
// IMPORTANT: It may have been truncated -- see &quot;Limits&quot; below
XCTAssertEqual(&quot;wikipedia&quot;, try SearchDefault.name.testGetValue())
// Was the string truncated, and an error reported?
XCTAssertEqual(1, SearchDefault.name.testGetNumRecordedErrors(.invalidValue))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

# Record a value into the metric.
metrics.search_default.name.set(&quot;duck duck go&quot;)
# If it changed later, you can record the new value:
metrics.search_default.name.set(&quot;wikipedia&quot;)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.search_default.name.test_has_value()
# Does the string metric have the expected value?
# IMPORTANT: It may have been truncated -- see &quot;Limits&quot; below
assert &quot;wikipedia&quot; == metrics.search_default.name.test_get_value()
# Was the string truncated, and an error reported?
assert 1 == metrics.search_default.name.test_get_num_recorded_errors(
    ErrorType.INVALID_VALUE
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-5" id="limits-5">Limits</a></h2>
<ul>
<li>Fixed maximum string length: 100. Longer strings are truncated. This is measured in the number of bytes when the string is encoded in UTF-8.</li>
</ul>
<h2><a class="header" href="#examples-4" id="examples-4">Examples</a></h2>
<ul>
<li>
<p>Record the operating system name with a value of <code>&quot;android&quot;</code>.</p>
</li>
<li>
<p>Recording the device model with a value of <code>&quot;SAMSUNG-SGH-I997&quot;</code>.</p>
</li>
</ul>
<h2><a class="header" href="#recorded-errors-4" id="recorded-errors-4">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>: if the string is too long</li>
</ul>
<h2><a class="header" href="#reference-5" id="reference-5">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-string-metric-type/index.html">Kotlin API docs</a>.</li>
<li><a href="user/metrics/../../../swift/Classes/StringMetricType.html">Swift API docs</a></li>
<li><a href="user/metrics/../../../python/glean/metrics/string.html">Python API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/string.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#labeled-strings" id="labeled-strings">Labeled Strings</a></h1>
<p>Labeled strings record multiple Unicode string values, each under a different label.</p>
<h2><a class="header" href="#configuration-5" id="configuration-5">Configuration</a></h2>
<p>For example to record which kind of error occurred in different stages of a login process - <code>&quot;RuntimeException&quot;</code> in the <code>&quot;server_auth&quot;</code> stage or <code>&quot;invalid_string&quot;</code> in the <code>&quot;enter_email&quot;</code> stage:</p>
<pre><code class="language-YAML">login:
  errors_by_stage:
    type: labeled_string
    description: Records the error type, if any, that occur in different stages of the login process.
    labels:
      - server_auth
      - enter_email
    ...
</code></pre>
<h2><a class="header" href="#api-6" id="api-6">API</a></h2>
<p>Now you can use the labeled string from the application's code:</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Login

Login.errorsByStage[&quot;server_auth&quot;].set(&quot;Invalid password&quot;)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Login

// Was anything recorded?
assertTrue(Login.errorsByStage[&quot;server_auth&quot;].testHasValue())

// Were there any invalid labels?
assertEquals(0, Login.errorsByStage.testGetNumRecordedErrors(ErrorType.InvalidLabel))
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">Login.errorsByStage[&quot;server_auth&quot;].set(&quot;Invalid password&quot;)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssert(Login.errorsByStage[&quot;server_auth&quot;].testHasValue())

// Were there any invalid labels?
XCTAssertEqual(0, Login.errorsByStage.testGetNumRecordedErrors(.invalidLabel))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

metrics.login.errors_by_stage[&quot;server_auth&quot;].set(&quot;Invalid password&quot;)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.login.errors_by_stage[&quot;server_auth&quot;].test_has_value()

# Were there any invalid labels?
assert 0 == metrics.login.errors_by_stage.test_get_num_recorded_errors(
    ErrorType.INVALID_LABEL
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-6" id="limits-6">Limits</a></h2>
<ul>
<li>
<p>Labels must conform to the <a href="user/metrics/index.html#label-format">label formatting regular expression</a>.</p>
</li>
<li>
<p>Each label must have a maximum of 60 bytes, when encoded as UTF-8.</p>
</li>
<li>
<p>If the labels are specified in the <code>metrics.yaml</code>, using any label not listed in that file will be replaced with the special value <code>__other__</code>.</p>
</li>
<li>
<p>If the labels aren't specified in the <code>metrics.yaml</code>, only 16 different dynamic labels may be used, after which the special value <code>__other__</code> will be used.</p>
</li>
</ul>
<h2><a class="header" href="#examples-5" id="examples-5">Examples</a></h2>
<ul>
<li>What kind of errors occurred at each step in the login process?</li>
</ul>
<h2><a class="header" href="#recorded-errors-5" id="recorded-errors-5">Recorded Errors</a></h2>
<ul>
<li>
<p><code>invalid_label</code>: If the label contains invalid characters.</p>
</li>
<li>
<p><code>invalid_label</code>: If the label exceeds the maximum number of allowed characters.</p>
</li>
</ul>
<h2><a class="header" href="#reference-6" id="reference-6">Reference</a></h2>
<ul>
<li>Kotlin API docs: <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-labeled-metric-type/index.html"><code>LabeledMetricType</code></a>, <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-string-metric-type/index.html"><code>StringMetricType</code></a></li>
<li>Swift API docs: <a href="user/metrics/../../../swift/Classes/LabeledMetricType.html"><code>LabeledMetricType</code></a>, <a href="user/metrics/../../../swift/Classes/StringMetricType.html"><code>StringMetricType</code></a></li>
<li>Python API docs: <a href="user/metrics/../../../python/glean/metrics/labeled.html"><code>LabeledMetricBase</code></a>, <a href="user/metrics/../../../python/glean/metrics/string.html"><code>StringMetricType</code></a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/labeled_strings.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#string-list" id="string-list">String List</a></h1>
<p>Strings lists are used for recording a list of Unicode string values, such as the names of the enabled search engines.</p>
<hr />
<p><em>Note:</em> Be careful using arbitrary strings and make sure they can't accidentally contain identifying data (like directory paths or user input).</p>
<hr />
<h2><a class="header" href="#configuration-6" id="configuration-6">Configuration</a></h2>
<p>First you need to add an entry for the counter to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">search:
  engines:
    type: string_list
    description: &gt;
      Records the name of the enabled search engines.
    lifetime: application
    ...
</code></pre>
<h2><a class="header" href="#api-7" id="api-7">API</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Search

// Add them one at a time
engines.forEach {
  Search.engines.add(it)
}

// Set them in one go
Search.engines.set(engines)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Search

// Was anything recorded?
assertTrue(Search.engines.testHasValue())
// Does it have the expected value?
// IMPORTANT: It may have been truncated -- see &quot;Limits&quot; below
assertEquals(listOf(&quot;Google&quot;, &quot;DuckDuckGo&quot;), Search.engines.testGetValue())
// Were any of the values too long, and thus an error was recorded?
assertEquals(1, Search.engines.testGetNumRecordedErrors(ErrorType.InvalidValue))
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">// Add them one at a time
for engine in engines {
    Search.engines.add(engine)
}

// Set them in one go
Search.engines.set(engines)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssert(Search.engines.testHasValue())
// Does it have the expected value?
// IMPORTANT: It may have been truncated -- see &quot;Limits&quot; below
XCTAssertEqual([&quot;Google&quot;, &quot;DuckDuckGo&quot;], try Search.engines.testGetValue())
// Were any of the values too long, and thus an error was recorded?
XCTAssertEqual(1, Search.engines.testGetNumRecordedErrors(.invalidValue))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import load_metrics

metrics = load_metrics(&quot;metrics.yaml&quot;)

# Add them one at a time
for engine in engines:
    metrics.search.engines.add(engine)

# Set them in one go
metrics.search.engines.set(engines)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.search.engines.test_has_value()
# Does it have the expected value?
# IMPORTANT: It may have been truncated -- see &quot;Limits&quot; below
assert [&quot;Google&quot;, &quot;DuckDuckGo&quot;] == metrics.search.engines.test_get_value()
# Were any of the values too long, and thus an error was recorded?
assert 1 == metrics.search.engines.test_get_num_recorded_errors(
    ErrorType.INVALID_VALUE
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-7" id="limits-7">Limits</a></h2>
<ul>
<li>
<p>Fixed maximum string length: 50. Longer strings are truncated. This is measured in the number of bytes when the string is encoded in UTF-8.</p>
</li>
<li>
<p>Fixed maximum list length: 20 items. Additional strings are dropped.</p>
</li>
</ul>
<h2><a class="header" href="#examples-6" id="examples-6">Examples</a></h2>
<ul>
<li>The names of the enabled search engines.</li>
</ul>
<h2><a class="header" href="#recorded-errors-6" id="recorded-errors-6">Recorded errors</a></h2>
<ul>
<li>
<p><code>invalid_value</code>: if the string is too long</p>
</li>
<li>
<p><code>invalid_value</code>: if the list is too long</p>
</li>
</ul>
<h2><a class="header" href="#reference-7" id="reference-7">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-string-list-metric-type/index.html">Kotlin API docs</a></li>
<li><a href="user/metrics/../../../python/glean/metrics/string_list.html">Python API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/string_list.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#timespan" id="timespan">Timespan</a></h1>
<p>Timespans are used to make a measurement of how much time is spent in a particular task.</p>
<p>To measure the distribution of multiple timespans, see <a href="user/metrics/timing_distribution.html">Timing Distributions</a>. To record absolute times, see <a href="user/metrics/datetime.html">Datetimes</a>.</p>
<p>It is not recommended to use timespans in multiple threads, since calling <code>start</code> or <code>stop</code> out of order will be recorded as an <code>invalid_state</code> error.</p>
<h2><a class="header" href="#configuration-7" id="configuration-7">Configuration</a></h2>
<p>Timespans have a required <code>time_unit</code> parameter to specify the smallest unit of resolution that the timespan will record. The allowed values for <code>time_unit</code> are:</p>
<ul>
<li><code>nanosecond</code></li>
<li><code>microsecond</code></li>
<li><code>millisecond</code></li>
<li><code>second</code></li>
<li><code>minute</code></li>
<li><code>hour</code></li>
<li><code>day</code></li>
</ul>
<p>Consider the resolution that is required by your metric, and use the largest possible value that will provide useful information so as to not leak too much fine-grained information from the client. It is important to note that the value sent in the ping is truncated down to the nearest unit. Therefore, a measurement of 500 nanoseconds will be truncated to 0 microseconds.</p>
<p>Say you're adding a new timespan for the time spent logging into the app. First you need to add an entry for the counter to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">auth:
  login_time:
    type: timespan
    description: &gt;
      Measures the time spent logging in.
    time_unit: milliseconds
    ...
</code></pre>
<h2><a class="header" href="#api-8" id="api-8">API</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Auth

fun onShowLogin() {
    Auth.loginTime.start()
    // ...
}

fun onLogin() {
    Auth.loginTime.stop()
    // ...
}

fun onLoginCancel() {
    Auth.loginTime.cancel()
    // ...
}
</code></pre>
<p>The time reported in the telemetry ping will be timespan recorded during the lifetime of the ping.</p>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Auth

// Was anything recorded?
assertTrue(Auth.loginTime.testHasValue())
// Does the timer have the expected value
assertTrue(Auth.loginTime.testGetValue() &gt; 0)
// Was the timing recorded incorrectly?
assertEquals(1, Auth.loginTime.testGetNumRecordedErrors(ErrorType.InvalidValue))
</code></pre>
</div>
<div data-lang="Java" class="tab">
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.Auth;

void onShowLogin() {
    Auth.INSTANCE.loginTime.start();
    // ...
}

void onLogin() {
    Auth.INSTANCE.loginTime.stop();
    // ...
}

void onLoginCancel() {
    Auth.INSTANCE.loginTime.cancel();
    // ...
}
</code></pre>
<p>The time reported in the telemetry ping will be timespan recorded during the lifetime of the ping.</p>
<p>There are test APIs available too:</p>
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.Auth;

// Was anything recorded?
assertTrue(Auth.INSTANCE.loginTime.testHasValue());
// Does the timer have the expected value
assertTrue(Auth.INSTANCE.loginTime.testGetValue() &gt; 0);
// Was the timing recorded incorrectly?
assertEquals(
    1,
    Auth.INSTANCE.loginTime.testGetNumRecordedErrors(
        ErrorType.InvalidValue
    )
);
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">func onShowLogin() {
    Auth.loginTime.start()
    // ...
}

func onLogin() {
    Auth.loginTime.stop()
    // ...
}

func onLoginCancel() {
    Auth.loginTime.cancel()
    // ...
}
</code></pre>
<p>The time reported in the telemetry ping will be timespan recorded during the lifetime of the ping.</p>
<p>There are test APIs available too:</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssert(Auth.loginTime.testHasValue())
// Does the timer have the expected value
XCTAssert(try Auth.loginTime.testGetValue() &gt; 0)
// Was the timing recorded incorrectly?
XCTAssertEqual(1, Auth.loginTime.testGetNumRecordedErrors(.invalidValue))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

def on_show_login():
    metrics.auth.login_time.start()
    # ...

def on_login():
    metrics.auth.login_time.stop()
    # ...

def on_login_cancel():
    metrics.auth.login_time.cancel()
    # ...
</code></pre>
<p>The time reported in the telemetry ping will be timespan recorded during the lifetime of the ping.</p>
<p>There are test APIs available too:</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.auth.login_time.test_has_value()
# Does the timer have the expected value
assert metrics.auth.login_time.test_get_value() &gt; 0
# Was the timing recorded incorrectly?
assert 1 == metrics.auth.local_time.test_get_num_recorded_errors(
    ErrorType.INVALID_VALUE
)
</code></pre>
</div>
</div>
<h2><a class="header" href="#raw-api" id="raw-api">Raw API</a></h2>
<blockquote>
<p><strong>Note</strong>: The raw API was designed to support a specific set of use-cases.
Please consider using the higher level APIs listed above.</p>
</blockquote>
<p>It's possible to explicitly set the timespan value, in nanoseconds.
This API should only be used if your library or application requires recording times in a way that can not make use of <code>start</code>/<code>stop</code>/<code>cancel</code>.</p>
<p>The raw API will not overwrite a running timer or existing timespan value.</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.HistorySync

val duration = SyncResult.status.syncs.took.toLong()
HistorySync.setRawNanos(duration)
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">let duration = SyncResult.status.syncs.took.toLong()
HistorySync.setRawNanos(duration)
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">import org.mozilla.yourApplication.GleanMetrics.HistorySync

val duration = SyncResult.status.syncs.took.toLong()
HistorySync.setRawNanos(duration)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-8" id="limits-8">Limits</a></h2>
<ul>
<li>
<p>Timings are recorded in nanoseconds.</p>
<ul>
<li>
<p>On Android, the <a href="https://developer.android.com/reference/android/os/SystemClock.html#elapsedRealtimeNanos()"><code>SystemClock.elapsedRealtimeNanos()</code></a> function is used, so it is limited by the accuracy and performance of that timer. The time measurement includes time spent in sleep.</p>
</li>
<li>
<p>On iOS, the <a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/services/services.html"><code>mach_absolute_time</code></a> function is used,
so it is limited by the accuracy and performance of that timer.
The time measurement does not include time spent in sleep.</p>
</li>
<li>
<p>On Python 3.7 and later, <a href="https://docs.python.org/3/library/time.html#time.monotonic_ns"><code>time.monotonic_ns()</code></a> is used.  On earlier versions of Python, <a href="https://docs.python.org/3/library/time.html#time.monotonic"><code>time.monotonics()</code></a> is used, which is not guaranteed to have nanosecond resolution.</p>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#examples-7" id="examples-7">Examples</a></h2>
<ul>
<li>How much time is spent rendering the UI?</li>
</ul>
<h2><a class="header" href="#recorded-errors-7" id="recorded-errors-7">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>
<ul>
<li>If recording a negative timespan.</li>
</ul>
</li>
<li><code>invalid_state</code>
<ul>
<li>If starting a timer while a previous timer is running.</li>
<li>If stopping a timer while it is not running.</li>
<li>If trying to set a raw timespan while a timer is running.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#reference-8" id="reference-8">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-timespan-metric-type/index.html">Kotlin API docs</a></li>
<li><a href="user/metrics/../../../swift/Classes/TimespanMetricType.html">Swift API docs</a></li>
<li><a href="user/metrics/../../../python/glean/metrics/timespan.html">Python API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/timespan.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#timing-distribution" id="timing-distribution">Timing Distribution</a></h1>
<p>Timing distributions are used to accumulate and store time measurement, for analyzing distributions of the timing data.</p>
<p>To measure the distribution of single timespans, see <a href="user/metrics/timespan.html">Timespans</a>. To record absolute times, see <a href="user/metrics/datetime.html">Datetimes</a>.</p>
<p>Timing distributions are recorded in a histogram where the buckets have an exponential distribution, specifically with 8 buckets for every power of 2.
That is, the function from a value \( x \) to a bucket index is:</p>
<p>\[ \lfloor 8 \log_2(x) \rfloor \]</p>
<p>This makes them suitable for measuring timings on a number of time scales without any configuration.</p>
<p>Timings always span the full length between <code>start</code> and <code>stopAndAccumulate</code>.
If the Glean upload is disabled when calling <code>start</code>, the timer is still started.
If the Glean upload is disabled at the time <code>stopAndAccumulate</code> is called, nothing is recorded.</p>
<p>Multiple concurrent timespans in different threads may be measured at the same time.</p>
<p>Timings are always stored and sent in the payload as nanoseconds. However, the <code>time_unit</code> parameter
controls the minimum and maximum values that will recorded:</p>
<ul>
<li><code>nanosecond</code>: 1ns &lt;= x &lt;= 10 minutes</li>
<li><code>microsecond</code>: 1s &lt;= x &lt;= ~6.94 days</li>
<li><code>millisecond</code>: 1ms &lt;= x &lt;= ~19 years</li>
</ul>
<p>Overflowing this range is considered an error and is reported through the error reporting mechanism. Underflowing this range is not an error and the value is silently truncated to the minimum value.</p>
<p>Additionally, when a metric comes from GeckoView (the <code>geckoview_datapoint</code> parameter is present), the <code>time_unit</code> parameter specifies the unit that the samples are in when passed to Glean. Glean will convert all of the incoming samples to nanoseconds internally.</p>
<h2><a class="header" href="#configuration-8" id="configuration-8">Configuration</a></h2>
<p>If you wanted to create a timing distribution to measure page load times, first you need to add an entry for it to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">pages:
  page_load:
    type: timing_distribution
    description: &gt;
      Counts how long each page takes to load
    ...
</code></pre>
<h2><a class="header" href="#api-9" id="api-9">API</a></h2>
<p>Now you can use the timing distribution from the application's code.
Starting a timer returns a timer ID that needs to be used to stop or cancel the timer at a later point.
Multiple intervals can be measured concurrently.
For example, to measure page load time on a number of tabs that are loading at the same time, each tab object needs to store the running timer ID.</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import mozilla.components.service.glean.GleanTimerId
import org.mozilla.yourApplication.GleanMetrics.Pages

val timerId : GleanTimerId

fun onPageStart(e: Event) {
    timerId = Pages.pageLoad.start()
}

fun onPageLoaded(e: Event) {
    Pages.pageLoad.stopAndAccumulate(timerId)
}
</code></pre>
<p>There are test APIs available too.  For convenience, properties <code>sum</code> and <code>count</code> are exposed to facilitate validating that data was recorded correctly.</p>
<p>Continuing the <code>pageLoad</code> example above, at this point the metric should have a <code>sum == 11</code> and a <code>count == 2</code>:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Pages

// Was anything recorded?
assertTrue(pages.pageLoad.testHasValue())

// Get snapshot.
val snapshot = pages.pageLoad.testGetValue()

// Does the sum have the expected value?
assertEquals(11, snapshot.sum)

// Usually you don't know the exact timing values, but how many should have been recorded.
assertEquals(2L, snapshot.count)

// Was an error recorded?
assertEquals(1, pages.pageLoad.testGetNumRecordedErrors(ErrorType.InvalidValue))
</code></pre>
</div>
<div data-lang="Java" class="tab">
<pre><code class="language-Java">import mozilla.components.service.glean.GleanTimerId;
import org.mozilla.yourApplication.GleanMetrics.Pages;

GleanTimerId timerId;

void onPageStart(Event e) {
    timerId = Pages.INSTANCE.pageLoad.start();
}

void onPageLoaded(Event e) {
    Pages.INSTANCE.pageLoad.stopAndAccumulate(timerId);
}
</code></pre>
<p>There are test APIs available too.  For convenience, properties <code>sum</code> and <code>count</code> are exposed to facilitate validating that data was recorded correctly.</p>
<p>Continuing the <code>pageLoad</code> example above, at this point the metric should have a <code>sum == 11</code> and a <code>count == 2</code>:</p>
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.Pages;

// Was anything recorded?
assertTrue(pages.INSTANCE.pageLoad.testHasValue());

// Get snapshot.
DistributionData snapshot = pages.INSTANCE.pageLoad.testGetValue();

// Does the sum have the expected value?
assertEquals(11, snapshot.getSum);

// Usually you don't know the exact timing values, but how many should have been recorded.
assertEquals(2L, snapshot.getCount);

// Was an error recorded?
assertEquals(
    1,
    pages.INSTANCE.pageLoad.testGetNumRecordedErrors(
        ErrorType.InvalidValue
    )
);
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">import Glean

var timerId : GleanTimerId

func onPageStart() {
    timerId = Pages.pageLoad.start()
}

func onPageLoaded() {
    Pages.pageLoad.stopAndAccumulate(timerId)
}
</code></pre>
<p>There are test APIs available too.  For convenience, properties <code>sum</code> and <code>count</code> are exposed to facilitate validating that data was recorded correctly.</p>
<p>Continuing the <code>pageLoad</code> example above, at this point the metric should have a <code>sum == 11</code> and a <code>count == 2</code>:</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssert(pages.pageLoad.testHasValue())

// Get snapshot.
let snapshot = try! pages.pageLoad.testGetValue()

// Does the sum have the expected value?
XCTAssertEqual(11, snapshot.sum)

// Usually you don't know the exact timing values, but how many should have been recorded.
XCTAssertEqual(2, snapshot.count)

// Was an error recorded?
XCTAssertEqual(1, pages.pageLoad.testGetNumRecordedErrors(.invalidValue))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

class PageHandler:
    def __init__(self):
        self.timer_id = None

    def on_page_start(self, event):
        # ...
        self.timer_id = metrics.pages.page_load.start()

    def on_page_loaded(self, event):
        # ...
        metrics.pages.page_load.store_and_accumulate(self.timer_id)
</code></pre>
<p>There are test APIs available too.  For convenience, properties <code>sum</code> and <code>count</code> are exposed to facilitate validating that data was recorded correctly.</p>
<p>Continuing the <code>page_load</code> example above, at this point the metric should have a <code>sum == 11</code> and a <code>count == 2</code>:</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.pages.page_load.test_has_value()

# Get snapshot.
snapshot = metrics.pages.page_load.test_get_value()

# Does the sum have the expected value?
assert 11 == snapshot.sum

# Usually you don't know the exact timing values, but how many should have been recorded.
assert 2 == snapshot.count

# Was an error recorded?
assert 1 == metrics.pages.page_load.test_get_num_recorded_errors(
    ErrorType.INVALID_VALUE
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-9" id="limits-9">Limits</a></h2>
<ul>
<li>
<p>Timings are recorded in nanoseconds.</p>
<ul>
<li>
<p>On Android, the <a href="https://developer.android.com/reference/android/os/SystemClock.html#elapsedRealtimeNanos()"><code>SystemClock.elapsedRealtimeNanos()</code></a> function is used, so it is limited by the accuracy and performance of that timer. The time measurement includes time spent in sleep.</p>
</li>
<li>
<p>On iOS, the <a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/services/services.html"><code>mach_absolute_time</code></a> function is used,
so it is limited by the accuracy and performance of that timer.
The time measurement does not include time spent in sleep.</p>
</li>
<li>
<p>On Python 3.7 and later, <a href="https://docs.python.org/3/library/time.html#time.monotonic_ns"><code>time.monotonic_ns()</code></a> is used.  On earlier versions of Python, <a href="https://docs.python.org/3/library/time.html#time.monotonic"><code>time.monotonics()</code></a> is used, which is not guaranteed to have nanosecond resolution.</p>
</li>
</ul>
</li>
<li>
<p>The maximum timing value that will be recorded depends on the <code>time_unit</code> parameter:</p>
<ul>
<li><code>nanosecond</code>: 1ns &lt;= x &lt;= 10 minutes</li>
<li><code>microsecond</code>: 1s &lt;= x &lt;= ~6.94 days</li>
<li><code>millisecond</code>: 1ms &lt;= x &lt;= ~19 years
Longer times will be truncated to the maximum value and an error will be recorded.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#examples-8" id="examples-8">Examples</a></h2>
<ul>
<li>How long does it take a page to load?</li>
</ul>
<h2><a class="header" href="#recorded-errors-8" id="recorded-errors-8">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>: If recording a negative timespan.</li>
<li><code>invalid_state</code>: If a non-existing/stopped timer is stopped again.</li>
<li><code>invalid_overflow</code>: If recording a time longer than the maximum for the given unit.</li>
</ul>
<h2><a class="header" href="#reference-9" id="reference-9">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-timing-distribution-metric-type/index.html">Kotlin API docs</a></li>
<li><a href="user/metrics/../../../swift/Classes/TimingDistributionMetricType.html">Swift API docs</a></li>
<li><a href="user/metrics/../../../python/glean/metrics/timing_distribution.html">Python API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/timing_distribution.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#memory-distribution" id="memory-distribution">Memory Distribution</a></h1>
<p>Memory distributions are used to accumulate and store memory sizes.</p>
<p>Memory distributions are recorded in a histogram where the buckets have an exponential distribution, specifically with 16 buckets for every power of 2.
That is, the function from a value \( x \) to a bucket index is:</p>
<p>\[ \lfloor 16 \log_2(x) \rfloor \]</p>
<p>This makes them suitable for measuring memory sizes on a number of different scales without any configuration.</p>
<h2><a class="header" href="#configuration-9" id="configuration-9">Configuration</a></h2>
<p>If you wanted to create a memory distribution to measure the amount of heap memory allocated, first you need to add an entry for it to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">memory:
  heap_allocated:
    type: memory_distribution
    description: &gt;
      The heap memory allocated
    memory_unit: kilobyte
    ...
</code></pre>
<h2><a class="header" href="#api-10" id="api-10">API</a></h2>
<p>Now you can use the memory distribution from the application's code.</p>
<p>For example, to measure the distribution of heap allocations:</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Memory

fun allocateMemory(nbytes: Int) {
    // ...
    Memory.heapAllocated.accumulate(nbytes / 1024)
}
</code></pre>
<p>There are test APIs available too.  For convenience, properties <code>sum</code> and <code>count</code> are exposed to facilitate validating that data was recorded correctly.</p>
<p>Continuing the <code>heapAllocated</code> example above, at this point the metric should have a <code>sum == 11</code> and a <code>count == 2</code>:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Memory

// Was anything recorded?
assertTrue(Memory.heapAllocated.testHasValue())

// Get snapshot
val snapshot = Memory.heapAllocated.testGetValue()

// Does the sum have the expected value?
assertEquals(11, snapshot.sum)

// Usually you don't know the exact memory values, but how many should have been recorded.
assertEquals(2L, snapshot.count)

// Did this record a negative value?
assertEquals(1, Memory.heapAllocated.testGetNumRecordedErrors(ErrorType.InvalidValue))
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">func allocateMemory(nbytes: UInt64) {
    // ...
    Memory.heapAllocated.accumulate(nbytes / 1024)
}
</code></pre>
<p>There are test APIs available too.  For convenience, properties <code>sum</code> and <code>count</code> are exposed to facilitate validating that data was recorded correctly.</p>
<p>Continuing the <code>heapAllocated</code> example above, at this point the metric should have a <code>sum == 11</code> and a <code>count == 2</code>:</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssert(Memory.heapAllocated.testHasValue())

// Get snapshot
let snapshot = try! Memory.heapAllocated.testGetValue()

// Does the sum have the expected value?
XCTAssertEqual(11, snapshot.sum)

// Usually you don't know the exact memory values, but how many should have been recorded.
XCTAssertEqual(2, snapshot.count)

// Did this record a negative value?
XCTAssertEqual(1, Memory.heapAllocated.testGetNumRecordedErrors(.invalidValue))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

def allocate_memory(nbytes):
    # ...
    metrics.memory.heap_allocated.accumulate(nbytes / 1024)
</code></pre>
<p>There are test APIs available too.  For convenience, properties <code>sum</code> and <code>count</code> are exposed to facilitate validating that data was recorded correctly.</p>
<p>Continuing the <code>heapAllocated</code> example above, at this point the metric should have a <code>sum == 11</code> and a <code>count == 2</code>:</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.memory.head_allocated.test_has_value()

# Get snapshot
snapshot = metrics.memory.heap_allocated.test_get_value()

# Does the sum have the expected value?
assert 11 == snapshot.sum

# Usually you don't know the exact memory values, but how many should have been recorded.
assert 2 == snapshot.count

# Did this record a negative value?
assert 1 == metrics.memory.heap_allocated.test_get_num_recorded_errors(
    ErrorType.INVALID_VALUE
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-10" id="limits-10">Limits</a></h2>
<ul>
<li>The maximum memory size that can be recorded is 1 Terabyte (2<sup>40</sup> bytes). Larger sizes will be truncated to 1 Terabyte.</li>
</ul>
<h2><a class="header" href="#examples-9" id="examples-9">Examples</a></h2>
<ul>
<li>What is the distribution of the size of heap allocations?</li>
</ul>
<h2><a class="header" href="#recorded-errors-9" id="recorded-errors-9">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>: If recording a negative memory size.</li>
<li><code>invalid_value</code>: If recording a size larger than 1TB.</li>
</ul>
<h2><a class="header" href="#reference-10" id="reference-10">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-memory-distribution-metric-type/index.html">Kotlin API docs</a></li>
<li><a href="user/metrics/../../../swift/Classes/MemoryDistributionMetricType.html">Swift API docs</a></li>
<li><a href="user/metrics/../../../python/glean/metrics/timing_distribution.html">Python API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/memory_distribution.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#uuid" id="uuid">UUID</a></h1>
<p>UUIDs are used to record values that uniquely identify some entity, such as a client id.</p>
<h2><a class="header" href="#configuration-10" id="configuration-10">Configuration</a></h2>
<p>You first need to add an entry for it to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">user:
  client_id:
    type: uuid
    description: &gt;
      A unique identifier for the client's profile
    lifetime: user
    ...
</code></pre>
<h2><a class="header" href="#api-11" id="api-11">API</a></h2>
<p>Now that the UUID is defined in <code>metrics.yaml</code>, you can use the metric to record values in the application's code.</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.User

User.clientId.generateAndSet() // Generate a new UUID and record it
User.clientId.set(UUID.randomUUID())  // Set a UUID explicitly
</code></pre>
<p>There are test APIs available too.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.User

// Was anything recorded?
assertTrue(User.clientId.testHasValue())
// Was it the expected value?
assertEquals(uuid, User.clientId.testGetValue())
</code></pre>
</div>
<div data-lang="Java" class="tab">
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.User;

User.INSTANCE.clientId.generateAndSet(); // Generate a new UUID and record it
User.INSTANCE.clientId.set(UUID.randomUUID());  // Set a UUID explicitly
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.User;

// Was anything recorded?
assertTrue(User.INSTANCE.clientId.testHasValue());
// Was it the expected value?
assertEquals(uuid, User.INSTANCE.clientId.testGetValue());
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">User.clientId.generateAndSet() // Generate a new UUID and record it
User.clientId.set(UUID())  // Set a UUID explicitly
</code></pre>
<p>There are test APIs available too.</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssert(User.clientId.testHasValue())
// Was it the expected value?
XCTAssertEqual(uuid, try User.clientId.testGetValue())
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">import uuid

from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

# Generate a new UUID and record it
metrics.user.client_id.generate_and_set()
# Set a UUID explicitly
metrics.user.client_id.set(uuid.uuid4())
</code></pre>
<p>There are test APIs available too.</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.user.client_id.test_has_value()
# Was it the expected value?
assert uuid == metrics.user.client_id.test_get_value()
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-11" id="limits-11">Limits</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#examples-10" id="examples-10">Examples</a></h2>
<ul>
<li>A unique identifier for the client.</li>
</ul>
<h2><a class="header" href="#recorded-errors-10" id="recorded-errors-10">Recorded errors</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#reference-11" id="reference-11">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-uuid-metric-type/index.html">Kotlin API docs</a>.</li>
<li><a href="user/metrics/../../../swift/Classes/UuidMetricType.html">Swift API docs</a></li>
<li><a href="user/metrics/../../../python/glean/metrics/uuid.html">Python API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/uuid.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#datetime" id="datetime">Datetime</a></h1>
<p>Datetimes are used to record an absolute date and time, for example the date and time that the application was first run.</p>
<p>The device's offset from UTC is recorded and sent with the Datetime value in the ping.</p>
<p>To measure the distribution of multiple timespans, see <a href="user/metrics/timing_distribution.html">Timing Distributions</a>. To record absolute times, see <a href="user/metrics/datetime.html">Datetimes</a>.</p>
<h2><a class="header" href="#configuration-11" id="configuration-11">Configuration</a></h2>
<p>Datetimes have a required <code>time_unit</code> parameter to specify the smallest unit of resolution that the timespan will record. The allowed values for <code>time_unit</code> are:</p>
<ul>
<li><code>nanosecond</code></li>
<li><code>microsecond</code></li>
<li><code>millisecond</code></li>
<li><code>second</code></li>
<li><code>minute</code></li>
<li><code>hour</code></li>
<li><code>day</code></li>
</ul>
<p>Carefully consider the required resolution for recording your metric, and choose the coarsest resolution possible.</p>
<p>You first need to add an entry for it to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">install:
  first_run:
    type: datetime
    time_unit: day
    description: &gt;
      Records the date when the application was first run
    lifetime: user
    ...
</code></pre>
<h2><a class="header" href="#api-12" id="api-12">API</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Install

Install.firstRun.set() // Records &quot;now&quot;
Install.firstRun.set(Calendar(2019, 3, 25)) // Records a custom datetime
</code></pre>
<p>There are test APIs available too.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Install

// Was anything recorded?
assertTrue(Install.firstRun.testHasValue())
// Was it the expected value?
// NOTE: Datetimes always include a timezone offset from UTC, hence the
// &quot;-05:00&quot; suffix.
assertEquals(&quot;2019-03-25-05:00&quot;, Install.firstRun.testGetValueAsString())
// Was the value invalid?
assertEquals(1, Install.firstRun.testGetNumRecordedErrors(ErrorType.InvalidValue))
</code></pre>
</div>
<div data-lang="Java" class="tab">
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.Install;

Install.INSTANCE.firstRun.set(); // Records &quot;now&quot;
Install.INSTANCE.firstRun.set(Calendar(2019, 3, 25)); // Records a custom datetime
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Java">import org.mozilla.yourApplication.GleanMetrics.Install;

// Was anything recorded?
assertTrue(Install.INSTANCE.firstRun.testHasValue());
// Was it the expected value?
// NOTE: Datetimes always include a timezone offset from UTC, hence the
// &quot;-05:00&quot; suffix.
assertEquals(&quot;2019-03-25-05:00&quot;, Install.INSTANCE.firstRun.testGetValueAsString());
// Was the value invalid?
assertEquals(1, Install.INSTANCE.firstRun.testGetNumRecordedErrors(ErrorType.InvalidValue));
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-Swift">Install.firstRun.set() // Records &quot;now&quot;

let dateComponents = DateComponents(
                        calendar: Calendar.current,
                        year: 2004, month: 12, day: 9, hour: 8, minute: 3, second: 29
                     )
Install.firstRun.set(dateComponents.date!) // Records a custom datetime
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Swift">@testable import Glean

// Was anything recorded?
XCTAssert(Install.firstRun.testHasValue())
// Does the datetime have the expected value?
XCTAssertEqual(6, try Install.firstRun.testGetValue())
// Was the value invalid?
XCTAssertEqual(1, Install.firstRun.getNumRecordedErrors(.invalidValue))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">import datetime

from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

# Records &quot;now&quot;
metrics.install.first_run.set()
# Records a custom datetime
metrics.install.first_run.set(datetime.datetime(2019, 3, 25))
</code></pre>
<p>There are test APIs available too.</p>
<pre><code class="language-Python"># Was anything recorded?
assert metrics.install.first_run.test_has_value()

# Was it the expected value?
# NOTE: Datetimes always include a timezone offset from UTC, hence the
# &quot;-05:00&quot; suffix.
assert &quot;2019-03-25-05:00&quot; == metrics.install.first_run.test_get_value_as_str()
# Was the value invalid?
assert 1 == metrics.install.test_get_num_recorded_errors(
    ErrorType.INVALID_VALUE
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-12" id="limits-12">Limits</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#examples-11" id="examples-11">Examples</a></h2>
<ul>
<li>When did the user first run the application?</li>
</ul>
<h2><a class="header" href="#recorded-errors-11" id="recorded-errors-11">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>: Setting the date time to an invalid value.</li>
</ul>
<h2><a class="header" href="#reference-12" id="reference-12">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-datetime-metric-type/index.html">Kotlin API docs</a></li>
<li><a href="user/metrics/../../../swift/Classes/DatetimeMetricType.html">Swift API docs</a></li>
<li><a href="user/metrics/../../../python/glean/metrics/datetime.html">Python API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/datetime.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#events" id="events">Events</a></h1>
<p>Events allow recording of e.g. individual occurrences of user actions, say every time a view was open and from where. Each time you record an event, it records a
timestamp, the event's name and a set of custom values.</p>
<h2><a class="header" href="#configuration-12" id="configuration-12">Configuration</a></h2>
<p>Say you're adding a new event for when a view is shown. First you need to add an entry for the event to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">views:
  login_opened:
    type: event
    description: &gt;
      Recorded when the login view is opened.
    ...
    extra_keys:
      source_of_login:
        description: The source from which the login view was opened, e.g. &quot;toolbar&quot;.
</code></pre>
<h2><a class="header" href="#api-13" id="api-13">API</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<p>Note that an <code>enum</code> has been generated for handling the <code>extra_keys</code>: it has the same name as the event metric, with <code>Keys</code> added.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Views

Views.loginOpened.record(mapOf(Views.loginOpenedKeys.sourceOfLogin to &quot;toolbar&quot;))
</code></pre>
<p>There are test APIs available too, for example:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Views

// Was any event recorded?
assertTrue(Views.loginOpened.testHasValue())
// Get a List of the recorded events.
val snapshot = Views.loginOpened.testGetValue()
// Check that two events were recorded.
assertEquals(2, snapshot.size)
val first = snapshot.single()
assertEquals(&quot;login_opened&quot;, first.name)
// Check that no errors were recorded
assertEquals(0, Views.loginOpened.testGetNumRecordedErrors(ErrorType.InvalidValue))
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<p>Note that an <code>enum</code> has been generated for handling the <code>extra_keys</code>: it has the same name as the event metric, with <code>Keys</code> added.</p>
<pre><code class="language-Swift">Views.loginOpened.record(extra: [.sourceOfLogin: &quot;toolbar&quot;])
</code></pre>
<p>There are test APIs available too, for example:</p>
<pre><code class="language-Kotlin">@testable import Glean

// Was any event recorded?
XCTAssert(Views.loginOpened.testHasValue())
// Get a List of the recorded events.
val snapshot = try! Views.loginOpened.testGetValue()
// Check that two events were recorded.
XCTAssertEqual(2, snapshot.size)
val first = snapshot[0]
XCTAssertEqual(&quot;login_opened&quot;, first.name)
// Check that no errors were recorded
XCTAssertEqual(0, Views.loginOpened.testGetNumRecordedErrors(.invalidValue))
</code></pre>
</div>
<div data-lang="Python" class="tab">
<p>Note that an <code>enum</code> has been generated for handling the <code>extra_keys</code>: it has the same name as the event metric, with <code>_keys</code> added.</p>
<pre><code class="language-Python">from glean import load_metrics
metrics = load_metrics(&quot;metrics.yaml&quot;)

metrics.views.login_opened.record(
    {
        metrics.views.login_opened_keys.SOURCE_OF_LOGIN: &quot;toolbar&quot;
    }
)
</code></pre>
<p>There are test APIs available too, for example:</p>
<pre><code class="language-Python"># Was any event recorded?
assert metrics.views.login_opened.test_has_value()
# Get a List of the recorded events.
snapshot = metrics.views.login_opened.test_get_value()
# Check that two events were recorded.
assert 2 == len(snapshot)
first = snapshot[0]
assert &quot;login_opened&quot; == first.name
# Check that no errors were recorded
assert 0 == metrics.views.login_opened.test_get_num_recorded_errors(
    ErrorType.INVALID_VALUE
)
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#limits-13" id="limits-13">Limits</a></h2>
<ul>
<li>
<p>When 500 events are queued on the client an events ping is immediately sent.</p>
</li>
<li>
<p>The keys in the <code>extra_keys</code> list must be in dotted snake case, with a maximum length of 40 bytes in UTF-8.</p>
</li>
<li>
<p>The values in the <code>extras</code> object have a maximum length of 50 in UTF-8.</p>
</li>
</ul>
<h2><a class="header" href="#examples-12" id="examples-12">Examples</a></h2>
<ul>
<li>Every time a new tab is opened.</li>
</ul>
<h2><a class="header" href="#recorded-errors-12" id="recorded-errors-12">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>: if any of the values in the <code>extras</code> object are greater than 50 bytes in length.</li>
</ul>
<h2><a class="header" href="#reference-13" id="reference-13">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-event-metric-type/index.html">Kotlin API docs</a>.</li>
<li><a href="user/metrics/../../../swift/Classes/EventMetricType.html">Swift API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/event.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#custom-distribution" id="custom-distribution">Custom Distribution</a></h1>
<p>Custom distributions are used to record the distribution of arbitrary values.</p>
<p>It should be used only when direct control over how the histogram buckets are computed is required.
Otherwise, look at the standard distribution metric types:</p>
<ul>
<li><a href="user/metrics/timing_distribution.html">Timing Distributions</a></li>
<li><a href="user/metrics/memory_distribution.html">Memory Distributions</a></li>
</ul>
<blockquote>
<p><strong>Note</strong>: Custom distributions are currently only allowed for GeckoView metrics (the <code>gecko_datapoint</code> parameter is present) and thus have only a Kotlin API.</p>
</blockquote>
<h2><a class="header" href="#configuration-13" id="configuration-13">Configuration</a></h2>
<p>Custom distributions have the following required parameters:</p>
<ul>
<li><code>range_min</code>: (Integer) The minimum value of the first bucket</li>
<li><code>range_max</code>: (Integer) The minimum value of the last bucket</li>
<li><code>bucket_count</code>: (Integer) The number of buckets</li>
<li><code>histogram_type</code>:
<ul>
<li><code>linear</code>: The buckets are evenly spaced</li>
<li><code>exponential</code>: The buckets follow a natural logarithmic distribution</li>
</ul>
</li>
</ul>
<p>In addition, the metric should specify:</p>
<ul>
<li><code>unit</code>: (String) The unit of the values in the metric. For documentation purposes only -- does not affect data collection.</li>
</ul>
<p>If you wanted to create a custom distribution of the peak number of pixels used during a checkerboard event, first you need to add an entry for it to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">graphics:
  checkerboard_peak:
    type: custom_distribution
    description: &gt;
      Peak number of CSS pixels checkerboarded during a checkerboard event.
    range_min: 1
    range_max: 66355200
    bucket_count: 50
    histogram_type: exponential
    unit: pixels
    gecko_datapoint: CHECKERBOARD_PEAK
    ...
</code></pre>
<h2><a class="header" href="#api-14" id="api-14">API</a></h2>
<p>Now you can use the custom distribution from the application's code.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Graphics

Graphics.checkerboardPeak.accumulateSamples([23])
</code></pre>
<p>There are test APIs available too.  For convenience, properties <code>sum</code> and <code>count</code> are exposed to facilitate validating that data was recorded correctly.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Graphics

// Was anything recorded?
assertTrue(Graphics.checkerboardPeak.testHasValue())

// Get snapshot
val snapshot = Graphics.checkerboardPeak.testGetValue()

// Does the sum have the expected value?
assertEquals(11, snapshot.sum)

// Usually you don't know the exact timing values, but how many should have been recorded.
assertEquals(2L, snapshot.count())

/// Did the metric receive a negative value?
assertEquals(1, Graphics.checkerboardPeak.testGetNumRecordedErrors(ErrorType.InvalidValue))
</code></pre>
<h2><a class="header" href="#limits-14" id="limits-14">Limits</a></h2>
<ul>
<li>
<p>The maximum value of <code>bucket_count</code> is 100.</p>
</li>
<li>
<p>Only non-negative values may be recorded.</p>
</li>
</ul>
<h2><a class="header" href="#recorded-errors-13" id="recorded-errors-13">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>: If recording a negative value.</li>
</ul>
<h2><a class="header" href="#reference-14" id="reference-14">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-custom-distribution-metric-type/index.html">Kotlin API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/custom_distribution.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#quantity" id="quantity">Quantity</a></h1>
<p>Used to record a single non-negative integer value.
For example, the width of the display in pixels.</p>
<blockquote>
<p><strong>Note</strong>: Quantities are currently only allowed for GeckoView metrics (the <code>gecko_datapoint</code> parameter is present) and thus have only a Kotlin API.</p>
</blockquote>
<h2><a class="header" href="#configuration-14" id="configuration-14">Configuration</a></h2>
<p>Say you're adding a new quantity for the width of the display in pixels. First you need to add an entry for the quantity to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">gfx:
  display_width:
    type: quantity
    description: &gt;
      The width of the display, in pixels.
    unit: pixels
    gecko_datapoint: DISPLAY_W_PIXELS
    ...
</code></pre>
<p>Note that quantities have a required <code>unit</code> parameter, which is a free-form string for documentation purposes.</p>
<h2><a class="header" href="#api-15" id="api-15">API</a></h2>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Gfx

Gfx.displayWidth.set(width)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Gfx

// Was anything recorded?
assertTrue(Gfx.displayWidth.testHasValue())
// Does the quantity have the expected value?
assertEquals(6, Gfx.displayWidth.testGetValue())
// Did it record an error due to a negative value?
assertEquals(1, Gfx.displayWidth.testGetNumRecordedErrors(ErrorType.InvalidValue))
</code></pre>
<h2><a class="header" href="#limits-15" id="limits-15">Limits</a></h2>
<ul>
<li>
<p>Quantities must be non-negative integers.</p>
</li>
<li>
<p>Quantities are only available for metrics that come from Gecko.</p>
</li>
</ul>
<h2><a class="header" href="#examples-13" id="examples-13">Examples</a></h2>
<ul>
<li>What is the width of the display, in pixels?</li>
</ul>
<h2><a class="header" href="#recorded-errors-14" id="recorded-errors-14">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>: If a negative value is passed in.</li>
</ul>
<h2><a class="header" href="#reference-15" id="reference-15">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-quantity-metric-type/index.html">Kotlin API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/metrics/quantity.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#glean-pings" id="glean-pings">Glean Pings</a></h1>
<p>Every Glean ping is in JSON format and contains one or more of the <a href="user/pings/index.html#ping-sections">common sections</a> with shared information data.</p>
<p>If data collection is enabled, the Glean SDK provides a set of built-in pings that are assembled out of the box without any developer intervention.  The following is a list of these built-in pings:</p>
<ul>
<li><a href="user/pings/baseline.html"><code>baseline</code> ping</a>: A small ping sent every time the application goes to foreground and background. Going to foreground also includes when the application starts.</li>
<li><a href="user/pings/metrics.html"><code>metrics</code> ping</a>: The default ping for metrics. Sent approximately daily.</li>
<li><a href="user/pings/events.html"><code>events</code> ping</a>: The default ping for events. Sent every time the application goes to background or a certain number of events is reached.</li>
<li><a href="user/pings/deletion_request.html"><code>deletion-request</code> ping</a>: Sent when the user disables telemetry in order to request a deletion of their data.</li>
</ul>
<p>Applications can also define and send their own <a href="user/pings/custom.html">custom pings</a> when the schedules of these pings is not suitable.</p>
<p>There is also a <a href="user/pings/ping-schedules-and-timings.html">high-level overview</a> of how the <code>metrics</code> and <code>baseline</code> pings relate and the timings they record.</p>
<h2><a class="header" href="#ping-sections" id="ping-sections">Ping sections</a></h2>
<p>There are two standard metadata sections that are added to most pings, in addition to their core metrics and events content (which are described in <a href="user/pings/../adding-new-metrics.html">Adding new metrics</a>).</p>
<ul>
<li>
<p>The <a href="user/pings/index.html#The-ping_info-section"><code>ping_info</code> section</a> contains core metadata that is included in <strong>every</strong> ping.</p>
</li>
<li>
<p>The <a href="user/pings/index.html#The-client_info-section"><code>client_info</code> section</a> contains information that identifies the client.
It is included in most pings (including all built-in pings), but may be excluded from pings where we don't want to connect client information with the other metrics in the ping.</p>
</li>
</ul>
<h3><a class="header" href="#the-ping_info-section" id="the-ping_info-section">The <code>ping_info</code> section</a></h3>
<p>The following fields are included in the <code>ping_info</code> section, for every ping.
Optional fields are marked accordingly.</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ping_type</code></td><td>String</td><td>The name of the ping type (e.g. &quot;baseline&quot;, &quot;metrics&quot;)</td></tr>
<tr><td><code>seq</code></td><td>Counter</td><td>A running counter of the number of times pings of this type have been sent</td></tr>
<tr><td><code>experiments</code></td><td>Object</td><td><em>Optional</em>. A dictionary of <a href="user/pings/index.html#the-experiments-object">active experiments</a></td></tr>
<tr><td><code>start_time</code></td><td>Datetime</td><td>The time of the start of collection of the data in the ping, in local time and with minute precision, including timezone information.</td></tr>
<tr><td><code>end_time</code></td><td>Datetime</td><td>The time of the end of collection of the data in the ping, in local time and with minute precision, including timezone information. This is also the time this ping was generated and is likely well before ping transmission time.</td></tr>
<tr><td><code>reason</code></td><td>String</td><td><em>Optional</em>. The reason the ping was submitted. The specific set of values and their meanings are defined for each metric type in the <code>reasons</code> field in the <code>pings.yaml</code> file.</td></tr>
</tbody></table>
<p>All the metrics surviving application restarts (e.g. <code>seq</code>, ...) are removed once the application using the Glean SDK is uninstalled.</p>
<h3><a class="header" href="#the-client_info-section" id="the-client_info-section">The <code>client_info</code> section</a></h3>
<p>The following fields are included in the <code>client_info</code> section.
Optional fields are marked accordingly.</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>app_build</code></td><td>String</td><td>The build identifier generated by the CI system (e.g. &quot;1234/A&quot;)</td></tr>
<tr><td><code>app_channel</code></td><td>String</td><td><em>Optional</em> The product-provided release channel (e.g. &quot;beta&quot;)</td></tr>
<tr><td><code>app_display_version</code></td><td>String</td><td>The user-visible version string (e.g. &quot;1.0.3&quot;)</td></tr>
<tr><td><code>architecture</code></td><td>String</td><td>The architecture of the device (e.g. &quot;arm&quot;, &quot;x86&quot;)</td></tr>
<tr><td><code>client_id</code></td><td>UUID</td><td><em>Optional</em> A UUID identifying a profile and allowing user-oriented correlation of data</td></tr>
<tr><td><code>device_manufacturer</code></td><td>String</td><td><em>Optional</em> The manufacturer of the device</td></tr>
<tr><td><code>device_model</code></td><td>String</td><td><em>Optional</em> The model name of the device. On Android, this is <a href="https://developer.android.com/reference/android/os/Build.html#MODEL"><code>Build.MODEL</code></a>, the user-visible name of the device.</td></tr>
<tr><td><code>first_run_date</code></td><td>Datetime</td><td>The date of the first run of the application, in local time and with day precision, including timezone information.</td></tr>
<tr><td><code>os</code></td><td>String</td><td>The name of the operating system (e.g. &quot;linux&quot;, &quot;Android&quot;, &quot;ios&quot;)</td></tr>
<tr><td><code>os_version</code></td><td>String</td><td>The user-visible version of the operating system (e.g. &quot;1.2.3&quot;)</td></tr>
<tr><td><code>android_sdk_version</code></td><td>String</td><td><em>Optional</em>. The Android specific SDK version of the software running on this hardware device (e.g. &quot;23&quot;)</td></tr>
<tr><td><code>telemetry_sdk_build</code></td><td>String</td><td>The version of the Glean SDK</td></tr>
<tr><td><code>locale</code></td><td>String</td><td><em>Optional</em>. The locale of the application during initialization (e.g. &quot;es-ES&quot;). If the locale can't be determined on the system, the value is &quot;und&quot;, to indicate &quot;undetermined&quot;.</td></tr>
</tbody></table>
<p>All the metrics surviving application restarts (e.g. <code>client_id</code>, ...) are removed once the application using the Glean SDK is uninstalled.</p>
<h3><a class="header" href="#the-experiments-object" id="the-experiments-object">The <code>experiments</code> object</a></h3>
<p>This object (included in the <a href="user/pings/index.html#The-ping_info-section"><code>ping_info</code> section</a>) contains experiments keyed by the experiment <code>id</code>. Each listed experiment contains the <code>branch</code> the client is enrolled in and may contain a string to string map with additional data in the <code>extra</code> key. Both the <code>id</code> and <code>branch</code> are truncated to 30 characters.
See <a href="user/pings/../experiments-api.html">Using the Experiments API</a> on how to record experiments data.</p>
<pre><code class="language-json">{
  &quot;&lt;id&gt;&quot;: {
    &quot;branch&quot;: &quot;branch-id&quot;,
    &quot;extra&quot;: {
      &quot;some-key&quot;: &quot;a-value&quot;
    }
  }
}
</code></pre>
<h2><a class="header" href="#ping-submission" id="ping-submission">Ping submission</a></h2>
<p>The pings that the Glean SDK generates are submitted to the Mozilla servers at specific paths, in order to provide additional metadata without the need to unpack the ping payload.
A typical submission URL looks like</p>
<p><code>&quot;&lt;server-address&gt;/submit/&lt;application-id&gt;/&lt;doc-type&gt;/&lt;glean-schema-version&gt;/&lt;document-id&gt;&quot;</code></p>
<p>where:</p>
<ul>
<li><code>&lt;server-address&gt;</code>: the address of the server that receives the pings;</li>
<li><code>&lt;application-id&gt;</code>: a unique application id, automatically detected by the Glean SDK; this is the value returned by <a href="http://developer.android.com/reference/android/content/Context.html#getPackageName()"><code>Context.getPackageName()</code></a>;</li>
<li><code>&lt;doc-type&gt;</code>: the name of the ping; this can be one of the pings available out of the box with the Glean SDK, or a custom ping;</li>
<li><code>&lt;glean-schema-version&gt;</code>: the version of the Glean ping schema;</li>
<li><code>&lt;document-id&gt;</code>: a unique identifier for this ping.</li>
</ul>
<h3><a class="header" href="#submitted-headers" id="submitted-headers">Submitted headers</a></h3>
<p>A pre-defined set of headers is additionally sent along with the submitted ping:</p>
<table><thead><tr><th>Header</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Content-Type</code></td><td><code>application/json; charset=utf-8</code></td><td>Describes the data sent to the server</td></tr>
<tr><td><code>User-Agent</code></td><td>Defaults to e.g. <code>Glean/0.40.0 (Android)</code>, where <code>0.40.0</code> is the Glean SDK version number and <code>Android</code> is the platform name. It can be overridden by user through <a href="user/pings/../../../javadoc/glean/mozilla.telemetry.glean/-configuration/index.html">configuration</a></td><td>Describes the application sending the ping using the Glean SDK</td></tr>
<tr><td><code>Date</code></td><td>e.g. <code>Mon, 23 Jan 2019 10:10:10 GMT+00:00</code></td><td>Submission date/time in GMT/UTC+0 offset</td></tr>
<tr><td><code>X-Client-Type</code></td><td><code>Glean</code></td><td>Custom header to support handling of Glean pings in the legacy pipeline</td></tr>
<tr><td><code>X-Client-Version</code></td><td>e.g. <code>0.40.0</code></td><td>The Glean SDK version, sent as a custom header to support handling of Glean pings in the legacy pipeline</td></tr>
</tbody></table>
<h2><a class="header" href="#defining-foreground-and-background-state" id="defining-foreground-and-background-state">Defining foreground and background state</a></h2>
<p>These docs refer to application 'foreground' and 'background' state in several places.</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<h4><a class="header" href="#foreground" id="foreground">Foreground</a></h4>
<p>For Android, this specifically means the activity becomes visible to the user, it has entered the <code>Started</code> state, and the system invokes the <a href="https://developer.android.com/reference/android/app/Activity.html#onStart()"><code>onStart()</code></a> callback.</p>
<h3><a class="header" href="#background" id="background">Background</a></h3>
<p>This specifically means when the activity is no longer visible to the user, it has entered the <code>Stopped</code> state, and the system invokes the <a href="https://developer.android.com/reference/android/app/Activity.html#onStop()"><code>onStop()</code></a> callback.</p>
<p>This may occur, if the user uses <code>Overview</code> button to change to another app, the user presses the <code>Back</code> button and
navigates to a previous application or the home screen, or if the user presses the <code>Home</code> button to return to the
home screen.  This can also occur if the user navigates away from the application through some notification or
other means.</p>
<p>The system may also call <code>onStop()</code> when the activity has finished running, and is about to be terminated.</p>
</div>
<div data-lang="Swift" class="tab">
<h3><a class="header" href="#foreground-1" id="foreground-1">Foreground</a></h3>
<p>For iOS, Glean attaches to the <a href="https://developer.apple.com/documentation/uikit/uiapplication/1622944-willenterforegroundnotification"><code>willEnterForegroundNotification</code></a>.
This notification is posted by the OS shortly before an app leaves the background state on its way to becoming the active app.</p>
<h3><a class="header" href="#background-1" id="background-1">Background</a></h3>
<p>For iOS, this specifically means when the app is no longer visible to the user, or when the <code>UIApplicationDelegate</code>
receives the <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622997-applicationdidenterbackground"><code>applicationDidEnterBackground</code></a> event.</p>
<p>This may occur if the user opens the task switcher to change to another app, or if the user presses the <code>Home</code> button
to show the home screen.  This can also occur if the user navigates away from the app through a notification or other
means.</p>
<blockquote>
<p><strong>Note:</strong> Glean does not currently support <a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle">Scene based lifecycle events</a> that were introduced in iOS 13.</p>
</blockquote>
</div>
</div>
</div>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/pings/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#ping-schedules-and-timings-overview" id="ping-schedules-and-timings-overview">Ping schedules and timings overview</a></h1>
<p>Full reference details about the <a href="user/pings/metrics.html"><code>metrics</code></a> and <a href="user/pings/baseline.html"><code>baseline</code></a> ping schedules are detailed elsewhere.</p>
<p>The following diagram shows a typical timeline of a mobile application, when pings are sent and what timing-related information is included.</p>
<p><img src="user/pings/ping_timing.svg" alt="ping timeline diagram" /></p>
<p>There are two distinct runs of the application, where the OS shutdown the application at the end of Run 1, and the user started it up again at the beginning of Run 2.</p>
<p>There are three distinct foreground sessions, where the application was visible on the screen and the user was able to interact with it.</p>
<p>The rectangles for the <code>baseline</code> and <code>metrics</code> pings represent the measurement windows of those pings, which always start exactly at the end of the preceding ping.  The <code>ping_info.start_time</code> and <code>ping_info.end_time</code> metrics included in these pings correspond to these beginning and the end of their measurement windows.</p>
<p>The <code>baseline.duration</code> metric (included only in <code>baseline</code> pings) corresponds to amount of time the application spent on the foreground, which, since measurement window always extend to the next ping, is not always the same thing as the <code>baseline</code> ping's measurement window.</p>
<p>The <code>submission_timestamp</code> is the time the ping was received at the telemetry endpoint, added by the ingestion pipeline.  It is not exactly the same as <code>ping_info.end_time</code>, since there may be various networking and system latencies both on the client and in the ingestion pipeline (represented by the dotted horizontal line, not to scale).  Also of note is that <code>start_time</code>/<code>end_time</code> are measured using the client's real-time clock in its local timezone, which is not a fully reliable source of time.</p>
<p>The &quot;Baseline 4&quot; ping illustrates an important corner case. When &quot;Session 2&quot; ended, the OS also shut down the entire process, and the Glean SDK did not have an opportunity to send a <code>baseline</code> ping immediately.  In this case, it is sent at the next available opportunity when the application starts up again in &quot;Run 2&quot;.  This <code>baseline</code> ping is annotated with the reason code <code>dirty_startup</code>.</p>
<p>The &quot;Metrics 2&quot; ping likewise illustrates another important corner case. &quot;Metrics 1&quot; was able to be sent at the target time of 04:00 (local device time) because the application was currently running.  However, the next time 04:00 came around, the application was not active, so the Glean SDK was unable to send a <code>metrics</code> ping.  It is sent at the next available opportunity, when the application starts up again in &quot;Run 2&quot;.  This <code>metrics</code> ping is annotated with the reason code <code>overdue</code>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/pings/ping-schedules-and-timings.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#the-baseline-ping" id="the-baseline-ping">The <code>baseline</code> ping</a></h1>
<h2><a class="header" href="#description" id="description">Description</a></h2>
<p>This ping is intended to provide metrics that are managed by the library itself, and not explicitly set by the application or included in the application's <code>metrics.yaml</code> file.</p>
<blockquote>
<p><strong>Note:</strong> As the <code>baseline</code> ping was specifically designed for mobile operating systems, it is not sent when using the Glean Python bindings.</p>
</blockquote>
<h2><a class="header" href="#scheduling" id="scheduling">Scheduling</a></h2>
<p>The <code>baseline</code> ping is automatically submitted with a <code>reason: foreground</code> when the application is moved to the <a href="user/pings/index.html#defining-background-state">foreground</a>.  These baseline pings do not contain <code>duration</code>.</p>
<p>The <code>baseline</code> ping is automatically submitted with a <code>reason: background</code> when the application is moved to the <a href="user/pings/index.html#defining-background-state">background</a>.
Occasionally, the <code>baseline</code> ping may fail to send when going to background (e.g. the process is killed quickly).  In that case, it will be submitted at startup with a <code>reason: dirty_startup</code>, if the previous session was not cleanly closed. This only happens from the second start onward.</p>
<p>See also the <a href="user/pings/ping-schedules-and-timings.html">ping schedules and timing overview</a>.</p>
<h2><a class="header" href="#contents" id="contents">Contents</a></h2>
<p>The baseline ping includes the following fields:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>duration</code></td><td>Timespan</td><td>The duration, in seconds, of the last foreground session. Only available if <code>reason: background</code>. <sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
<tr><td><code>locale</code></td><td>String</td><td>The locale of the application. <sup class="footnote-reference"><a href="#2">2</a></sup></td></tr>
</tbody></table>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>See also the <a href="user/pings/ping-schedules-and-timings.html">ping schedules and timing overview</a> for how the <code>duration</code> metric relates to other sources of timing in the <code>baseline</code> ping.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>The locale metric in the baseline ping is deprecated. Use <a href="user/pings/index.html#The-client-info-section"><code>client_info.locale</code></a> instead. </p>
</div>
<p>The <code>baseline</code> ping also includes the common <a href="user/pings/index.html#ping-sections">ping sections</a> found in all pings.</p>
<h3><a class="header" href="#querying-ping-contents" id="querying-ping-contents">Querying ping contents</a></h3>
<p>A quick note about querying ping contents (i.e. for <a href="https://sql.telemetry.mozilla.org">sql.telemetry.mozilla.org</a>):  Each metric in the baseline ping is organized by its metric type, and uses a namespace of <code>glean.baseline</code>. For instance, in order to select <code>duration</code> you would use <code>metrics.timespan['glean.baseline.duration']</code>. If you were trying to select a String based metric such as <code>os</code>, then you would use <code>metrics.string['glean.baseline.os']</code></p>
<h2><a class="header" href="#example-baseline-ping" id="example-baseline-ping">Example baseline ping</a></h2>
<pre><code class="language-json">{
  &quot;ping_info&quot;: {
    &quot;experiments&quot;: {
      &quot;third_party_library&quot;: {
        &quot;branch&quot;: &quot;enabled&quot;
      }
    },
    &quot;seq&quot;: 0,
    &quot;start_time&quot;: &quot;2019-03-29T09:50-04:00&quot;,
    &quot;end_time&quot;: &quot;2019-03-29T09:53-04:00&quot;,
    &quot;reason&quot;: &quot;foreground&quot;
  },
  &quot;client_info&quot;: {
    &quot;telemetry_sdk_build&quot;: &quot;0.49.0&quot;,
    &quot;first_run_date&quot;: &quot;2019-03-29-04:00&quot;,
    &quot;os&quot;: &quot;Android&quot;,
    &quot;android_sdk_version&quot;: &quot;27&quot;,
    &quot;os_version&quot;: &quot;8.1.0&quot;,
    &quot;device_manufacturer&quot;: &quot;Google&quot;,
    &quot;device_model&quot;: &quot;Android SDK built for x86&quot;,
    &quot;architecture&quot;: &quot;x86&quot;,
    &quot;app_build&quot;: &quot;1&quot;,
    &quot;app_display_version&quot;: &quot;1.0&quot;,
    &quot;client_id&quot;: &quot;35dab852-74db-43f4-8aa0-88884211e545&quot;
  },
  &quot;metrics&quot;: {
    &quot;string&quot;: {
      &quot;glean.baseline.locale&quot;: &quot;en-US&quot;
    },
    &quot;timespan&quot;: {
      &quot;glean.baseline.duration&quot;: {
        &quot;value&quot;: 52,
        &quot;time_unit&quot;: &quot;second&quot;
      }
    }
  }
}
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/pings/baseline.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#the-deletion-request-ping" id="the-deletion-request-ping">The <code>deletion-request</code> ping</a></h1>
<h2><a class="header" href="#description-1" id="description-1">Description</a></h2>
<p>This ping is submitted when a user opts out of sending technical and interaction data.</p>
<p>This ping contains the client id.</p>
<p>This ping is intended to communicate to the Data Pipeline that the user wishes to have their reported Telemetry data deleted.
As such it attempts to send itself at the moment the user opts out of data collection, and continues to try and send itself.</p>
<blockquote>
<p><strong>Note:</strong> It is possible to send secondary ids in the deletion request ping.  For instance, if the application is migrating
from legacy telemetry to Glean, the legacy client ids can be added to the deletion request ping by creating a <code>metrics.yaml</code>
entry for the id to be added with a <code>send_in_pings</code> value of <code>deletion_request</code>.</p>
<p>An example <code>metrics.yaml</code> entry might look like this:</p>
<pre><code>legacy_client_id:
   type: uuid
   description:
     A UUID uniquely identifying the legacy client.
   send_in_pings:
     - deletion_request
   ...
</code></pre>
</blockquote>
<h2><a class="header" href="#scheduling-1" id="scheduling-1">Scheduling</a></h2>
<p>The <code>deletion-request</code> ping is automatically submitted when upload is disabled in Glean.
If upload fails, it is retried after Glean is initialized.</p>
<h2><a class="header" href="#contents-1" id="contents-1">Contents</a></h2>
<p>The <code>deletion-request</code> does not contain additional metrics aside from secondary ids that have been added.</p>
<h2><a class="header" href="#example-deletion-request-ping" id="example-deletion-request-ping">Example <code>deletion-request</code> ping</a></h2>
<pre><code class="language-json">{
  &quot;ping_info&quot;: {
    &quot;seq&quot;: 0,
    &quot;start_time&quot;: &quot;2019-12-06T09:50-04:00&quot;,
    &quot;end_time&quot;: &quot;2019-12-06T09:53-04:00&quot;
  },
  &quot;client_info&quot;: {
    &quot;telemetry_sdk_build&quot;: &quot;22.0.0&quot;,
    &quot;first_run_date&quot;: &quot;2019-03-29-04:00&quot;,
    &quot;os&quot;: &quot;Android&quot;,
    &quot;android_sdk_version&quot;: &quot;28&quot;,
    &quot;os_version&quot;: &quot;9&quot;,
    &quot;device_manufacturer&quot;: &quot;Google&quot;,
    &quot;device_model&quot;: &quot;Android SDK built for x86&quot;,
    &quot;architecture&quot;: &quot;x86&quot;,
    &quot;app_build&quot;: &quot;1&quot;,
    &quot;app_display_version&quot;: &quot;1.0&quot;,
    &quot;client_id&quot;: &quot;35dab852-74db-43f4-8aa0-88884211e545&quot;
  },
  &quot;metrics&quot;: {
    &quot;uuid&quot;: {
      &quot;legacy_client_id&quot;: &quot;5faffa6d-6147-4d22-a93e-c1dbd6e06171&quot;
    }
  }
}
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/pings/deletion_request.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#the-metrics-ping" id="the-metrics-ping">The <code>metrics</code> ping</a></h1>
<h2><a class="header" href="#description-2" id="description-2">Description</a></h2>
<p>The <code>metrics</code> ping is intended for all of the metrics that are explicitly set by the application or are included in the application's <code>metrics.yaml</code> file (except events). 
The reported data is tied to the ping's <em>measurement window</em>, which is the time between the collection of two <code>metrics</code> pings. 
Ideally, this window is expected to be about 24 hours, given that the collection is scheduled daily at 04:00. 
However, the metrics ping is only submitted while the application is actually running, so in practice, it may not meet the 04:00 target very frequently.
Data in the <a href="user/pings/index.html#the-ping_info-section"><code>ping_info</code></a> section of the ping can be used to infer the length of this window and the reason that triggered the ping to be submitted.
If the application crashes, unsent recorded metrics are sent along with the next <code>metrics</code> ping.</p>
<p>Additionally, it is undesirable to mix metric recording from different versions of the application. Therefore, if a version upgrade is detected, the <code>metrics</code> ping is collected immediately before further metrics from the new version are recorded.</p>
<blockquote>
<p><strong>Note:</strong> As the <code>metrics</code> ping was specifically designed for mobile operating systems, it is not sent when using the Glean Python bindings.</p>
</blockquote>
<h2><a class="header" href="#scheduling-2" id="scheduling-2">Scheduling</a></h2>
<p>The desired behavior is to collect the ping at the first available opportunity after 04:00 local time on a new calendar day, but given constraints of the platform, it can only be submitted while the application is running. 
This breaks down into three scenarios:</p>
<ol>
<li>the application was just installed;</li>
<li>the application was just upgraded (the version of the app is different from the last time the app was run);</li>
<li>the application was just started (after a crash or a long inactivity period);</li>
<li>the application was running at 04:00.</li>
</ol>
<p>In the first case, since the application was just installed, if the due time for the current calendar day has passed, a <code>metrics</code> ping is immediately generated and scheduled for sending (reason code <code>overdue</code>). Otherwise, if the due time for the current calendar day has not passed, a ping collection is scheduled for that time (reason code <code>today</code>). </p>
<p>In the second case, if a version change is detected at startup, the metrics ping is immediately submitted so that metrics from one version are not aggregated with metrics from another version (reason code <code>upgrade</code>).</p>
<p>In the third case, if the <code>metrics</code> ping was not already collected on the current calendar day, and it is before 04:00, a collection is scheduled for 04:00 on the current calendar day (reason code <code>today</code>).
If it is after 04:00, a new collection is scheduled immediately (reason code <code>overdue</code>).
Lastly, if a ping was already collected on the current calendar day, the next one is scheduled for collecting at 04:00 on the next calendar day (reason code <code>tomorrow</code>).</p>
<p>In the fourth and last case, the application is running during a scheduled ping collection time.
The next ping is scheduled for 04:00 the next calendar day (reason code <code>reschedule</code>).</p>
<p>More <a href="user/pings/metrics.html#scheduling-examples">scheduling examples</a> are included below.</p>
<p>See also the <a href="user/pings/ping-schedules-and-timings.html">ping schedules and timing overview</a>.</p>
<h2><a class="header" href="#contents-2" id="contents-2">Contents</a></h2>
<p>The <code>metrics</code> ping contains all of the metrics defined in <code>metrics.yaml</code> (except events) that don't specify a ping or where <code>default</code> is specified in their <a href="https://mozilla.github.io/glean_parser/metrics-yaml.html#send-in-pings"><code>send in pings</code></a> property.</p>
<p>Additionally, error metrics in the <code>glean.error</code> category are included in the <code>metrics</code> ping.</p>
<p>The <code>metrics</code> ping shall also include the common <a href="user/pings/index.html#the-ping_info-section"><code>ping_info</code></a> and <a href="user/pings/index.html#the-client_info-section">'client_info'</a> sections.</p>
<h3><a class="header" href="#querying-ping-contents-1" id="querying-ping-contents-1">Querying ping contents</a></h3>
<p>Information about query ping contents is available in <a href="https://docs.telemetry.mozilla.org/concepts/glean/accessing_glean_data.html">Accessing Glean data</a> in the Firefox data docs.</p>
<h2><a class="header" href="#scheduling-examples" id="scheduling-examples">Scheduling Examples</a></h2>
<h3><a class="header" href="#crossing-due-time-with-the-application-closed" id="crossing-due-time-with-the-application-closed">Crossing due time with the application closed</a></h3>
<ol>
<li>
<p>The application is opened on Feb 7 on 15:00, closed on 15:05.</p>
<ul>
<li>Glean records one metric A (say startup time in ms) during this measurement window MW1.</li>
</ul>
</li>
<li>
<p>The application is opened again on Feb 8 on 17:00.</p>
</li>
</ol>
<ul>
<li>
<p>Glean notes that we passed local 04:00 since MW1.</p>
</li>
<li>
<p>Glean closes MW1, with:</p>
<ul>
<li><code>start_time=Feb7/15:00</code>;</li>
<li><code>end_time=Feb8/17:00</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW2, which has a start_time of Feb8/17:00.</p>
</li>
</ul>
<h3><a class="header" href="#crossing-due-time-and-changing-timezones" id="crossing-due-time-and-changing-timezones">Crossing due time and changing timezones</a></h3>
<ol>
<li>
<p>The application is opened on Feb 7 on 15:00 in timezone UTC, closed on 15:05.</p>
<ul>
<li>Glean records one metric A (say startup time in ms) during this measurement window MW1.</li>
</ul>
</li>
<li>
<p>The application is opened again on Feb 8 on 17:00 in timezone UTC+1.</p>
<ul>
<li>
<p>Glean notes that we passed local 04:00 UTC+1 since MW1.</p>
</li>
<li>
<p>Glean closes MW1, with:</p>
<ul>
<li><code>start_time=Feb7/15:00/UTC</code>;</li>
<li><code>end_time=Feb8/17:00/UTC+1</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW2.</p>
</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#the-application-doesnt-run-in-a-week" id="the-application-doesnt-run-in-a-week">The application doesnt run in a week</a></h3>
<ol>
<li>
<p>The application is opened on Feb 7 on 15:00 in timezone UTC, closed on 15:05.</p>
<ul>
<li>Glean records one metric A (say startup time in ms) during this measurement window MW1.</li>
</ul>
</li>
<li>
<p>The application is opened again on Feb 16 on 17:00 in timezone UTC.</p>
<ul>
<li>
<p>Glean notes that we passed local 04:00 UTC since MW1.</p>
</li>
<li>
<p>Glean closes MW1, with:</p>
<ul>
<li><code>start_time=Feb7/15:00/UTC</code>;</li>
<li><code>end_time=Feb16/17:00/UTC</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW2.</p>
</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#the-application-doesnt-run-for-a-week-and-when-its-finally-re-opened-the-timezone-has-changed" id="the-application-doesnt-run-for-a-week-and-when-its-finally-re-opened-the-timezone-has-changed">The application doesnt run for a week, and when its finally re-opened the timezone has changed</a></h3>
<ol>
<li>
<p>The application is opened on Feb 7 on 15:00 in timezone UTC, closed on 15:05.</p>
<ul>
<li>Glean records one metric A (say startup time in ms) during this measurement window MW1.</li>
</ul>
</li>
<li>
<p>The application is opened again on Feb 16 on 17:00 in timezone UTC+1.</p>
<ul>
<li>
<p>Glean notes that we passed local 04:00 UTC+1 since MW1.</p>
</li>
<li>
<p>Glean closes MW1, with:</p>
<ul>
<li><code>start_time=Feb7/15:00/UTC</code></li>
<li><code>end_time=Feb16/17:00/UTC+1</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW2.</p>
</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#the-user-changes-timezone-in-an-extreme-enough-fashion-that-they-cross-0400-twice-on-the-same-date" id="the-user-changes-timezone-in-an-extreme-enough-fashion-that-they-cross-0400-twice-on-the-same-date">The user changes timezone in an extreme enough fashion that they cross 04:00 twice on the same date</a></h3>
<ol>
<li>
<p>The application is opened on Feb 7 at 15:00 in timezone UTC+11, closed at 15:05.</p>
<ul>
<li>Glean records one metric A (say startup time in ms) during this measurement window MW1.</li>
</ul>
</li>
<li>
<p>The application is opened again on Feb 8 at 04:30 in timezone UTC+11.</p>
<ul>
<li>
<p>Glean notes that we passed local 04:00 UTC+11.</p>
</li>
<li>
<p>Glean closes MW1, with:</p>
<ul>
<li><code>start_time=Feb7/15:00/UTC+11</code>;</li>
<li><code>end_time=Feb8/04:30/UTC+11</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW2.</p>
</li>
</ul>
</li>
<li>
<p>The user changes to timezone UTC-10 and opens the application at Feb 7 at 22:00 in timezone UTC-10</p>
<ul>
<li>Glean records metric A again, into MW2 (not MW1, which was already sent).</li>
</ul>
</li>
<li>
<p>The user opens the application at Feb 8 05:00 in timezone UTC-10</p>
<ul>
<li>Glean notes that we have not yet passed local 04:00 on Feb 9</li>
<li>Measurement window MW2 remains the current measurement window</li>
</ul>
</li>
<li>
<p>The user opens the application at Feb 9 07:00 in timezone UTC-10</p>
<ul>
<li>
<p>Glean notes that we have passed local 04:00 on Feb 9</p>
</li>
<li>
<p>Glean closes MW2 with:</p>
<ul>
<li><code>start_time=Feb8/04:30/UTC+11</code>;</li>
<li><code>end_time=Feb9/19:00/UTC-10</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW3.</p>
</li>
</ul>
</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/pings/metrics.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#the-events-ping" id="the-events-ping">The <code>events</code> ping</a></h1>
<h2><a class="header" href="#description-3" id="description-3">Description</a></h2>
<p>The events ping's purpose is to transport all of the event metric information.
If the application crashes, an <code>events</code> ping is generated next time the application starts with events that were not sent before the crash.</p>
<h2><a class="header" href="#scheduling-3" id="scheduling-3">Scheduling</a></h2>
<p>The <code>events</code> ping is collected under the following circumstances:</p>
<ol>
<li>
<p>Normally, it is collected when the application goes into the <a href="user/pings/index.html#defining-background-state">background</a>, if there are any recorded events to send.</p>
</li>
<li>
<p>When the queue of events exceeds <code>Glean.configuration.maxEvents</code> (default 500).</p>
</li>
<li>
<p>If there are any unsent events found on disk when starting the application. It would be impossible to coordinate the timestamps across a reboot, so it's best to just collect all events from the previous run into their own ping, and start over.</p>
</li>
</ol>
<p>All of these cases are handled automatically, with no intervention or configuration required by the application.</p>
<blockquote>
<p><strong>Note:</strong> Since the Python bindings don't have a concept of &quot;going to background&quot;, case (1) above does not apply.</p>
</blockquote>
<h2><a class="header" href="#contents-3" id="contents-3">Contents</a></h2>
<p>At the top-level, this ping contains the following keys:</p>
<ul>
<li>
<p><code>ping_info</code>: The information <a href="user/pings/index.html#the-ping_info-section">common to all pings</a>.</p>
</li>
<li>
<p><code>events</code>: An array of all of the events that have occurred since the last time the <code>events</code> ping was sent.</p>
</li>
</ul>
<p>Each entry in the <code>events</code> array is an object with the following properties:</p>
<ul>
<li>
<p><code>&quot;timestamp&quot;</code>: The milliseconds relative to the first event in the ping.</p>
</li>
<li>
<p><code>&quot;category&quot;</code>: The category of the event, as defined by its location in the <code>metrics.yaml</code> file.</p>
</li>
<li>
<p><code>&quot;name&quot;</code>: The name of the event, as defined in the <code>metrics.yaml</code> file.</p>
</li>
<li>
<p><code>&quot;extra&quot;</code> (optional): A mapping of strings to strings providing additional data about the event. The keys are restricted to 40 characters and values in this map will never exceed 100 characters.</p>
</li>
</ul>
<h3><a class="header" href="#example-event-json" id="example-event-json">Example event JSON</a></h3>
<pre><code class="language-json">{
  &quot;ping_info&quot;: {
    &quot;experiments&quot;: {
      &quot;third_party_library&quot;: {
        &quot;branch&quot;: &quot;enabled&quot;
      }
    },
    &quot;seq&quot;: 0,
    &quot;start_time&quot;: &quot;2019-03-29T09:50-04:00&quot;,
    &quot;end_time&quot;: &quot;2019-03-29T10:02-04:00&quot;
  },
  &quot;client_info&quot;: {
    &quot;telemetry_sdk_build&quot;: &quot;0.49.0&quot;,
    &quot;first_run_date&quot;: &quot;2019-03-29-04:00&quot;,
    &quot;os&quot;: &quot;Android&quot;,
    &quot;android_sdk_version&quot;: &quot;27&quot;,
    &quot;os_version&quot;: &quot;8.1.0&quot;,
    &quot;device_manufacturer&quot;: &quot;Google&quot;,
    &quot;device_model&quot;: &quot;Android SDK built for x86&quot;,
    &quot;architecture&quot;: &quot;x86&quot;,
    &quot;app_build&quot;: &quot;1&quot;,
    &quot;app_display_version&quot;: &quot;1.0&quot;,
    &quot;client_id&quot;: &quot;35dab852-74db-43f4-8aa0-88884211e545&quot;
  },
  &quot;events&quot;: [
    {
      &quot;timestamp&quot;: 123456789,
      &quot;category&quot;: &quot;examples&quot;,
      &quot;name&quot;: &quot;event_example&quot;,
      &quot;extra&quot;: {
        &quot;metadata1&quot;: &quot;extra&quot;,
        &quot;metadata2&quot;: &quot;more_extra&quot;
      }
    },
    {
      &quot;timestamp&quot;: 123456791,
      &quot;category&quot;: &quot;examples&quot;,
      &quot;name&quot;: &quot;event_example&quot;
    }
  ]
}
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/pings/events.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#custom-pings" id="custom-pings">Custom pings</a></h1>
<p>Applications can define metrics that are sent in custom pings. Unlike the built-in pings, custom pings are sent explicitly by the application.</p>
<p>This is useful when the scheduling of the built-in pings (<a href="user/pings/metrics.html">metrics</a>, <a href="user/pings/baseline.html">baseline</a> and <a href="user/pings/events.html">events</a>) are not appropriate for your data.  Since the timing of the submission of custom pings is handled by the application, the measurement window is under the application's control.</p>
<p>This is especially useful when metrics need to be tightly related to one another, for example when you need to measure the distribution of frame paint times when a particular rendering backend is in use.  If these metrics were in different pings, with different measurement windows, it is much harder to do that kind of reasoning with much certainty.</p>
<h2><a class="header" href="#defining-a-custom-ping" id="defining-a-custom-ping">Defining a custom ping</a></h2>
<p>Custom pings must be defined in a <a href="https://mozilla.github.io/glean_parser/pings-yaml.html"><code>pings.yaml</code> file</a>, which is in the same directory alongside your app's <code>metrics.yaml</code> file.</p>
<p>Ping names are limited to lowercase letters from the <a href="https://en.wikipedia.org/wiki/ISO_basic_Latin_alphabet">ISO basic Latin alphabet</a>
and hyphens and a maximum of 30 characters.</p>
<p>Each ping has the following parameters:</p>
<ul>
<li><code>description</code> (required): A textual description describing the purpose of the ping. It may contain <a href="https://www.markdownguide.org/basic-syntax/">markdown syntax</a>.</li>
<li><code>include_client_id</code> (required): A boolean indicating whether to include the
<code>client_id</code> in the <a href="user/pings/index.html#The-client_info-section"><code>client_info</code> section</a>).</li>
<li><code>send_if_empty</code> (optional, default: false): A boolean indicating if the ping is sent if it contains no metric data.</li>
<li><code>reasons</code> (optional, default: <code>{}</code>): The reasons that this ping may be sent. The keys are the reason codes, and the values are a textual description of each reason. The ping payload will (optionally) contain one of these reasons in the <code>ping_info.reason</code> field.</li>
</ul>
<p>In addition to these parameters, pings also support the parameters related to data review and expiration defined in <a href="user/pings/../adding-new-metrics.html#common-metric-parameters">common metric parameters</a>: <code>description</code>, <code>notification_emails</code>, <code>bugs</code>, and <code>data_reviews</code>.</p>
<p>For example, to define a custom ping called <code>search</code> specifically for search information:</p>
<pre><code class="language-YAML"># Required to indicate this is a `pings.yaml` file
$schema: moz://mozilla.org/schemas/glean/pings/1-0-0

search:
  description: &gt;
    A ping to record search data.
  include_client_id: false
  notification_emails:
    - CHANGE-ME@example.com
  bugs:
    - http://bugzilla.mozilla.org/123456789/
  data_reviews:
    - http://example.com/path/to/data-review
</code></pre>
<blockquote>
<p>Note: the names <code>baseline</code>, <code>metrics</code>, <code>events</code>, <code>deletion-request</code> and <code>all-pings</code> are reserved and may not be used as the name of a custom ping.</p>
</blockquote>
<h2><a class="header" href="#loading-custom-ping-metadata-into-your-application-or-library" id="loading-custom-ping-metadata-into-your-application-or-library">Loading custom ping metadata into your application or library</a></h2>
<p>The Glean SDK build generates code from <code>pings.yaml</code> in a <code>Pings</code> object, which must be instantiated so Glean can send pings by name.</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<p>In Kotlin, this object must be registered with Glean from your startup code (such as in your application's <code>onCreate</code> method or a function called from that method).</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Pings

...

override fun onCreate() {
    ...
    Glean.registerPings(Pings)
    ...
}
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<p>In Swift, this object must be registered with Glean from your startup code
(such as in your application's <code>UIApplicationDelegate</code> <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application"><code>application(_:didFinishLaunchingWithOptions:)</code></a> method or a function called from that method).</p>
<pre><code class="language-swift">import Glean

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
func application(_: UIApplication, didFinishLaunchingWithOptions _: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // ...
    Glean.shared.registerPings(GleanMetrics.Pings)
    // ...
}
}
</code></pre>
</div>
<div data-lang="Python" class="tab">
<p>For Python, the <code>pings.yaml</code> file must be available and loaded at runtime.</p>
<p>If your project is a script (i.e. just Python files in a directory), you can load the <code>pings.yaml</code> using:</p>
<pre><code>from glean import load_pings

pings = load_pings(&quot;pings.yaml&quot;)
</code></pre>
<p>If your project is a distributable Python package, you need to include the <code>metrics.yaml</code> file using <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#including-data-files">one of the myriad ways to include data in a Python package</a> and then use <a href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html#resource-extraction"><code>pkg_resources.resource_filename()</code></a> to get the filename at runtime.</p>
<pre><code class="language-Python">from glean import load_pings
from pkg_resources import resource_filename

pings = load_pings(resource_filename(__name__, &quot;pings.yaml&quot;))
</code></pre>
</div>
</div>
</div>
<h2><a class="header" href="#sending-metrics-in-a-custom-ping" id="sending-metrics-in-a-custom-ping">Sending metrics in a custom ping</a></h2>
<p>To send a metric on a custom ping, you add the custom ping's name to the <code>send_in_pings</code> parameter in the <code>metrics.yaml</code> file.</p>
<p>For example, to define a new metric to record the default search engine, which is sent in a custom ping called <code>search</code>, put <code>search</code> in the <code>send_in_pings</code> parameter.  Note that it is an error to specify a ping in <code>send_in_pings</code> that does not also have an entry in <code>pings.yaml</code>.</p>
<pre><code class="language-YAML">search.default:
  name:
    type: string
    description: &gt;
      The name of the default search engine.
    send_in_pings:
      - search
</code></pre>
<p>If this metric should also be sent in the default ping for the given metric type, you can add the special value <code>default</code> to <code>send_in_pings</code>:</p>
<pre><code class="language-YAML">    send_in_pings:
      - search
      - default
</code></pre>
<h2><a class="header" href="#submitting-a-custom-ping" id="submitting-a-custom-ping">Submitting a custom ping</a></h2>
<p>To collect and queue a custom ping for eventual uploading, call the <code>submit</code> method on the <code>PingType</code> object that the Glean SDK generated for your ping.</p>
<p>By default, if the ping doesn't currently have any events or metrics set, <code>submit</code> will do nothing.  However, if the <code>send_if_empty</code> flag is set to true in the ping definition, it will always be submitted.</p>
<p>For example, to submit the custom ping defined above:</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-kotlin">import org.mozilla.yourApplication.GleanMetrics.Pings
Pings.search.submit(
    GleanMetrics.Pings.searchReasonCodes.performed
)
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-swift">import Glean

GleanMetrics.Pings.shared.search.submit(
    reason: .performed
)
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-Python">from glean import load_pings

pings = load_pings(&quot;pings.yaml&quot;)

pings.search.submit(pings.search_reason_codes.PERFORMED)
</code></pre>
</div>
</div>
</div>
<p>If none of the metrics for the ping contain data the ping is not sent (unless <code>send_if_empty</code> is set to true in the definition file)</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/pings/custom.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#unit-testing-glean-custom-pings-for-android" id="unit-testing-glean-custom-pings-for-android">Unit testing Glean custom pings for Android</a></h1>
<p>Applications defining <a href="user/pings/custom.html">custom pings</a> can use use the strategy defined in this document to test these pings in unit tests.</p>
<h2><a class="header" href="#general-testing-strategy" id="general-testing-strategy">General testing strategy</a></h2>
<p>The schedule of custom pings depends on the specific application implementation, since it is up to the SDK user to define the ping semantics. This makes writing unit tests for custom pings a bit more involved.</p>
<p>One possible strategy could be to wrap the Glean SDK API call to send the ping in a function that can be mocked in the unit test. This would allow for checking the status and the values of the metrics contained in the ping at the time in which the application would have sent it.</p>
<h2><a class="header" href="#example-testing-of-a-custom-ping" id="example-testing-of-a-custom-ping">Example testing of a custom ping</a></h2>
<p>Let us start by defining a custom ping with a sample metric in it. Here is the <code>pings.yaml</code> file:</p>
<pre><code class="language-yaml">$schema: moz://mozilla.org/schemas/glean/pings/1-0-0

my-custom-ping:
  description: &gt;
    This ping is intended to showcase the recommended testing strategy for
    custom pings.
  include_client_id: false
  bugs:
    - https://bugzilla.mozilla.org/1556985/
  data_reviews:
    - https://bugzilla.mozilla.org/show_bug.cgi?id=1556985
  notification_emails:
    - custom-ping-owner@example.com

</code></pre>
<p>And here is the <code>metrics.yaml</code></p>
<pre><code class="language-yaml">$schema: moz://mozilla.org/schemas/glean/metrics/1-0-0

custom_ping_data:
  sample_string:
    type: string
    lifetime: ping
    description: &gt;
      A sample string metric for demonstrating unit tests for custom pings.
    send_in_pings:
      - my-custom-ping
    bugs:
      - https://bugzilla.mozilla.org/1556985/
    data_reviews:
      - https://bugzilla.mozilla.org/show_bug.cgi?id=1556985
    notification_emails:
      - custom-ping-owner@example.com
    expires: &quot;2019-10-01&quot;
</code></pre>
<p>A potential usage of the Glean SDK generated API could be the following:</p>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<pre><code class="language-kotlin">import my.component.GleanMetrics.Pings
import my.component.GleanMetrics.CustomPingData

class MyCustomPingScheduler {
  /**
   * HERE ONLY TO KEEP THE EXAMPLE SIMPLE.
   *
   * A function that consumes the Glean SDK generated metrics API to
   * record some data. It doesn't really need to be in a function, nor
   * in this class. The Glean SDK API can be called when the data is
   * generated.
   */
  fun addSomeData() {
    // Record some sample data.
    CustomPingData.sampleString.set(&quot;test-data&quot;)
  }

  /**
   * Called to implement the ping scheduling logic for 'my_custom_ping'.
   */
  fun schedulePing() {
    // ... some scheduling logic that will end up calling the function below.
    submitPing()
  }

  /**
   * Internal function to only be overridden in tests. This
   * calls the Glean SDK API to send custom pings.
   */
  @VisibleForTesting(otherwise = VisibleForTesting.NONE)
  internal fun submitPing() {
    Pings.MyCustomPing.submit()
  }
}
</code></pre>
<p>The following unit test intercepts the <code>MyCustomPingScheduler.submitPing()</code> call in order to perform the validation on the data.
This specific example uses Mockito, but any other framework would work.</p>
<pre><code class="language-kotlin">// Metrics and pings definitions.
import my.component.GleanMetrics.Pings
import my.component.GleanMetrics.CustomPingData

// Mockito imports for using spies.
import org.mockito.Mockito.spy
import org.mockito.Mockito.`when`

@RunWith(AndroidJUnit4::class)
class MyCustomPingSchedulerTest {
    // Apply the GleanTestRule to set up a disposable Glean instance.
    // Please note that this clears the Glean data across tests.
    @get:Rule
    val gleanRule = GleanTestRule(ApplicationProvider.getApplicationContext())

    @Test
    fun `verify custom ping metrics`() {
      val scheduler = spy(MyCustomPingScheduler())
      doAnswer {
        // Here we validate the content that goes into the ping.
        assertTrue(CustomPingData.sampleString.testHasValue())
        assertEquals(&quot;test-data&quot;, CustomPingData.sampleString.testGetValue())

        // We want to intercept this call, but we also want to make sure the
        // real Glean API is called in order to clear the ping store and to provide
        // consistent behaviour with respect to the application.
        it.callRealMethod()
      }.`when`(scheduler).submitPing()

      scheduler.addSomeData()
      scheduler.schedulePing()
    }
}
</code></pre>
</div>
<div data-lang="Swift" class="tab">
<pre><code class="language-swift">import Foundation
import Glean

// Use typealiases to simplify usage.
// This can be placed anywhere in your code to be available in all files.
typealias CustomPingData = GleanMetrics.CustomPingData
typealias Pings = GleanMetrics.Pings

class MyCustomPingScheduler {
    /**
     * HERE ONLY TO KEEP THE EXAMPLE SIMPLE.
     *
     * A function that consumes the Glean SDK generated metrics API to
     * record some data. It doesn't really need to be in a function, nor
     * in this class. The Glean SDK API can be called when the data is
     * generated.
     */
    func addSomeData() {
       // Record some sample data.
       CustomPingData.sampleString.set(&quot;test-data&quot;)
    }

    /**
     * Called to implement the ping scheduling logic for 'my_custom_ping'.
     */
    func schedulePing() {
        // ... some scheduling logic that will end up calling the function below.
        submitPing()
    }

    /**
     * Internal function to only be overridden in tests. This
     * calls the Glean SDK API to send custom pings.
     */
    internal func submitPing() {
        Pings.shared.myCustomPing.submit()
    }
}
</code></pre>
<p>The following unit test intercepts the <code>MyCustomPingScheduler.submitPing()</code> call in order to perform the validation on the data.
This example uses a manual mock implementation, but you could use a framework for that.</p>
<pre><code class="language-swift">@testable import YourApplication
import Glean
import XCTest

class MyCustomPingSchedulerMock: MyCustomPingScheduler {
    var submitWasCalled = false

    deinit {
        XCTAssertTrue(submitWasCalled, &quot;submitPing should have been called once&quot;)
    }

    override func submitPing() {
        submitWasCalled = true

        XCTAssertTrue(CustomPingData.os.testHasValue())
        XCTAssertEqual(&quot;test-data&quot;, try! CustomPingData.os.testGetValue())

        super.submitPing()
    }
}

class MyCustomPingSchedulerTests: XCTestCase {
    override func setUp() {
        Glean.shared.resetGlean(clearStores: true)
    }

    func testCustomPingMetrics() {
        let scheduler = MyCustomPingSchedulerMock()
        scheduler.addSomeData()
        scheduler.schedulePing()
    }
}
</code></pre>
</div>
<div data-lang="Python" class="tab">
<pre><code class="language-python">import glean

metrics = glean.load_metrics(&quot;metrics.yaml&quot;)
pings = glean.load_pings(&quot;pings.yaml&quot;)


class MyCustomPingScheduler:
    def add_some_data(self):
        &quot;&quot;&quot;
        HERE ONLY TO KEEP THE EXAMPLE SIMPLE.

        A function that consumes the Glean SDK generated metrics API to
        record some data. It doesn't really need to be in a function, nor
        in this class. The Glean SDK API can be called when the data is
        generated.
        &quot;&quot;&quot;
        # Record some sample data.
        metrics.custom_ping_data.sample_string.set(&quot;test-data&quot;)

    def schedule_ping(self):
        &quot;&quot;&quot;
        Called to implement the ping scheduling logic for 'my_custom_ping'.
        &quot;&quot;&quot;
        # ... some scheduling logic that will end up calling the function below.
        self._submit_ping()

    def _submit_ping(self):
        &quot;&quot;&quot;
        Internal function to only be overridden in tests.
        &quot;&quot;&quot;
        pings.my_custom_ping.submit()
</code></pre>
<p>The following unit test intercepts the <code>MyCustomPingScheduler._submit_ping()</code> call in order to perform the validation on the data.</p>
<pre><code class="language-python">from unittest.mock import MagicMock

from glean import testing

import custom_ping_scheduler


# This will be run before every test in the entire test suite
def pytest_runtest_setup(item):
    testing.reset_glean(application_id=&quot;my-app&quot;, application_version=&quot;0.0.1&quot;)


def test_verify_custom_ping_metrics():
    scheduler = custom_ping_scheduler.MyCustomPingScheduler()

    original_submit_ping = scheduler._submit_ping

    def _submit_ping(self):
        # Here we validate the content that goes into the ping.
        assert (
            custom_ping_scheduler.metrics.custom_ping_data.sample_string.test_has_value()
        )
        assert (
            &quot;test-data&quot;
            == custom_ping_scheduler.metrics.custom_ping_data.sample_string.test_get_value()
        )

        # We want to intercept this call, but we also want to make sure the
        # real Glean API is called in order to clear the ping strong and to
        # provide consistent behavior with respect to the application.
        original_submit_ping(self)

    scheduler._submit_ping = MagicMock(_submit_ping)

    scheduler.add_some_data()
    scheduler.schedule_ping()
</code></pre>
</div>
</div>
</div>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/pings/testing-custom-pings.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#android-build-script-configuration-options" id="android-build-script-configuration-options">Android build script configuration options</a></h1>
<p>This chapter describes build configuration options that control the behavior of Glean's Gradle plugin.
These options are not usually required for normal use.</p>
<p>Options can be turned on by setting a variable on the Gradle <a href="https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html"><code>ext</code></a> object <em>before</em> applying the Glean Gradle plugin.</p>
<h2><a class="header" href="#allowmetricsfromaar" id="allowmetricsfromaar"><code>allowMetricsFromAAR</code></a></h2>
<p>Normally, Glean looks for <code>metrics.yaml</code> and <code>pings.yaml</code> files in the root directory of the Glean-using project.
However, in some cases, these files may need to ship inside the dependencies of the project.
For example, this is used in the <code>engine-gecko</code> component to grab the <code>metrics.yaml</code> from the <code>geckoview</code> AAR.</p>
<pre><code class="language-groovy">ext.allowMetricsFromAAR = true
</code></pre>
<p>When this flag is set, every direct dependency of your library will be searched for a <code>metrics.yaml</code> file, and those metrics will be treated as the metrics as if they were defined by your library.
That is, API wrappers accessible from your library will be generated for those metrics.</p>
<p>The <code>metrics.yaml</code> can be added to the dependency itself by calling this on each relevant build variant:</p>
<pre><code class="language-groovy">variant.packageLibraryProvider.get().from(&quot;${topsrcdir}/path/metrics.yaml&quot;)
</code></pre>
<h2><a class="header" href="#gleangeneratemarkdowndocs" id="gleangeneratemarkdowndocs"><code>gleanGenerateMarkdownDocs</code></a></h2>
<p>The Glean SDK can automatically generate Markdown documentation for metrics and pings defined in the registry files, in addition to the metrics API code.</p>
<pre><code class="language-groovy">ext.gleanGenerateMarkdownDocs = true
</code></pre>
<p>Flipping the feature to <code>true</code> will generate a <code>metrics.md</code> file in <code>$projectDir/docs</code> at build-time.</p>
<h2><a class="header" href="#gleandocsdirectory" id="gleandocsdirectory"><code>gleanDocsDirectory</code></a></h2>
<p>The <code>gleanDocsDirectory</code> can be used to customize the path of the documentation output directory.
If <code>gleanGenerateMarkdownDocs</code> is disabled, it does nothing.
Please note that only the <code>metrics.md</code> will be overwritten: any other file available in the target directory will be preserved.</p>
<pre><code class="language-groovy">ext.gleanDocsDirectory = &quot;$rootDir/docs/user/telemetry&quot;
</code></pre>
<h2><a class="header" href="#gleanyamlfiles" id="gleanyamlfiles"><code>gleanYamlFiles</code></a></h2>
<p>By default, the Glean Gradle plugin will look for <code>metrics.yaml</code> and <code>pings.yaml</code> files in the same directory that the plugin is included from in your application or library.
To override this, <code>ext.gleanYamlFiles</code> may be set to a list of explicit paths.</p>
<pre><code class="language-groovy">ext.gleanYamlFiles = [&quot;$rootDir/glean-core/metrics.yaml&quot;, &quot;$rootDir/glean-core/pings.yaml&quot;]
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/android-build-configuration-options.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#focused-use-cases" id="focused-use-cases">Focused Use Cases</a></h1>
<p>Here is a list of specific examples of using Glean to instrument different situations.</p>
<h2><a class="header" href="#a-hrefuserinstrument-android-crashes-examplehtmlinstrumenting-android-crashes-with-gleana" id="a-hrefuserinstrument-android-crashes-examplehtmlinstrumenting-android-crashes-with-gleana"><a href="user/instrument-android-crashes-example.html">Instrumenting Android Crashes With Glean</a></a></h2>
<p>This is a simple example illustrating a strategy or method for instrumenting crashes in Android applications using Glean.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/focused-use-cases.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#instrumenting-android-crashes-with-the-glean-sdk" id="instrumenting-android-crashes-with-the-glean-sdk">Instrumenting Android Crashes With The Glean SDK</a></h1>
<p>One of the things that might be useful to collect data on in an Android application is crashes.  This guide will walk through a
basic strategy for instrumenting an Android application with crash telemetry using a custom ping.</p>
<p><strong>Note:</strong>  This is a <em>very</em> simple example of instrumenting crashes using the Glean SDK.  There will be challenges to
using this approach in a production application that should be considered.  For instance, when an app crashes it can be in an
unknown state and may not be able to do things like upload data to a server.  The recommended way of instrumenting crashes with
Android Components is called <a href="https://github.com/mozilla-mobile/android-components/tree/master/components/lib/crash">lib-crash</a>, which takes into consideration things like multiple processes and persistence.</p>
<h2><a class="header" href="#before-you-start" id="before-you-start">Before You Start</a></h2>
<p>There are a few things that need to be installed in order to proceed, mainly <a href="https://developer.android.com/studio/">Android Studio</a>.  If you include the Android SDK,
Android Studio can take a little while to download and get installed.  This walk-through assumes some knowledge of Android
application development.  Knowing where to go to create a new project and how to add dependencies to a Gradle file will be
helpful in following this guide.</p>
<h2><a class="header" href="#setup-build-configuration" id="setup-build-configuration">Setup Build Configuration</a></h2>
<p>Please follow the instruction in the <a href="user/adding-glean-to-your-project.html">&quot;Adding Glean to your project&quot;</a> chapter in order to set up
Glean in an Android project.</p>
<h3><a class="header" href="#add-a-custom-metric" id="add-a-custom-metric">Add A Custom Metric</a></h3>
<p>Since crashes will be instrumented with some custom metrics, the next step will be to add a <code>metrics.yaml</code> file to define the
metrics used to record the crash information and a <code>pings.yaml</code> file to define a custom ping which will give some control over
the scheduling of the uploading.  See <a href="user/adding-new-metrics.html">&quot;Adding new metrics&quot;</a> for more information about adding metrics.</p>
<p>What metric type should be used to represent the crash data?  While this could be implemented several ways, an <a href="user/metrics/event.html">event</a> is an
excellent choice, simply because events capture information in a nice concise way and they have a built-in way of passing
additional information using the <code>extras</code> field.  If it is necessary to pass along the cause of the exception or a few lines of
description, events let us do that easily (with <a href="user/metrics/event.html#limits">some limitations</a>).</p>
<p>Now that a metric type has been chosen to represent the metric, the next step is creating the <code>metrics.yaml</code>.  Inside of the
root application folder of the Android Studio project create a new file named <code>metrics.yaml</code>.  After adding the schema
definition and event metric definition, the <code>metrics.yaml</code> should look like this:</p>
<pre><code class="language-YAML"># Required to indicate this is a `metrics.yaml` file
$schema: moz://mozilla.org/schemas/glean/metrics/1-0-0

crash:
  exception:
    type: event
    description: |
      Event to record crashes caused by unhandled exceptions
    notification_emails:
      - crashes@example.com
    bugs:
      - https://bugzilla.mozilla.org/show_bug.cgi?id=1582479
    data_reviews:
      - https://bugzilla.mozilla.org/show_bug.cgi?id=1582479
    expires:
      2021-01-01
    send_in_pings:
      - crash
    extra_keys:
      cause:
        description: The cause of the crash
      message:
        description: The exception message
</code></pre>
<p>As a brief explanation, this creates a metric called <code>exception</code> within a metric category called <code>crash</code>.  There is a text
<code>description</code> and the required <code>notification_emails</code>, <code>bugs</code>, <code>data_reviews</code>, and <code>expires</code> fields.  The <code>send_in_pings</code> field
is important to note here that it has a value of <code>- crash</code>.  This means that the crash event metric will be sent via a custom
ping named <code>crash</code> (which hasn't been created yet).  Finally, note the <code>extra_keys</code> field which has two keys defined, <code>cause</code>
and <code>message</code>.  This allows for sending additional information along with the event to be associated with these keys.</p>
<p><strong>Note:</strong>  For Mozilla applications, a mandatory <a href="https://github.com/mozilla/data-review/blob/master/request.md">data review</a> is required in order to collect information with the Glean SDK.</p>
<h3><a class="header" href="#add-a-custom-ping" id="add-a-custom-ping">Add A Custom Ping</a></h3>
<p>Define the custom ping that will help control the upload scheduling by creating a <code>pings.yaml</code> file in the same directory as
the <code>metrics.yaml</code> file.  For more information about adding custom pings, see the section on <a href="user/pings/custom.html">custom pings</a>.<br />
The name of the ping will be <code>crash</code>, so the <code>pings.yaml</code> file should look like this:</p>
<pre><code class="language-YAML"># Required to indicate this is a `pings.yaml` file
$schema: moz://mozilla.org/schemas/glean/pings/1-0-0

crash:
  description: &gt;
    A ping to transport crash data
  include_client_id: true
  notification_emails:
    - crash@example.com
  bugs:
    - https://bugzilla.mozilla.org/show_bug.cgi?id=1582479
  data_reviews:
    - https://bugzilla.mozilla.org/show_bug.cgi?id=1582479
</code></pre>
<p>Before the newly defined metric or ping can be used, the application must first be built.  This will cause the <a href="https://github.com/mozilla/glean_parser/">glean_parser</a>
to execute and generate the API files that represent the metric and ping that were newly defined.</p>
<p><strong>Note:</strong> If changes to the YAML files aren't showing up in the project, try running the clean task on the project before
building any time one of the Glean YAML files has been modified.</p>
<p>It is recommended that Glean be initialized as early in the application startup as possible, which is why it's good to use a
custom <code>Application</code>, like the Glean Sample App <a href="https://github.com/mozilla/glean/blob/master/samples/android/app/src/main/java/org/mozilla/samples/glean/GleanApplication.kt"><code>GleanApplication.kt</code></a>.</p>
<p>Initializing Glean in the <code>Application.onCreate()</code> is ideal for this purpose.  Start by adding the import statement to allow
the usage of the custom ping that was created, adding the following to the top of the file:</p>
<pre><code class="language-Kotlin">import org.mozilla.gleancrashexample.GleanMetrics.Pings
</code></pre>
<p>Next, register the custom ping by calling <code>Glean.registerPings(Pings)</code> in the <code>onCreate()</code> function, preferably before calling
<code>Glean.initialize()</code>.  The completed function should look something like this:</p>
<pre><code class="language-Kotlin">override fun onCreate() {
  super.onCreate()

  // Register the application's custom pings.
  Glean.registerPings(Pings)

  // Initialize the Glean library
  Glean.initialize(applicationContext)
}

</code></pre>
<p>This completes the registration of the custom ping with the Glean SDK so that it knows about it and can manage the storage and
other important details of it like sending it when <code>send()</code> is called.</p>
<h3><a class="header" href="#instrument-the-app-to-record-the-event" id="instrument-the-app-to-record-the-event">Instrument The App To Record The Event</a></h3>
<p>In order to make the custom <code>Application</code> class handle uncaught exceptions, extend the class definition by adding
<code>Thread.UncaughtExceptionHandler</code> as an inherited class like this:</p>
<pre><code class="language-Kotlin">class MainActivity : AppCompatActivity(), Thread.UncaughtExceptionHandler {
    ...
}
</code></pre>
<p>As part of implementing the <code>Thread.UncaughtExceptionHandler</code> interface, the custom <code>Application</code> needs to implement the
override of the <code>uncaughtException()</code> function.  An example of this override that records data and sends the ping could look
something like this:</p>
<pre><code class="language-Kotlin">override fun uncaughtException(thread: Thread, exception: Throwable) {
    Crash.exception.record(
        mapOf(
            Crash.exceptionKeys.cause to exception.cause!!.toString(),
            Crash.exceptionKeys.message to exception.message!!
        )
    )
    Pings.crash.submit()
}
</code></pre>
<p>This records data to the <code>Crash.exception</code> metric from the <code>metrics.yaml</code>.  The category of the metric is <code>crash</code> and the name
is <code>exception</code> so it is accessed it by calling <code>record()</code> on the <code>Crash.exception</code> object.  The extra information for the
<code>cause</code> and the <code>message</code> is set as well.  Finally, calling <code>Pings.crash.submit()</code> forces the <code>crash</code> ping to be scheduled to be
sent.</p>
<p>The final step is to register the custom <code>Application</code> as the default uncaught exception handler by adding the following to the
<code>onCreate()</code> function after <code>Glean.initialize(this)</code>:</p>
<pre><code class="language-Kotlin">Thread.setDefaultUncaughtExceptionHandler(this)
</code></pre>
<h3><a class="header" href="#next-steps" id="next-steps">Next Steps</a></h3>
<p>This information didn't really get recorded by anything, as it would be rejected by the telemetry pipeline unless the
application was already known.  In order to collect telemetry from a new application, there is additional work that is
necessary that is beyond the scope of this example.  In order for data to be collected from your project, metadata must be
added to the <code>probe_scraper</code>.  The instructions for accomplishing this can be found in the <a href="https://github.com/mozilla/probe-scraper#adding-a-new-glean-repository"><code>probe_scraper</code> documentation</a>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/instrument-android-crashes-example.md">Edit this file on GitHub.</a></footer><!-- AUTOGENERATED BY glean_parser.  DO NOT EDIT. -->
<h1><a class="header" href="#metrics-1" id="metrics-1">Metrics</a></h1>
<p>This document enumerates the metrics collected by this project.
This project may depend on other projects which also collect metrics.
This means you might have to go searching through the dependency tree to get a full picture of everything collected by this project.</p>
<h1><a class="header" href="#pings" id="pings">Pings</a></h1>
<ul>
<li><a href="user/collected-metrics/metrics.html#all-pings">all-pings</a></li>
<li><a href="user/collected-metrics/metrics.html#baseline">baseline</a></li>
<li><a href="user/collected-metrics/metrics.html#deletion-request">deletion-request</a></li>
<li><a href="user/collected-metrics/metrics.html#metrics">metrics</a></li>
</ul>
<h2><a class="header" href="#all-pings" id="all-pings">all-pings</a></h2>
<p>These metrics are sent in every ping.</p>
<p>The following metrics are added to the ping:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Data reviews</th><th>Extras</th><th>Expiration</th></tr></thead><tbody>
<tr><td>glean.error.invalid_label</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html">labeled_counter</a></td><td>Counts the number of times a metric was set with an invalid label. The labels are the <code>category.name</code> identifier of the metric.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1499761#c5">1</a></td><td></td><td>never</td></tr>
<tr><td>glean.error.invalid_overflow</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html">labeled_counter</a></td><td>Counts the number of times a metric was set a value that overflew. The labels are the <code>category.name</code> identifier of the metric.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1591912#c3">1</a></td><td></td><td>never</td></tr>
<tr><td>glean.error.invalid_state</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html">labeled_counter</a></td><td>Counts the number of times a timing metric was used incorrectly. The labels are the <code>category.name</code> identifier of the metric.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1499761#c5">1</a></td><td></td><td>never</td></tr>
<tr><td>glean.error.invalid_value</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html">labeled_counter</a></td><td>Counts the number of times a metric was set to an invalid value. The labels are the <code>category.name</code> identifier of the metric.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1499761#c5">1</a></td><td></td><td>never</td></tr>
</tbody></table>
<h2><a class="header" href="#baseline" id="baseline">baseline</a></h2>
<p>This is a built-in ping that is assembled out of the box by the Glean SDK.</p>
<p>See the Glean SDK documentation for the <a href="https://mozilla.github.io/glean/book/user/pings/baseline.html"><code>baseline</code> ping</a>.</p>
<p>This ping includes the <a href="https://mozilla.github.io/glean/book/user/pings/index.html#the-client_info-section">client id</a>.</p>
<p><strong>Data reviews for this ping:</strong></p>
<ul>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1512938#c3">https://bugzilla.mozilla.org/show_bug.cgi?id=1512938#c3</a></li>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1599877#c25">https://bugzilla.mozilla.org/show_bug.cgi?id=1599877#c25</a></li>
</ul>
<p><strong>Bugs related to this ping:</strong></p>
<ul>
<li><a href="https://bugzilla.mozilla.org/1512938">https://bugzilla.mozilla.org/1512938</a></li>
<li><a href="https://bugzilla.mozilla.org/1599877">https://bugzilla.mozilla.org/1599877</a></li>
</ul>
<p><strong>Reasons this ping may be sent:</strong></p>
<ul>
<li>
<p><code>background</code>: The ping was submitted before going to background.</p>
</li>
<li>
<p><code>dirty_startup</code>: The ping was submitted at startup, because the application process was
killed before the Glean SDK had the chance to generate this ping, when
going to background, in the last session.</p>
<pre><code>*Note*: this ping will not contain the `glean.baseline.duration` metric.
</code></pre>
</li>
<li>
<p><code>foreground</code>: The ping was submitted when the application went to foreground, which
includes when the application starts.</p>
<pre><code>*Note*: this ping will not contain the `glean.baseline.duration` metric.
</code></pre>
</li>
</ul>
<p>The following metrics are added to the ping:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Data reviews</th><th>Extras</th><th>Expiration</th></tr></thead><tbody>
<tr><td>glean.baseline.duration</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/timespan.html">timespan</a></td><td>The duration of the last foreground session.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1512938#c3">1</a></td><td></td><td>never</td></tr>
<tr><td>glean.baseline.locale</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/string.html">string</a></td><td>The locale of the application during initialization (e.g. &quot;es-ES&quot;). If the locale can't be determined on the system, the value is <a href="https://unicode.org/reports/tr35/#Unknown_or_Invalid_Identifiers">&quot;und&quot;</a>, to indicate &quot;undetermined&quot;.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1512938#c3">1</a></td><td></td><td>never</td></tr>
</tbody></table>
<h2><a class="header" href="#deletion-request" id="deletion-request">deletion-request</a></h2>
<p>This ping is submitted when a user opts out of sending technical and interaction data to Mozilla. This ping is intended to communicate to the Data Pipeline that the user wishes to have their reported Telemetry data deleted. As such it attempts to send itself at the moment the user opts out of data collection.</p>
<p>This ping is sent if empty.</p>
<p>This ping includes the <a href="https://mozilla.github.io/glean/book/user/pings/index.html#the-client_info-section">client id</a>.</p>
<p><strong>Data reviews for this ping:</strong></p>
<ul>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1587095#c6">https://bugzilla.mozilla.org/show_bug.cgi?id=1587095#c6</a></li>
</ul>
<p><strong>Bugs related to this ping:</strong></p>
<ul>
<li><a href="https://bugzilla.mozilla.org/1587095">https://bugzilla.mozilla.org/1587095</a></li>
</ul>
<p>This ping contains no metrics.</p>
<h2><a class="header" href="#metrics-2" id="metrics-2">metrics</a></h2>
<p>This is a built-in ping that is assembled out of the box by the Glean SDK.</p>
<p>See the Glean SDK documentation for the <a href="https://mozilla.github.io/glean/book/user/pings/metrics.html"><code>metrics</code> ping</a>.</p>
<p>This ping includes the <a href="https://mozilla.github.io/glean/book/user/pings/index.html#the-client_info-section">client id</a>.</p>
<p><strong>Data reviews for this ping:</strong></p>
<ul>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1512938#c3">https://bugzilla.mozilla.org/show_bug.cgi?id=1512938#c3</a></li>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1557048#c13">https://bugzilla.mozilla.org/show_bug.cgi?id=1557048#c13</a></li>
</ul>
<p><strong>Bugs related to this ping:</strong></p>
<ul>
<li><a href="https://bugzilla.mozilla.org/1512938">https://bugzilla.mozilla.org/1512938</a></li>
</ul>
<p><strong>Reasons this ping may be sent:</strong></p>
<ul>
<li>
<p><code>overdue</code>: The last ping wasn't submitted on the current calendar day, but it's after
4am, so this ping submitted immediately</p>
</li>
<li>
<p><code>reschedule</code>: A ping was just submitted. This ping was rescheduled for the next calendar
day at 4am.</p>
</li>
<li>
<p><code>today</code>: The last ping wasn't submitted on the current calendar day, but it is
still before 4am, so schedule to send this ping on the current calendar
day at 4am.</p>
</li>
<li>
<p><code>tomorrow</code>: The last ping was already submitted on the current calendar day, so
schedule this ping for the next calendar day at 4am.</p>
</li>
<li>
<p><code>upgrade</code>: This ping was submitted at startup because the application was just
upgraded.</p>
</li>
</ul>
<p>The following metrics are added to the ping:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Data reviews</th><th>Extras</th><th>Expiration</th></tr></thead><tbody>
<tr><td>glean.error.preinit_tasks_overflow</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/counter.html">counter</a></td><td>The number of tasks queued in the pre-initialization buffer. Only sent if the buffer overflows.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1609482#c3">1</a></td><td></td><td>never</td></tr>
</tbody></table>
<!-- AUTOGENERATED BY glean_parser.  DO NOT EDIT. -->
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/user/collected-metrics/metrics.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#developing-the-glean-sdk" id="developing-the-glean-sdk">Developing the Glean SDK</a></h1>
<p>In this chapter we describe how to develop the Glean SDK.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#running-the-tests" id="running-the-tests">Running the tests</a></h1>
<h2><a class="header" href="#running-all-tests" id="running-all-tests">Running all tests</a></h2>
<p>The tests for all languages may be run from the command line:</p>
<pre><code>make test
</code></pre>
<blockquote>
<p><strong>Windows Note:</strong> On Windows, <code>make</code> is not available by default. While not required, installing <code>make</code> will allow you to use the convenience features in the <code>Makefile</code>.</p>
</blockquote>
<h2><a class="header" href="#running-the-rust-tests" id="running-the-rust-tests">Running the Rust tests</a></h2>
<p>The Rust tests may be run with the following command:</p>
<pre><code>cargo test --all
</code></pre>
<p>Log output can be controlled via the environment variable <code>RUST_LOG</code> for the <code>glean_core</code> crate:</p>
<pre><code>export RUST_LOG=glean_core=debug
</code></pre>
<p>When running tests with logging you need to tell <code>cargo</code> to not suppress output:</p>
<pre><code>cargo test -- --nocapture
</code></pre>
<p>Tests run in parallel by default, leading to interleaving log lines.
This makes it harder to understand what's going on.
For debugging you can force single-threaded tests:</p>
<pre><code>cargo test -- --nocapture --test-threads=1
</code></pre>
<h2><a class="header" href="#running-the-kotlinandroid-tests" id="running-the-kotlinandroid-tests">Running the Kotlin/Android tests</a></h2>
<h3><a class="header" href="#from-the-command-line" id="from-the-command-line">From the command line</a></h3>
<p>The full Android test suite may be run from the command line with:</p>
<pre><code>./gradlew test
</code></pre>
<h3><a class="header" href="#from-android-studio" id="from-android-studio">From Android Studio</a></h3>
<p>To run the full Android test suite, in the &quot;Gradle&quot; pane, navigate to <code>glean-core</code> -&gt; <code>Tasks</code> -&gt; <code>verification</code> and double-click either <code>testDebugUnitTest</code> or <code>testReleaseUnitTest</code> (depending on whether you want to run in Debug or Release mode).
You can save this task permanently by opening the task dropdown in the toolbar and selecting <code>&quot;Save glean.rs:glean:android [testDebugUnitTest] Configuration&quot;</code>.</p>
<p>To run a single Android test, navigate to the file containing the test, and right click on the green arrow in the left margin next to the test.  There you have a choice of running or debugging the test.</p>
<h2><a class="header" href="#running-the-swiftios-tests" id="running-the-swiftios-tests">Running the Swift/iOS tests</a></h2>
<h3><a class="header" href="#from-the-command-line-1" id="from-the-command-line-1">From the command line</a></h3>
<p>The full iOS test suite may be run from the command line with:</p>
<pre><code>make test-swift
</code></pre>
<h3><a class="header" href="#from-xcode" id="from-xcode">From Xcode</a></h3>
<p>To run the full iOS test suite, run tests in Xcode (<code>Product -&gt; Test</code>).
To run a single Swift test, navigate to the file containing the test,
and click on the arrow in the left margin next to the test.</p>
<h2><a class="header" href="#testing-in-ci" id="testing-in-ci">Testing in CI</a></h2>
<p>We run multiple tests on CI for every Pull Request and every commit to the <code>master</code> branch.
These include:</p>
<ul>
<li>Full Android tests</li>
<li>Full iOS tests</li>
<li>Rust tests</li>
<li>Rust, Kotlin and Swift source code formatting</li>
<li>Rust, Kotlin and Swift source code linting</li>
<li>Generating documentation from Rust, Kotlin, Swift and the book</li>
<li>Checking link validity of documentation</li>
<li>Deploying generated documentation</li>
</ul>
<p>These checks are required to pass before a Pull Request is merged.</p>
<h3><a class="header" href="#documentation-only-changes" id="documentation-only-changes">Documentation-only changes</a></h3>
<p>Documentation is deployed from CI, we therefore need it to run on documentation changes.
However, some of the long-running code tests can be skipped.
For that add the following literal string to the last commit message to be pushed:</p>
<pre><code>[doc only]
</code></pre>
<h3><a class="header" href="#skipping-ci-completely" id="skipping-ci-completely">Skipping CI completely</a></h3>
<p>It is possible to completely skip running CI on a given push by including the following literal string in the commit message:</p>
<pre><code>[ci skip]
</code></pre>
<p>This should only be used for metadata files, such as those in <code>.github</code>, <code>LICENSE</code> or <code>CODE_OF_CONDUCT.md</code>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/testing.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#developing-documentation" id="developing-documentation">Developing documentation</a></h1>
<p>The documentation in this repository pertains to the Glean SDK.  That is, the client-side code for Glean telemetry.
Documentation for Glean in general, and the Glean-specific parts of the data pipeline and analysis is <a href="https://docs.telemetry.mozilla.org/concepts/glean/glean.html">documented elsewhere</a> in the <a href="https://github.com/mozilla/firefox-data-docs"><code>firefox-data-docs</code> repository</a>.</p>
<p>The main narrative documentation is written in Markdown and converted to static HTML using <a href="https://rust-lang.github.io/mdBook/">mdbook</a>.</p>
<p>API docs are also generated from docstrings for Rust, Kotlin, Swift and Python.</p>
<h2><a class="header" href="#building-documentation" id="building-documentation">Building documentation</a></h2>
<h3><a class="header" href="#building-the-narrative-book-documentation" id="building-the-narrative-book-documentation">Building the narrative (book) documentation</a></h3>
<p>The <code>mdbook</code> crate is required in order to build the narrative documentation:</p>
<pre><code class="language-sh">cargo install mdbook
</code></pre>
<p>Then both the narrative and Rust API docs can be built with:</p>
<pre><code class="language-sh">make docs
# ...or...
bin/build-rust-docs.sh
# ...or on Windows...
bin/build-rust-docs.bat
</code></pre>
<p>The built narrative documentation is saved in <code>build/docs/book</code>, and the Rust API documentation is saved in <code>build/docs/docs</code>.</p>
<h3><a class="header" href="#building-api-documentation" id="building-api-documentation">Building API documentation</a></h3>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Kotlin" class="tab">
<p>Kotlin API documentation is generated using <a href="https://github.com/Kotlin/dokka">dokka</a>.
It is automatically installed by Gradle.</p>
<p>To build the Kotlin API documentation:</p>
<pre><code class="language-sh">make kotlin-docs
</code></pre>
<p>The generated documentation is saved in <code>build/docs/javadoc</code>.</p>
</div>
<div data-lang="Swift" class="tab">
<p>Swift API documentation is generated using <a href="https://github.com/realm/jazzy">jazzy</a>. 
It can be installed using:</p>
<ol>
<li>Install the latest Ruby: <code>brew install ruby</code></li>
<li>Make the installed Ruby available: <code>export PATH=/usr/local/opt/ruby/bin:$PATH</code> (and add that line to your <code>.bashrc</code>)</li>
<li>Install the documentation tool: <code>gem install jazzy</code></li>
</ol>
<p>To build the Swift API documentation:</p>
<pre><code class="language-sh">make swift-docs
</code></pre>
<p>The generated documentation is saved in <code>build/docs/swift</code>.</p>
</div>
<div data-lang="Python" class="tab">
<p>The Python API docs are generated using <a href="https://pdoc3.github.io/pdoc/">pdoc3</a>.
It is installed as part of <a href="dev/python/setting-up-python-build-environment.html#create-a-virtual-environment">creating the virtual environment for Python development</a>.</p>
<p>To build the Python API documentation:</p>
<pre><code>make python-docs
</code></pre>
<p>The generated documentation is saved in <code>build/docs/python</code>.</p>
</div>
</div>
</div>
<h3><a class="header" href="#checking-links" id="checking-links">Checking links</a></h3>
<p>Internal links within the documentation can be checked using the <a href="http://wummel.github.io/linkchecker/"><code>linkchecker</code></a> tool.
External links are currently not checked, since this takes considerable time and frequently fails in CI due to networking restrictions or issues.</p>
<p>Link checking requires building the narrative documentation as well as all of the API documentation for all languages.
It is rare to build all of these locally (and in particular, the Swift API documentation can only be built on macOS), therefore it is reasonable to let CI catch broken link errors for you.</p>
<p>However, if you do want to run the <code>linkchecker</code> locally, it can be installed
using <code>pip</code> or your system's package manager. Then, run <code>linkchecker</code> with:</p>
<pre><code class="language-sh">make linkcheck
</code></pre>
<h3><a class="header" href="#spell-checking" id="spell-checking">Spell checking</a></h3>
<p>The narrative documentation (but not the API documentation) is spell checked using <a href="http://aspell.net/">aspell</a>.</p>
<p>On Unix-like platforms, it can be installed using your system's package manager:</p>
<pre><code class="language-sh">sudo apt install aspell-en
# ...or...
sudo dnf install aspell-en
# ...or...
brew install aspell
</code></pre>
<p>Note that aspell 0.60.8 or later is required, as that is the first release with markdown support.</p>
<p>You can the spell check the narrative documentation using the following:</p>
<pre><code class="language-sh">make spellcheck
# ...or...
bin/spellcheck.sh
</code></pre>
<p>This will bring up an interactive spell-checking environment in the console.
Pressing <code>a</code> to add a word will add it to the project's local <code>.dictionary</code> file, and the changes should be committed to <code>git</code>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/docs.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#android-bindings" id="android-bindings">Android bindings</a></h1>
<p>The Glean SDK contains the Kotlin bindings for use by Android applications.
It makes use of the underlying <a href="dev/android/../core/index.html">Rust component</a> with a Kotlin-specific API on top.
It also includes integrations into the Android platform.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/android/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#setup-the-android-build-environment" id="setup-the-android-build-environment">Setup the Android Build Environment</a></h1>
<h2><a class="header" href="#doing-a-local-build-of-the-android-components" id="doing-a-local-build-of-the-android-components">Doing a local build of the Android Components:</a></h2>
<p>This document describes how to make local builds of the Android bindings in this
repository. Most consumers of these bindings <em>do not</em> need to follow this
process, but will instead <a href="dev/android/../../user/adding-glean-to-your-project.html">use pre-built
bindings</a>.</p>
<h2><a class="header" href="#prepare-your-build-environment" id="prepare-your-build-environment">Prepare your build environment</a></h2>
<p>Typically, this process only needs to be run once, although periodically you
may need to repeat some steps (e.g., rust updates should be done periodically)</p>
<h3><a class="header" href="#setting-up-android-dependencies" id="setting-up-android-dependencies">Setting up Android dependencies</a></h3>
<p>At the end of this process you should have the following environment variables set up.</p>
<ul>
<li><code>ANDROID_HOME</code></li>
<li><code>ANDROID_NDK_ROOT</code></li>
<li><code>JAVA_HOME</code></li>
</ul>
<p>The easiest way to install all the dependencies (and automatically
handle updates), is by using <a href="https://developer.android.com/studio/index.html">Android Studio</a>.
Once this is installed, it must be run and the Glean project opened to complete initial setup.
If Android Studio asks you to upgrade the version of Gradle, decline.</p>
<p>The following dependencies can be installed in Android Studio through <code>Tools &gt; SDK Manager &gt; SDK Tools</code>:</p>
<ul>
<li>Android SDK Tools (may already be selected)</li>
<li>NDK r20</li>
<li>CMake</li>
<li>LLDB</li>
</ul>
<p>With the dependencies installed, note down the <code>Android SDK Location</code> in <code>Tools &gt; SDK Manager</code>.
Set the <code>ANDROID_HOME</code> environment variable to that path.
The <code>ANDROID_NDK_ROOT</code> can be set to <code>ANDROID_NDK_ROOT=$ANDROID_HOME/ndk-bundle</code>.
Set <code>JAVA_HOME</code> to be the location of Android Studio's JDK which can be found in Glean's &quot;Project Structure&quot; menu. (You may need to escape spaces in the path).</p>
<p>If you want to install the NDK manually:</p>
<ol>
<li>Download NDK r20 from <a href="https://developer.android.com/ndk/downloads">https://developer.android.com/ndk/downloads</a>.</li>
<li>Extract it and put it somewhere (<code>$HOME/.android-ndk-r20</code> is a reasonable choice, but it doesn't matter).</li>
<li>Set <code>ANDROID_NDK_ROOT</code> to this path.
<ul>
<li>Set <code>ANDROID_NDK_HOME</code> to match <code>ANDROID_NDK_ROOT</code>, for compatibility with some android Gradle plugins.</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#setting-up-rust" id="setting-up-rust">Setting up Rust</a></h3>
<p>Rust can be installed using <code>rustup</code>, with the following commands:</p>
<ul>
<li><code>curl https://sh.rustup.rs -sSf | sh</code></li>
<li><code>rustup update</code></li>
</ul>
<p>Platform specific toolchains need to be installed for Rust. This can be
done using the <code>rustup target</code> command. In order to enable building to real
devices and Android emulators, the following targets need to be installed:</p>
<ul>
<li><code>rustup target add aarch64-linux-android</code></li>
<li><code>rustup target add armv7-linux-androideabi</code></li>
<li><code>rustup target add i686-linux-android</code></li>
<li><code>rustup target add x86_64-linux-android</code></li>
</ul>
<h2><a class="header" href="#building" id="building">Building</a></h2>
<p>This should be relatively straightforward and painless:</p>
<ol>
<li>
<p>Ensure your repository is up-to-date.</p>
</li>
<li>
<p>Ensure Rust is up-to-date by running <code>rustup update</code>.</p>
</li>
<li>
<p>The builds are all performed by <code>./gradlew</code> and the general syntax used is
<code>./gradlew project:task</code></p>
<p>You can see a list of projects by executing <code>./gradlew projects</code> and a list
of tasks by executing <code>./gradlew tasks</code>.</p>
</li>
</ol>
<p>The above can be skipped if using <code>Android Studio</code>. The project directory can be imported
and all the build details can be left to the IDE.</p>
<h2><a class="header" href="#faq" id="faq">FAQ</a></h2>
<ul>
<li>
<p><strong>Q: Android Studio complains about Python not being found when building.</strong></p>
</li>
<li>
<p>A: Make sure that the <code>python</code> binary is on your <code>PATH</code>. On Windows, in addition to that,
it might be required to add its full path to the <code>rust.pythonCommand</code> entry in  <code>$project_root/local.properties</code>.</p>
</li>
<li>
<p><strong>Q: Android Studio complains about <code>Toolchain for X does not exist</code>.</strong></p>
</li>
<li>
<p>A: On Windows, make sure that the <code>ndk.dir</code> property in <code>$project_root/local.properties</code> points to an existing
directory containing the Android NDK.</p>
</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/android/setup-android-build-environment.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#ios-bindings" id="ios-bindings">iOS bindings</a></h1>
<p>The Glean SDK contains the Swift bindings for use by iOS applications.
It makes use of the underlying <a href="dev/ios/../core/index.html">Rust component</a> with a Swift-specific API on top.
It also includes integrations into the iOS platform.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/ios/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#setup-the-ios-build-environment" id="setup-the-ios-build-environment">Setup the iOS Build Environment</a></h1>
<h2><a class="header" href="#prepare-your-build-environment-1" id="prepare-your-build-environment-1">Prepare your build environment</a></h2>
<ol>
<li>Install Xcode 11.0</li>
<li>Install <a href="https://github.com/Carthage/Carthage">Carthage</a>: <code>brew install carthage</code></li>
<li>Ensure you have Python 3 installed: <code>brew install python</code></li>
<li>Install linting and formatting tools: <code>brew install swiftlint swiftformat</code></li>
<li>Run <code>bin/bootstrap.sh</code> to download dependencies.</li>
<li>(Optional, only required for building on the CLI) Install <a href="https://github.com/xcpretty/xcpretty">xcpretty</a>: <code>gem install xcpretty</code></li>
</ol>
<h3><a class="header" href="#setting-up-rust-1" id="setting-up-rust-1">Setting up Rust</a></h3>
<p>Rust can be installed using <code>rustup</code>, with the following commands:</p>
<ul>
<li><code>curl https://sh.rustup.rs -sSf | sh</code></li>
<li><code>rustup update</code></li>
</ul>
<p>Platform specific toolchains need to be installed for Rust. This can be
done using the <code>rustup target</code> command. In order to enable building to real
devices and iOS emulators, the following targets need to be installed:</p>
<pre><code>rustup target add aarch64-apple-ios x86_64-apple-ios
</code></pre>
<h2><a class="header" href="#building-1" id="building-1">Building</a></h2>
<p>This should be relatively straightforward and painless:</p>
<ol>
<li>
<p>Ensure your repository is up-to-date.</p>
</li>
<li>
<p>Ensure Rust is up-to-date by running <code>rustup update</code>.</p>
</li>
<li>
<p>Run a build using the command <code>make build-swift</code></p>
<ul>
<li>To run tests use <code>make test-swift</code></li>
</ul>
</li>
</ol>
<p>The above can be skipped if using Xcode.
The project directory can be imported and all the build details can be left to the IDE.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/ios/setup-ios-build-environment.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#debug-an-ios-application-against-different-builds-of-glean" id="debug-an-ios-application-against-different-builds-of-glean">Debug an iOS application against different builds of Glean</a></h1>
<p>At times it may be necessary to debug against a local build of Glean or another git fork or branch in order to test new features or specific versions of Glean.</p>
<p>Since Glean is consumed through <a href="https://github.com/Carthage/Carthage">Carthage</a>, this can be as simple as modifying the Cartfile for the consuming application.</p>
<h2><a class="header" href="#building-against-the-latest-glean" id="building-against-the-latest-glean">Building against the latest Glean</a></h2>
<p>For consuming the latest version of Glean, the Cartfile contents would include the following line:</p>
<pre><code>github &quot;mozilla/glean&quot; &quot;master&quot;
</code></pre>
<p>This will fetch and compile Glean from the <a href="https://github.com/mozilla/glean/">mozilla/glean GitHub</a> repository from the &quot;master&quot; branch.</p>
<h2><a class="header" href="#building-against-a-specific-release-of-glean" id="building-against-a-specific-release-of-glean">Building against a specific release of Glean</a></h2>
<p>For consuming a specific version of Glean, you can specify a branch name, tag name, or commit ID, like this:</p>
<pre><code>github &quot;mozilla/glean&quot; &quot;v0.0.1&quot;
</code></pre>
<p>Where <code>v0.0.1</code> is a tagged release name, but could also be a branch name or a specific commit ID like <code>832b222</code></p>
<p>If the custom Glean you wish to build from is a different fork on GitHub, you could simply modify the Cartfile to point at your fork like this:</p>
<pre><code>github &quot;myGitHubHandle/glean&quot; &quot;myBranchName&quot;
</code></pre>
<p>Replace the <code>myGitHubHandle</code> and <code>myBranchName</code> with your GitHub handle and branch name, as appropriate.</p>
<h2><a class="header" href="#build-from-a-locally-cloned-glean" id="build-from-a-locally-cloned-glean">Build from a locally cloned Glean</a></h2>
<p>You can also use Carthage to build from a local clone by replacing the Cartfile line with the following:</p>
<pre><code>git &quot;file:///Users/yourname/path/to/glean&quot; &quot;localBranchName&quot;
</code></pre>
<p>Notice that the initial Carthage command is <code>git</code> now instead of <code>github</code>, and we need to use a file URL of the path to the locally cloned Glean</p>
<h2><a class="header" href="#perform-the-carthage-update" id="perform-the-carthage-update">Perform the Carthage update</a></h2>
<p>One last thing not to forget is to run the <code>carthage update</code> command in the directory your Cartfile resides in order to fetch and build Glean.</p>
<p>Once that is done, your local application should be building against the version of Glean that you specified in the Cartfile.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/ios/debug-glean-on-ios.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#python-bindings" id="python-bindings">Python bindings</a></h1>
<p>The Glean SDK contains Python bindings for use in Python applications and test frameworks.
It makes use of the underlying <a href="dev/python/../core/index.html">Rust component</a> with a Python-specific API on top.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/python/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#setup-the-python-build-environment" id="setup-the-python-build-environment">Setup the Python Build Environment</a></h1>
<p>This document describes how to set up an environment for the development of the Glean Python bindings.</p>
<p>Instructions for installing a copy of the Glean Python bindings into your own environment for use in your project are described in <a href="dev/python/../../user/adding-glean-to-your-project.html">adding Glean to your project</a>.</p>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<p>Glean requires Python 3.5 or later.</p>
<p>Make sure it is installed on your system and accessible on the <code>PATH</code> as <code>python3</code>.</p>
<h3><a class="header" href="#setting-up-rust-2" id="setting-up-rust-2">Setting up Rust</a></h3>
<p>If you've already set up Rust for building Glean for Android or iOS, you already have everything you need and can skip this section.</p>
<p>Rust can be installed using <code>rustup</code>, with the following commands:</p>
<ul>
<li><code>curl https://sh.rustup.rs -sSf | sh</code></li>
<li><code>rustup update</code></li>
</ul>
<h2><a class="header" href="#create-a-virtual-environment" id="create-a-virtual-environment">Create a virtual environment</a></h2>
<p>It is recommended to do all Python development inside a virtual environment to make sure there are no interactions with other Python libraries installed on your system.</p>
<p>You may want to manage your own virtual environment if, for example, you are developing a library that is using Glean and you want to install Glean into it.  If you are just developing Glean itself, however, Glean's <code>Makefile</code> will handle the creation and use of a virtual environment automatically (though the <code>Makefile</code> unfortunately does not work on Microsoft Windows).</p>
<p>The instructions below all have both the manual instructions and the <code>Makefile</code> shortcuts.</p>
<h3><a class="header" href="#manual-method" id="manual-method">Manual method</a></h3>
<p>The following instructions use the basic <a href="https://docs.python.org/3/library/venv.html">virtual environment functionality that comes in the Python standard library</a>.
Other higher level tools exist to manage virtual environments, such as <a href="https://pipenv.kennethreitz.org/en/latest/">pipenv</a> and <a href="https://docs.conda.io/en/latest/">conda</a>.
These will work just as well, but are not documented here.
Using an alternative tool would replace the instructions in this section only, but all other instructions below would remain the same.</p>
<p>To create a virtual environment, enter the following command, replacing <code>&lt;venv&gt;</code> with the path to the virtual environment you want to create.  You will need to do this only once.</p>
<pre><code class="language-bash">  $ python3 -m venv &lt;venv&gt;
</code></pre>
<p>Then activate the environment. You will need to do this for each new shell session when you want to develop Glean.
The command to use depends on your shell environment.</p>
<table><thead><tr><th>Platform</th><th>Shell</th><th>Command to activate virtual environment</th></tr></thead><tbody>
<tr><td>POSIX</td><td>bash/zsh</td><td><code>source &lt;venv&gt;/bin/activate</code></td></tr>
<tr><td></td><td>fish</td><td><code>. &lt;venv&gt;/bin/activate.fish</code></td></tr>
<tr><td></td><td>csh/tcsh</td><td><code>source &lt;venv&gt;bin/activate.csh</code></td></tr>
<tr><td></td><td>PowerShell Core</td><td><code>&lt;venv&gt;/bin/Activate.ps1</code></td></tr>
<tr><td>Windows</td><td>cmd.exe</td><td><code>&lt;venv&gt;\Scripts\activate.bat</code></td></tr>
<tr><td></td><td>PowerShell</td><td><code>&lt;venv&gt;\Scripts\Activate.ps1</code></td></tr>
</tbody></table>
<p>Lastly, install Glean's Python development dependencies into the virtual environment.</p>
<pre><code class="language-bash">cd glean-core/python
pip install -r requirements_dev.txt
</code></pre>
<h3><a class="header" href="#makefile-method" id="makefile-method">Makefile method</a></h3>
<pre><code class="language-bash">  $ make python-setup
</code></pre>
<p>The default location of the virtual environment used by the make file is <code>glean-core/python/.venvX.Y</code>, where <code>X.Y</code> is the version of Python in use. This makes it possible to build and test for multiple versions of Python in the same checkout.</p>
<blockquote>
<p><em>Note:</em> If you wish to change the location of the virtual environment that the <code>Makefile</code> uses, pass the <code>GLEAN_PYENV</code> environment variable: <code>make python-setup GLEAN_PYENV=mypyenv</code>.</p>
</blockquote>
<p>By default, the <code>Makefile</code> installs the latest version available of each of Glean's dependencies.  If you wish to install the minimum required versions instead, (useful primarily to ensure that Glean doesn't unintentionally use newer APIs in its dependencies) pass the <code>GLEAN_PYDEPS=min</code> environment variable: <code>make python-setup GLEAN_PYDEPS=min</code>.</p>
<h2><a class="header" href="#build-the-python-bindings" id="build-the-python-bindings">Build the Python bindings</a></h2>
<h3><a class="header" href="#manual-method-1" id="manual-method-1">Manual method</a></h3>
<p>First, rebuild the Rust core if any Rust changes were made:</p>
<pre><code class="language-bash">  $ cargo build  # If there were Rust changes
  $ cd glean-core/python
  $ python setup.py install
</code></pre>
<h3><a class="header" href="#makefile-method-1" id="makefile-method-1">Makefile method</a></h3>
<p>This will implicitly setup the Python environment, rebuild the Rust core and then build the Python bindings.</p>
<pre><code class="language-bash">  $ make build-python
</code></pre>
<h2><a class="header" href="#running-the-python-unit-tests" id="running-the-python-unit-tests">Running the Python unit tests</a></h2>
<h3><a class="header" href="#manual-method-2" id="manual-method-2">Manual method</a></h3>
<p>Make sure the Python bindings are built, then:</p>
<pre><code class="language-bash">  $ cd glean-core/python
  $ py.test
</code></pre>
<h3><a class="header" href="#makefile-method-2" id="makefile-method-2">Makefile method</a></h3>
<p>The following will run the Python unit tests using <code>py.test</code>:</p>
<pre><code class="language-bash">  $ make test-python
</code></pre>
<p>You can send extra parameters to the <code>py.test</code> command by setting the <code>PYTEST_ARGS</code> variable:</p>
<pre><code class="language-bash">  $ make test-python PYTEST_ARGS=&quot;-s --pdb&quot;
</code></pre>
<h2><a class="header" href="#viewing-logging-output" id="viewing-logging-output">Viewing logging output</a></h2>
<p>The Glean Python bindings have two sources of log messages: those that come from Python and those that come from Rust.</p>
<h3><a class="header" href="#python-log-messages" id="python-log-messages">Python log messages</a></h3>
<p>Python log messages are emitted using the Python standard library's <a href="https://docs.python.org/3/library/logging.html"><code>logging</code> module</a>.
This module provides a lot of possibilities for customization, but the easiest way to control the log level globally is with <a href="https://docs.python.org/3/library/logging.html#logging.basicConfig"><code>logging.basicConfig</code></a>:</p>
<pre><code class="language-python">import logging
logging.basicConfig(level=logging.DEBUG)
</code></pre>
<h3><a class="header" href="#rust-log-messages" id="rust-log-messages">Rust log messages</a></h3>
<p>Rust log messages are emitted using <a href="https://docs.rs/env_logger/latest/env_logger/"><code>env_logger</code></a>.
The log level can be controlled with the <code>RUST_LOG</code> environment variable:</p>
<pre><code class="language-python">import os
os.environ[&quot;RUST_LOG&quot;] = &quot;DEBUG&quot;
</code></pre>
<h2><a class="header" href="#linting-formatting-and-type-checking" id="linting-formatting-and-type-checking">Linting, formatting and type checking</a></h2>
<p>The Glean Python bindings use the following tools:</p>
<ul>
<li>Linting: <a href="http://flake8.pycqa.org/en/latest/">flake8</a></li>
<li>Formatting: <a href="https://black.readthedocs.io/en/stable/">black</a></li>
<li>Type-checking: <a href="http://mypy-lang.org/">mypy</a></li>
</ul>
<h3><a class="header" href="#manual-method-3" id="manual-method-3">Manual method</a></h3>
<pre><code class="language-bash">  $ cd glean-core/python
  $ flake8 glean tests
  $ black glean tests
  $ mypy glean
</code></pre>
<h3><a class="header" href="#makefile-method-3" id="makefile-method-3">Makefile method</a></h3>
<p>To just check the lints:</p>
<pre><code class="language-bash">  $ make pythonlint
</code></pre>
<p>To reformat the Python files in-place:</p>
<pre><code class="language-bash">  $ make pythonfmt
</code></pre>
<h2><a class="header" href="#building-the-python-api-docs" id="building-the-python-api-docs">Building the Python API docs</a></h2>
<p>The Python API docs are built using <a href="https://pdoc3.github.io/pdoc/">pdoc3</a>.</p>
<h3><a class="header" href="#manual-method-4" id="manual-method-4">Manual method</a></h3>
<pre><code class="language-bash">  $ python -m pdoc --html glean --force -o build/docs/python
</code></pre>
<h3><a class="header" href="#makefile-method-4" id="makefile-method-4">Makefile method</a></h3>
<pre><code class="language-bash">  $ make python-docs
</code></pre>
<h2><a class="header" href="#building-wheels-for-linux" id="building-wheels-for-linux">Building wheels for Linux</a></h2>
<p>Building on Linux using the above instructions will create Linux binaries that dynamically link against the version of <code>libc</code> installed on your machine. 
This generally will not be portable to other Linux distributions, and PyPI will not even allow it to be uploaded.
In order to create wheels that can be installed on the broadest range of Linux distributions, the Python Packaging Authority's <a href="https://github.com/pypa/manylinux">manylinux</a> project maintains a Docker image for building compatible Linux wheels.</p>
<p>The CircleCI configuration handles making these wheels from tagged releases.
If you need to reproduce this locally, see the CircleCI job <code>pypi-linux-release</code> for an example of how this Docker image is used in practice.</p>
<h2><a class="header" href="#building-wheels-for-windows" id="building-wheels-for-windows">Building wheels for Windows</a></h2>
<p>The official wheels for Windows are produced on a Linux virtual machine using the Mingw toolchain.</p>
<p>The CircleCI configuration handles making these wheels from tagged releases.
If you need to reproduce this locally, see the CircleCI job <code>pypi-windows-release</code> for an example of how this is done in practice.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/python/setting-up-python-build-environment.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#rust-component" id="rust-component">Rust component</a></h1>
<p>The majority of the Glean SDK is implemented as a Rust component, to be usable across all platforms.</p>
<p>This includes:</p>
<ul>
<li>Implementations of all metric types</li>
<li>A storage layer</li>
<li>A ping serializer</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#dependency-management-guidelines" id="dependency-management-guidelines">Dependency Management Guidelines</a></h1>
<p>This repository uses third-party code from a variety of sources, so we need to be mindful
of how these dependencies will affect our consumers.  Considerations include:</p>
<ul>
<li>General code quality.</li>
<li><a href="https://www.mozilla.org/en-US/MPL/license-policy/#Licenses_Compatible_with_the_MPL">Licensing compatibility</a>.</li>
<li>Handling of security vulnerabilities.</li>
<li>The potential for <a href="https://medium.com/intrinsic/compromised-npm-package-event-stream-d47d08605502">supply-chain compromise</a>.</li>
</ul>
<p>We're still evolving our policies in this area, but these are the
guidelines we've developed so far.</p>
<h2><a class="header" href="#rust-code" id="rust-code">Rust Code</a></h2>
<p>Unlike <a href="https://firefox-source-docs.mozilla.org/build/buildsystem/rust.html">Firefox</a>,
we do not vendor third-party source code directly into the repository.  Instead we rely on
<code>Cargo.lock</code> and its hash validation to ensure that each build uses an identical copy
of all third-party crates.  These are the measures we use for ongoing maintenance of our
existing dependencies:</p>
<ul>
<li>Check <code>Cargo.lock</code> into the repository.</li>
<li>Generate built artifacts using the <code>--locked</code> flag to <code>cargo build</code>, as an additional
assurance that the existing <code>Cargo.lock</code> will be respected.</li>
<li>Use <a href="https://github.com/EmbarkStudios/cargo-deny">cargo-deny</a> for a basic license-compatibility
check as part of CI, to guard against human error.</li>
</ul>
<p>Adding a new dependency, whether we like it or not, is a big deal - that dependency and everything
it brings with it will become part of Firefox-branded products that we ship to end users.
We try to balance this responsibility against the many benefits of using existing code, as follows:</p>
<ul>
<li>In general, be conservative in adding new third-party dependencies.
<ul>
<li>For trivial functionality, consider just writing it yourself.
Remember the cautionary tale of <a href="https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/">left-pad</a>.</li>
<li>Check if we already have a crate in our dependency tree that can provide the needed functionality.</li>
</ul>
</li>
<li>Prefer crates that have a a high level of due-diligence already applied, such as:
<ul>
<li>Crates that are <a href="https://dxr.mozilla.org/mozilla-central/source/third_party/rust">already vendored into Firefox</a>.</li>
<li>Crates from <a href="https://github.com/rust-lang-nursery">rust-lang-nursery</a> or <a href="https://github.com/rust-lang">rust-lang</a>.</li>
<li>Crates that appear to be widely used in the Rust community.</li>
</ul>
</li>
<li>Check that it is clearly licensed and is <a href="https://www.mozilla.org/en-US/MPL/license-policy/#Licenses_Compatible_with_the_MPL">MPL-2.0 compatible</a>.</li>
<li>Take the time to investigate the crate's source and ensure it is suitably high-quality.
<ul>
<li>Be especially wary of uses of <code>unsafe</code>, or of code that is unusually resource-intensive to build.</li>
<li>Development dependencies do not require as much scrutiny as dependencies that will ship in consuming applications,
but should still be given some thought.
<ul>
<li>There is still the potential for supply-chain compromise with development dependencies!</li>
</ul>
</li>
</ul>
</li>
<li>Explicitly describe your consideration of these points in the PR that introduces the new dependency.</li>
</ul>
<p>Updating to new versions of existing dependencies is a normal part of software development
and is not accompanied by any particular ceremony.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/dependency-management.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#adding-a-new-metric-type" id="adding-a-new-metric-type">Adding a new metric type</a></h1>
<p>Data in the Glean SDK is stored in so-called metrics.
You can find the full list of implemented metric types <a href="dev/core/../../user/metrics/index.html">in the user overview</a>.</p>
<p>Adding a new metric type involves defining the metric type's API, its persisted and in-memory storage as well as its serialization into the ping payload.</p>
<h2><a class="header" href="#the-metric-types-api" id="the-metric-types-api">The metric type's API</a></h2>
<p>A metric type implementation is defined in its own file under <code>glean-core/src/metrics/</code>, e.g. <code>glean-core/src/metrics/counter.rs</code> for a <a href="dev/core/../../user/metrics/counter.html">Counter</a>.</p>
<p>Start by defining a structure to hold the metric's metadata:</p>
<pre><code class="language-rust noplaypen">#[derive(Clone, Debug)]
pub struct CounterMetric {
    meta: CommonMetricData
}
</code></pre>
<p>Implement the <code>MetricType</code> trait to create a metric from the meta data as well as expose the meta data.
This also gives you a <code>should_record</code> method on the metric type.</p>
<pre><code class="language-rust noplaypen">impl MetricType for CounterMetric {
    fn meta(&amp;self) -&gt; &amp;CommonMetricData {
        &amp;self.meta
    }

    fn meta_mut(&amp;mut self) -&gt; &amp;mut CommonMetricData {
        &amp;mut self.meta
    }
}
</code></pre>
<p>Its implementation should have a way to create a new metric from the common metric data. It should be the same for all metric types.</p>
<pre><code class="language-rust noplaypen">impl CounterMetric {
    pub fn new(meta: CommonMetricData) -&gt; Self {
        Self { meta }
    }
}
</code></pre>
<p>Implement each method for the type. The first argument to accept should always be <code>glean: &amp;Glean</code>, that is: a reference to the <code>Glean</code> object, used to access the storage:</p>
<pre><code class="language-rust noplaypen">impl CounterMetric { // same block as above
    pub fn add(&amp;self, glean: &amp;Glean, amount: i32) {
        // Always include this check!
        if !self.should_record() {
            return;
        }

        // Do error handling here

        glean
            .storage()
            .record_with(&amp;self.meta, |old_value| match old_value {
                Some(Metric::Counter(old_value)) =&gt; Metric::Counter(old_value + amount),
                _ =&gt; Metric::Counter(amount),
            })
    }
}
</code></pre>
<p>Use <code>glean.storage().record()</code> to record a fixed value or <code>glean.storage.record_with()</code> to construct a new value from the currently stored one.</p>
<p>The storage operation makes use of the metric's variant of the <code>Metric</code> enumeration.</p>
<h2><a class="header" href="#the-metric-enumeration" id="the-metric-enumeration">The <code>Metric</code> enumeration</a></h2>
<p>Persistence and in-memory serialization as well as ping payload serialization are handled through the <code>Metric</code> enumeration.
This is defined in <code>glean-core/src/metrics/mod.rs</code>.
Variants of this enumeration are used in the storage implementation of the metric type.</p>
<p>To add a new metric type, include the metric module and declare its use, then add a new variant to the <code>Metric</code> enum:</p>
<pre><code class="language-rust noplaypen">
mod counter;

// ...

pub use self::counter::CounterMetric;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum Metric {
    // ...
    Counter(i32),
}
</code></pre>
<p>Then modify the below implementation and define the right ping section name for the new type. This will be used in the ping payload:</p>
<pre><code class="language-rust noplaypen">impl Metric {
    pub fn ping_section(&amp;self) -&gt; &amp;'static str {
        match self {
            // ...
            Metric::Counter(_) =&gt; &quot;counter&quot;,
        }
    }
}
</code></pre>
<p>Finally, define the ping payload serialization (as JSON).
In the simple cases where the in-memory representation maps to its JSON representation it is enough to call the <code>json!</code> macro.</p>
<pre><code class="language-rust noplaypen">impl Metric { // same block as above
    pub fn as_json(&amp;self) -&gt; JsonValue {
        match self {
            // ...
            Metric::Counter(c) =&gt; json!(c),
        }
    }
}
</code></pre>
<p>For more complex serialization consider implementing serialization logic as a function returning a <a href="https://docs.rs/serde_json/*/serde_json/enum.Value.html"><code>serde_json::Value</code></a>
or another object that can be serialized.</p>
<p>For example, the <code>DateTime</code> serializer has the following entry, where <code>get_iso_time_string</code> is a function to convert from the <code>DateTime</code> metric representation to a string:</p>
<pre><code class="language-rust noplaypen">Metric::Datetime(d, time_unit) =&gt; json!(get_iso_time_string(*d, *time_unit)),
</code></pre>
<hr />
<p>In the next step we will create the FFI wrapper and platform-specific wrappers.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/new-metric-type.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#adding-a-new-metric-type---ffi-layer" id="adding-a-new-metric-type---ffi-layer">Adding a new metric type - FFI layer</a></h1>
<p>In order to use a new metric type over the FFI layer, it needs implementations in the FFI component.</p>
<h2><a class="header" href="#ffi-component" id="ffi-component">FFI component</a></h2>
<p>The FFI component implementation can be found in <code>glean-core/ffi/src</code>.
Each metric type is implemented in its own module.</p>
<p>Add a new file named after your metric, e.g. <code>glean-core/ffi/src/counter.rs</code>, and declare it in <code>glean-core/ffi/src/lib.rs</code> with <code>mod counter;</code>.</p>
<p>In the metric type module define your metric type using the <code>define_metric</code> macro.
This allows referencing the metric name and defines the global map as well as some common functions such as the constructor and destructor.
Simple operations can be also defined in the same macro invocation:</p>
<pre><code class="language-rust noplaypen">use crate::{define_metric, handlemap_ext::HandleMapExtension, GLEAN};

define_metric!(CounterMetric =&gt; COUNTER_METRICS {
    new           -&gt; glean_new_counter_metric(),
    destroy       -&gt; glean_destroy_counter_metric,

    add -&gt; glean_counter_add(amount: i32),
});
</code></pre>
<p>More complex operations need to be defined as plain functions.
For example the test helper function for a counter metric can be defined as:</p>
<pre><code class="language-rust noplaypen">#[no_mangle]
pub extern &quot;C&quot; fn glean_counter_test_has_value(
    glean_handle: u64,
    metric_id: u64,
    storage_name: FfiStr,
) -&gt; u8 {
    GLEAN.call_infallible(glean_handle, |glean| {
        COUNTER_METRICS.call_infallible(metric_id, |metric| {
            metric
                .test_get_value(glean, storage_name.as_str())
                .is_some()
        })
    })
}
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/new-metric-type/ffi.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#adding-a-new-metric-type---kotlin" id="adding-a-new-metric-type---kotlin">Adding a new metric type - Kotlin</a></h1>
<h2><a class="header" href="#ffi" id="ffi">FFI</a></h2>
<p>The platform-specific FFI wrapper needs the definitions of these new functions.
For Kotlin this is in <code>glean-core/android/src/main/java/mozilla/telemetry/glean/rust/LibGleanFFI.kt</code>:</p>
<pre><code class="language-kotlin">fun glean_new_counter_metric(category: String, name: String, send_in_pings: StringArray, send_in_pings_len: Int, lifetime: Int, disabled: Byte): Long
fun glean_destroy_counter_metric(handle: Long)
fun glean_counter_add(glean_handle: Long, metric_id: Long, amount: Int)
</code></pre>
<h2><a class="header" href="#kotlin-api" id="kotlin-api">Kotlin API</a></h2>
<p>Finally, create a platform-specific metric type wrapper.
For Kotlin this would be <code>glean-core/android/src/main/java/mozilla/telemetry/glean/private/CounterMetricType.kt</code>:</p>
<pre><code class="language-kotlin">class CounterMetricType(
    private var handle: Long,
    private val disabled: Boolean,
    private val sendInPings: List&lt;String&gt;
) {
    /**
     * The public constructor used by automatically generated metrics.
     */
    constructor(
        disabled: Boolean,
        category: String,
        lifetime: Lifetime,
        name: String,
        sendInPings: List&lt;String&gt;
    ) : this(handle = 0, disabled = disabled, sendInPings = sendInPings) {
        val ffiPingsList = StringArray(sendInPings.toTypedArray(), &quot;utf-8&quot;)
        this.handle = LibGleanFFI.INSTANCE.glean_new_counter_metric(
                category = category,
                name = name,
                send_in_pings = ffiPingsList,
                send_in_pings_len = sendInPings.size,
                lifetime = lifetime.ordinal,
                disabled = disabled.toByte())
    }

    fun add(amount: Int = 1) {
        if (disabled) {
            return
        }

        @Suppress(&quot;EXPERIMENTAL_API_USAGE&quot;)
        Dispatchers.API.launch {
            LibGleanFFI.INSTANCE.glean_counter_add(
                Glean.handle,
                this@CounterMetricType.handle,
                amount)
        }
    }

    @VisibleForTesting(otherwise = VisibleForTesting.NONE)
    fun testHasValue(pingName: String = sendInPings.first()): Boolean {
        @Suppress(&quot;EXPERIMENTAL_API_USAGE&quot;)
        Dispatchers.API.assertInTestingMode()

        val res = LibGleanFFI.INSTANCE.glean_counter_test_has_value(Glean.handle, this.handle, pingName)
        return res.toBoolean()
    }
}
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/new-metric-type/kotlin.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#adding-a-new-metric-type---swift" id="adding-a-new-metric-type---swift">Adding a new metric type - Swift</a></h1>
<h2><a class="header" href="#ffi-1" id="ffi-1">FFI</a></h2>
<p>Swift can re-use the generated C header file.
Re-generate it with</p>
<pre><code class="language-sh">make cbindgen
</code></pre>
<h2><a class="header" href="#swift-api" id="swift-api">Swift API</a></h2>
<p>Finally, create a platform-specific metric type wrapper.
For Swift this would be <code>glean-core/ios/Glean/Metrics/CounterMetric.swift</code>:</p>
<pre><code class="language-swift">public class CounterMetricType {
    let handle: UInt64
    let disabled: Bool
    let sendInPings: [String]

    /// The public constructor used by automatically generated metrics.
    public init(category: String, name: String, sendInPings: [String], lifetime: Lifetime, disabled: Bool) {
        self.disabled = disabled
        self.sendInPings = sendInPings
        self.handle = withArrayOfCStrings(sendInPings) { pingArray in
            glean_new_counter_metric(
                category,
                name,
                pingArray,
                Int32(sendInPings.count),
                lifetime.rawValue,
                disabled.toByte()
            )
        }
    }

    public func add(amount: Int32 = 1) {
        guard !self.disabled else { return }

        _ = Dispatchers.shared.launch {
            glean_counter_add(Glean.shared.handle, self.handle, amount)
        }
    }

    func testHasValue(_ pingName: String? = nil) -&gt; Bool {
        let pingName = pingName ?? self.sendInPings[0]
        return glean_counter_test_has_value(Glean.shared.handle, self.handle, pingName) != 0
    }

    func testGetValue(_ pingName: String? = nil) throws -&gt; Int32 {
        let pingName = pingName ?? self.sendInPings[0]

        if !testHasValue(pingName) {
            throw &quot;Missing value&quot;
        }

        return glean_counter_test_get_value(Glean.shared.handle, self.handle, pingName)
    }
}
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/new-metric-type/swift.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#adding-a-new-metric-type---python" id="adding-a-new-metric-type---python">Adding a new metric type - Python</a></h1>
<h2><a class="header" href="#ffi-2" id="ffi-2">FFI</a></h2>
<p>Python can use the generated C header file directly, through <a href="https://cffi.readthedocs.io/"><code>cffi</code></a>.
Re-generate it with</p>
<pre><code class="language-sh">make cbindgen
</code></pre>
<h2><a class="header" href="#python-api" id="python-api">Python API</a></h2>
<p>Finally, create a platform-specific metric type wrapper.
For Python this would be <code>glean-core/python/glean/metrics/counter.py</code>:</p>
<pre><code class="language-python">class CounterMetricType:
    &quot;&quot;&quot;
    This implements the developer facing API for recording counter metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The counter API only exposes the `CounterMetricType.add` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &quot;&quot;&quot;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_counter_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
        )

    def __del__(self):
        if getattr(self, &quot;_handle&quot;, 0) != 0:
            _ffi.lib.glean_destroy_counter_metric(self._handle)

    def add(self, amount: int = 1):
        &quot;&quot;&quot;
        Add to counter value.

        Args:
            amount (int): (default: 1) This is the amount to increment the
                counter by.
        &quot;&quot;&quot;
        if self._disabled:
            return

        @Dispatcher.launch
        def add():
            _ffi.lib.glean_counter_add(self._handle, amount)

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &quot;&quot;&quot;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &quot;&quot;&quot;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_counter_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; int:
        &quot;&quot;&quot;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (int): value of the stored metric.
        &quot;&quot;&quot;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&quot;metric has no value&quot;)

        return _ffi.lib.glean_counter_test_get_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &quot;&quot;&quot;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &quot;&quot;&quot;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_counter_test_get_num_recorded_errors(
            self._handle, error_type.value, _ffi.ffi_encode_string(ping_name),
        )
</code></pre>
<p>The new metric type also needs to be imported from <code>glean-core/python/glean/metrics/__init__.py</code>:</p>
<pre><code class="language-python">from .counter import CounterMetricType


__all__ = [
    &quot;CounterMetricType&quot;,
    # ...
]
</code></pre>
<p>It also must be added to the <code>_TYPE_MAPPING</code> in <code>glean-core/python/glean/_loader.py</code>:</p>
<pre><code class="language-python">_TYPE_MAPPING = {
    &quot;counter&quot;: metrics.CounterMetricType,
    # ...
}
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/new-metric-type/python.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#ffi-layer" id="ffi-layer">FFI layer</a></h1>
<p>The core part of the Glean SDK provides an FFI layer for its API.
This FFI layer can be consumed by platform-specific bindings, such as the <a href="dev/ffi/../android/index.html">Kotlin bindings for Android</a>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/ffi/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#when-to-use-what-method-of-passing-data-between-rust-and-javaswift" id="when-to-use-what-method-of-passing-data-between-rust-and-javaswift">When to use what method of passing data between Rust and Java/Swift</a></h1>
<p>There are a bunch of options here. For the purposes of our discussion,
there are two kinds of values you may want to pass over the FFI.</p>
<ol>
<li>Types with identity (includes stateful types, resource types, or anything that
isn't really serializable).</li>
<li>Plain ol' data.</li>
</ol>
<h2><a class="header" href="#types-with-identity" id="types-with-identity">Types with identity</a></h2>
<p>Examples of this are all metric type implementations, e.g. <code>StringMetric</code>.
These types are complex, implemented in Rust and make use of the global Glean singleton on the Rust side,
They have an equivalent on the wrapper side (Kotlin/Swift/Python), that forwards calls through FFI.</p>
<p>They all follow the same pattern:</p>
<p>A <code>ConcurrentHandleMap</code> stores all instances of the same type,
A handle is passed back and forth as a <code>u64</code> from Rust, <code>Long</code> from Kotlin, <code>UInt64</code> from Swift
or other equivalent type in other languages.</p>
<p>This is recommended for most cases, as it's the hardest to mess up.
Additionally, for types T such that <code>&amp;T: Sync + Send</code>, or that you
need to call <code>&amp;mut self</code> method, this is the safest choice.</p>
<p>Additionally, this will ensure panic-safety, as it will poison the internal Mutex, making further access impossible.</p>
<p>The <a href="https://docs.rs/ffi-support/*/ffi_support/handle_map/index.html"><code>ffi_support::handle_map</code> docs</a> are good,
and under <code>ConcurrentHandleMap</code> include an example of how to set this up.</p>
<h2><a class="header" href="#plain-old-data" id="plain-old-data">Plain Old Data</a></h2>
<p>This includes both primitive values, strings, arrays, or arbitrarily nested
structures containing them.</p>
<h3><a class="header" href="#primitives" id="primitives">Primitives</a></h3>
<p>Numeric primitives are the easiest to pass between languages.
The main recommendation is: use the equivalent and same-sized type as the one provided by Rust.</p>
<p>There are a couple of exceptions/caveats, especially for Kotlin. All of them are caused by JNA/Android issues.
Swift has very good support for calling over the FFI.</p>
<ol>
<li>
<p><code>bool</code>: Don't use it. JNA doesn't handle it well. Instead, use a numeric type
(like <code>u8</code>) and represent 0 for <code>false</code> and 1 for <code>true</code> for interchange over the
FFI, converting back to Kotlin's <code>Boolean</code> or Swift's <code>Bool</code> after (as to
not expose this somewhat annoying limitation in our public API).
All wrappers already include utility functions to turn 8-bit integers (<code>u8</code>) back to booleans
(<code>toBool()</code> or equivalent methods).</p>
</li>
<li>
<p><code>usize</code>/<code>isize</code>: These cause the structure size to be different based on the
platform. JNA does handle this if you use <code>NativeSize</code>, but it's awkward.
Use the size-defined integers instead, such as <code>i64</code>/<code>i32</code> and their language-equivalents
(Kotlin: <code>Long</code>/<code>Int</code>, Swift:<code>UInt64</code>/<code>UInt32</code>).
<em>Caution:</em> In Kotlin integers are signed by default. You can use <code>u64</code>/<code>u32</code> for <code>Long</code>/<code>Int</code> if you ensure the values are non-negative through asserts or error reporting code.</p>
</li>
<li>
<p><code>char</code>: Avoid these if possible. If you really have a use case consider <code>u32</code> instead.</p>
<p>If you do this, you should probably be aware of the fact that Java chars are 16
bit, and Swift <code>Character</code>s are actually strings (they represent Extended
Grapheme Clusters, not codepoints).</p>
</li>
</ol>
<h3><a class="header" href="#strings-1" id="strings-1">Strings</a></h3>
<p>These we pass as null-terminated UTF-8 C-strings.</p>
<p>For return values, used <code>*mut c_char</code>, and for input, use
<a href="https://docs.rs/ffi-support/*/ffi_support/struct.FfiStr.html"><code>ffi_support::FfiStr</code></a></p>
<ol>
<li>
<p>If the string is returned from Rust to Kotlin/Swift, you need to expose a
string destructor from your ffi crate. See
<a href="https://docs.rs/ffi-support/*/ffi_support/macro.define_string_destructor.html"><code>ffi_support::define_string_destructor!</code></a>).</p>
<p>For converting to a <code>*mut c_char</code>, use either
<a href="https://docs.rs/ffi-support/*/ffi_support/fn.rust_string_to_c.html"><code>rust_string_to_c</code></a>
if you have a <code>String</code>, or
<a href="https://docs.rs/ffi-support/*/ffi_support/fn.opt_rust_string_to_c.html"><code>opt_rust_string_to_c</code></a>
for <code>Option&lt;String&gt;</code> (None becomes <code>std::ptr::null_mut()</code>).</p>
<p><strong>Important</strong>: In Kotlin, the type returned by a function that produces this
must be <code>Pointer</code>, and not <code>String</code>, and the parameter that the destructor takes
as input must also be <code>Pointer</code>.</p>
<p>Using <code>String</code> will <em>almost</em> work. JNA will convert the return value to
<code>String</code> automatically, leaking the value Rust provides. Then, when passing
to the destructor, it will allocate a temporary buffer, pass it to Rust, which
we'll free, corrupting both heaps . Oops!</p>
</li>
<li>
<p>If the string is passed into Rust from Kotlin/Swift, the Rust code should
declare the parameter as a <a href="https://docs.rs/ffi-support/*/ffi_support/struct.FfiStr.html"><code>FfiStr&lt;'_&gt;</code></a>.
and things should then work more or less automatically. The <code>FfiStr</code> has methods
for extracting it's data as <code>&amp;str</code>, <code>Option&lt;&amp;str&gt;</code>, <code>String</code>, and <code>Option&lt;String&gt;</code>.</p>
</li>
</ol>
<h3><a class="header" href="#aggregates" id="aggregates">Aggregates</a></h3>
<p>This is any type that's more complex than a primitive or a string (arrays,
structures, and combinations there-in).
There are two options we recommend for these cases:</p>
<ol>
<li>
<p>Passing data as JSON. This is very easy and useful for prototyping, but is
much slower and requires a great deal of copying and redundant encode/decode
steps (in general, the data will be copied at least 4 times to make this
work, and almost certainly more in practice).
It can be done relatively easily by <code>derive(Serialize, Deserialize)</code>,
and converting to a JSON string using <code>serde_json::to_string</code>.</p>
<p>This is a viable option for test-only functions, where the overhead is not important.</p>
</li>
<li>
<p>Use <code>repr(C)</code> structures and copy the data across the boundary,
carefully replicating the same structure on the wrapper side.
In Kotlin this will require <code>@Structure.FieldOrder</code> annotations.
Swift can directly handle C types.</p>
<p><strong>Caution:</strong> This is error prone! Structures, enumerations and unions need to be kept the same across all layers
(Rust, generated C header, Kotlin, Swift, ...).
Be extra careful, avoid adding references to structures and ensure the structures are correctly freed inside Rust.
Copy out the data and convert into language-appropriate types (e.g. convert <code>*mut c_char</code> into Swift/Kotlin strings) as soon as possible.</p>
</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/ffi/when-to-use-what-in-the-ffi.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#contributing-to-the-glean-sdk" id="contributing-to-the-glean-sdk">Contributing to the Glean SDK</a></h1>
<p>Anyone is welcome to help with the Glean SDK project. Feel free to get in touch with other community members on <code>chat.mozilla.org</code> 
or through issues on GitHub or Bugzilla.</p>
<ul>
<li>Matrix: <a href="https://chat.mozilla.org/#/room/#glean:mozilla.org">#glean channel on chat.mozilla.org</a></li>
<li><a href="https://bugzilla.mozilla.org/buglist.cgi?list_id=14844212&amp;resolution=---&amp;classification=Client%20Software&amp;classification=Developer%20Infrastructure&amp;classification=Components&amp;classification=Server%20Software&amp;classification=Other&amp;query_format=advanced&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;component=Glean%3A%20SDK&amp;product=Data%20Platform%20and%20Tools">the Bugzilla issues list</a></li>
<li><a href="https://github.com/mozilla/glean/issues">the GitHub issues list</a></li>
</ul>
<p>Participation in this project is governed by the
<a href="https://www.mozilla.org/en-US/about/governance/policies/participation/">Mozilla Community Participation Guidelines</a>.</p>
<h2><a class="header" href="#bug-reports" id="bug-reports">Bug Reports</a></h2>
<p>To report issues or request changes, file a bug in <a href="https://bugzilla.mozilla.org/enter_bug.cgi?assigned_to=nobody%40mozilla.org&amp;bug_ignored=0&amp;bug_severity=normal&amp;bug_status=NEW&amp;cf_fission_milestone=---&amp;cf_fx_iteration=---&amp;cf_fx_points=---&amp;cf_status_firefox65=---&amp;cf_status_firefox66=---&amp;cf_status_firefox67=---&amp;cf_status_firefox_esr60=---&amp;cf_status_thunderbird_esr60=---&amp;cf_tracking_firefox65=---&amp;cf_tracking_firefox66=---&amp;cf_tracking_firefox67=---&amp;cf_tracking_firefox_esr60=---&amp;cf_tracking_firefox_relnote=---&amp;cf_tracking_thunderbird_esr60=---&amp;product=Data%20Platform%20and%20Tools&amp;component=Glean%3A%20SDK&amp;contenttypemethod=list&amp;contenttypeselection=text%2Fplain&amp;defined_groups=1&amp;flag_type-203=X&amp;flag_type-37=X&amp;flag_type-41=X&amp;flag_type-607=X&amp;flag_type-721=X&amp;flag_type-737=X&amp;flag_type-787=X&amp;flag_type-799=X&amp;flag_type-800=X&amp;flag_type-803=X&amp;flag_type-835=X&amp;flag_type-846=X&amp;flag_type-855=X&amp;flag_type-864=X&amp;flag_type-916=X&amp;flag_type-929=X&amp;flag_type-930=X&amp;flag_type-935=X&amp;flag_type-936=X&amp;flag_type-937=X&amp;form_name=enter_bug&amp;maketemplate=Remember%20values%20as%20bookmarkable%20template&amp;op_sys=Unspecified&amp;priority=P3&amp;&amp;rep_platform=Unspecified&amp;status_whiteboard=%5Btelemetry%3Aglean-rs%3Am%3F%5D&amp;target_milestone=---&amp;version=unspecified">Bugzilla in Data Platform &amp; Tools :: Glean: SDK</a>.</p>
<p>If you don't have a Bugzilla account, we also accept <a href="https://github.com/mozilla/glean/issues/new">issues on GitHub</a>.</p>
<h2><a class="header" href="#making-code-changes" id="making-code-changes">Making Code Changes</a></h2>
<p>To work on the code in this repository you will need to be familiar with
the <a href="https://www.rust-lang.org/">Rust</a> programming language.
You can get a working rust compiler and toolchain via <a href="https://rustup.rs/">rustup</a>.</p>
<p>You can check that everything compiles by running the following from the
root of your checkout:</p>
<pre><code>make test-rust
</code></pre>
<p>If you plan to work on the Android component bindings, you should also review
the instructions for <a href="https://github.com/mozilla/glean/blob/master/docs/dev/setup-android-build-environment.md">setting up an Android build environment</a></p>
<p>To run all Kotlin tests:</p>
<pre><code>make test-kotlin
</code></pre>
<p>or run tests in Android Studio.</p>
<p>To run all Swift tests:</p>
<pre><code>make test-swift
</code></pre>
<p>or run tests in Xcode.</p>
<h2><a class="header" href="#sending-pull-requests" id="sending-pull-requests">Sending Pull Requests</a></h2>
<p>Patches should be submitted as <a href="https://help.github.com/articles/about-pull-requests/">pull requests</a> (PRs).</p>
<p>Before submitting a PR:</p>
<ul>
<li>Your code must run and pass all the automated tests before you submit your PR for review.</li>
<li>&quot;Work in progress&quot; pull requests are allowed to be submitted, but should be clearly labeled as such and should not be merged until all tests pass and the code has been reviewed.</li>
<li>For changes to Rust code
<ul>
<li><code>make test-rust</code> produces no test failures</li>
<li><code>make clippy</code> runs without emitting any warnings or errors.</li>
<li><code>make rustfmt</code> does not produce any changes to the code.</li>
</ul>
</li>
<li>For changes to Kotlin code
<ul>
<li><code>make test-kotlin</code> runs without emitting any warnings or errors.</li>
<li><code>make ktlint</code> runs without emitting any warnings.</li>
</ul>
</li>
<li>For changes to Swift code
<ul>
<li><code>make test-swift</code> (or running tests in Xcode) runs without emitting any warnings or errors.</li>
<li><code>make swiftlint</code> runs without emitting any warnings or errors.</li>
<li><code>make swiftfmt</code> runs without emitting any warnings or producing changes.</li>
</ul>
</li>
<li>Your patch should include new tests that cover your changes. It is your and your reviewer's responsibility to ensure your patch includes adequate tests.</li>
</ul>
<p>When submitting a PR:</p>
<ul>
<li>You agree to license your code under the project's open source license (<a href="https://mozilla.org/MPL/2.0/">MPL 2.0</a>).</li>
<li>Base your branch off the current <code>master</code> (see below for an example workflow).</li>
<li>Add both your code and new tests if relevant.</li>
<li>Please do not include merge commits in pull requests; include only commits with the new relevant code.</li>
</ul>
<h2><a class="header" href="#code-review" id="code-review">Code Review</a></h2>
<p>This project is production Mozilla code and subject to our
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Committing_Rules_and_Responsibilities">engineering practices and quality standards</a>.
Every patch must be peer reviewed by a member of the Glean core team.</p>
<p>Reviewers are defined in the <a href="https://github.com/mozilla/glean/blob/master/.github/CODEOWNERS">CODEOWNERS</a> file
and are automatically added for every pull request.
Every pull request needs to be approved by at least one of these people before landing.</p>
<p>The submitter needs to decide on their own discretion whether the changes require a look from more than a single reviewer or any outside developer.
Reviewers can also ask for additional approval from other reviewers.</p>
<h2><a class="header" href="#release" id="release">Release</a></h2>
<p>See the <a href="dev/cut-a-new-release.html">Release process</a> on how to release a new version of the Glean SDK.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/contributing.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#code-coverage" id="code-coverage">Code Coverage</a></h1>
<blockquote>
<p>In computer science, test coverage is a measure used to describe the degree to which the source code of a program is executed when a particular test suite runs.
A program with high test coverage, measured as a percentage, has had more of its source code executed during testing,
which suggests it has a lower chance of containing undetected software bugs compared to a program with low test coverage.
(<a href="https://en.wikipedia.org/wiki/Code_coverage">Wikipedia</a>)</p>
</blockquote>
<h2><a class="header" href="#generating-kotlin-reports-locally" id="generating-kotlin-reports-locally">Generating Kotlin reports locally</a></h2>
<p>Locally you can generate a coverage report with the following command:</p>
<pre><code class="language-bash">./gradlew -Pcoverage :glean:build
</code></pre>
<p>After that you'll find an HTML report at the following location:</p>
<pre><code>glean-core/android/build/reports/jacoco/jacocoTestReport/jacocoTestReport/html/index.html
</code></pre>
<h2><a class="header" href="#generating-rust-reports-locally" id="generating-rust-reports-locally">Generating Rust reports locally</a></h2>
<blockquote>
<p>Generating the Rust coverage report requires a significant amount of RAM during the build.</p>
</blockquote>
<p>We use <a href="https://github.com/mozilla/grcov">grcov</a> to collect and aggregate code coverage information.
Releases can be found on the <a href="https://github.com/mozilla/grcov/releases">grcov Release page</a>.</p>
<p>The build process requires a Rust Nightly version. Install it using <code>rustup</code>:</p>
<pre><code class="language-bash">rustup toolchain add nightly
</code></pre>
<p>To generate an HTML report, <code>genhtml</code> from the <code>lcov</code> package is required. Install it through your system's package manager.</p>
<p>After installation you can build the Rust code and generate a report:</p>
<pre><code class="language-bash">export CARGO_INCREMENTAL=0
export RUSTFLAGS='-Zprofile -Ccodegen-units=1 -Cinline-threshold=0 -Clink-dead-code -Coverflow-checks=off -Zno-landing-pads'
cargo +nightly test

zip -0 ccov.zip `find . \( -name &quot;glean*.gc*&quot; \) -print`
grcov ccov.zip -s . -t lcov --llvm --branch --ignore-not-existing --ignore-dir &quot;/*&quot; -o lcov.info
genhtml -o report/ --show-details --highlight --ignore-errors source --legend lcov.info
</code></pre>
<p>After that you'll find an HTML report at the following location:</p>
<pre><code>report/index.html
</code></pre>
<h2><a class="header" href="#generating-swift-reports-locally" id="generating-swift-reports-locally">Generating Swift reports locally</a></h2>
<p>Xcode automatically generates code coverage when running tests.
You can find the report in the Report Navigator (<code>View -&gt; Navigators -&gt; Show Report Navigator -&gt; Coverage</code>).</p>
<h2><a class="header" href="#generating-python-reports-locally" id="generating-python-reports-locally">Generating Python reports locally</a></h2>
<p>Python code coverage is determined using the <a href="https://coverage.readthedocs.io/en/latest/">coverage.py</a> library.</p>
<p>Run</p>
<pre><code class="language-bash">make python-coverage
</code></pre>
<p>to generate code coverage reports in the Glean virtual environment.</p>
<p>After running, the report will be in <code>htmlcov</code>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/code_coverage.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#glean-release-process" id="glean-release-process">Glean release process</a></h1>
<p>The Glean SDK consists of multiple libraries for different platforms and targets.
The main supported libraries are released as one.
Development happens on the main repository <a href="https://github.com/mozilla/glean">https://github.com/mozilla/glean</a>.
See <a href="dev/../contributing.html">Contributing</a> for how to contribute changes to the Glean SDK.</p>
<p>The development &amp; release process roughly follows the <a href="https://nvie.com/posts/a-successful-git-branching-model/">GitFlow model</a>.</p>
<blockquote>
<p><strong>Note:</strong> The rest of this section assumes that <code>upstream</code> points to the <code>https://github.com/mozilla/glean</code> repository,
while <code>origin</code> points to the developer fork.
For some developer workflows, <code>upstream</code> can be the same as <code>origin</code>.</p>
</blockquote>
<p><strong>Table of Contents</strong>:</p>
<ul>
<li><a href="dev/cut-a-new-release.html#published-artifacts">Published artifacts</a></li>
<li><a href="dev/cut-a-new-release.html#standard-release">Standard release</a></li>
<li><a href="dev/cut-a-new-release.html#hotfix-release-for-latest-version">Hotfix release for latest version</a></li>
<li><a href="dev/cut-a-new-release.html#hotfix-release-for-previous-version">Hotfix release for previous version</a></li>
<li><a href="dev/cut-a-new-release.html#upgrading-android-components-to-a-new-version-of-glean">Upgrading android-components to a new version of Glean</a></li>
</ul>
<h2><a class="header" href="#published-artifacts" id="published-artifacts">Published artifacts</a></h2>
<ul>
<li>The Kotlin libraries are published to <a href="https://github.com/mozilla/glean/releases">GitHub Releases</a> and <a href="https://maven.mozilla.org/?prefix=maven2/org/mozilla/telemetry/">Mozilla Maven</a>.</li>
<li>Python bindings are published on PyPI: <a href="https://pypi.org/project/glean-sdk/">glean-sdk</a>.</li>
<li>iOS framework artifacts: <a href="https://github.com/mozilla/glean/releases">GitHub Releases</a>.</li>
<li>Rust crates are published on crates.io: <a href="https://crates.io/crates/glean-core">glean-core</a>, <a href="https://crates.io/crates/glean-ffi">glean-ffi</a>.</li>
</ul>
<h2><a class="header" href="#standard-release" id="standard-release">Standard Release</a></h2>
<p>Releases can only be done by one of the Glean maintainers.</p>
<ul>
<li>Main development branch: <code>master</code></li>
<li>Main release branch: <code>release</code></li>
<li>Specific release branch: <code>release-vX.Y.Z</code></li>
<li>Hotfix branch: <code>hotfix-X.Y.(Z+1)</code></li>
</ul>
<h3><a class="header" href="#create-a-release-branch" id="create-a-release-branch">Create a release branch</a></h3>
<ol>
<li>
<p>Create a release branch from the <code>master</code> branch:````
git checkout -b release-v25.0.0 master````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Update the changelog .</p>
<ol>
<li>Add any missing important changes under the <code>Unreleased changes</code> headline.</li>
<li>Commit any changes to the changelog file due to the previous step.</li>
</ol>
</li>
<li>
<p>Run <code>bin/prepare-release.sh &lt;new version&gt;</code> to bump the version number.</p>
<ol>
<li>The new version should be the next patch, minor or major version of what is currently released.</li>
<li>Let it create a commit for you.</li>
</ol>
</li>
<li>
<p>Push the new release branch:````
git push upstream release-v25.0.0````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Wait for CI to finish on that branch and ensure it's green: <a href="https://circleci.com/gh/mozilla/glean/tree/release-v25.0.0">https://circleci.com/gh/mozilla/glean/tree/release-v25.0.0</a></p>
</li>
<li>
<p>Apply additional commits for bug fixes to this branch.</p>
<ul>
<li>Adding large new features here is strictly prohibited. They need to go to the <code>master</code> branch and wait for the next release.</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#finish-a-release-branch" id="finish-a-release-branch">Finish a release branch</a></h3>
<p>When CI has finished and is green for your specific release branch, you are ready to cut a release.</p>
<ol>
<li>
<p>Check out the main release branch:````
git checkout release````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Merge the specific release branch:````
git merge --no-ff release-v25.0.0````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Push the main release branch:````
git push upstream release````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Tag the release on GitHub:</p>
<ol>
<li><a href="https://github.com/mozilla/glean/releases/new">Draft a New Release</a> in the GitHub UI (<code>Releases &gt; Draft a New Release</code>).</li>
<li>Enter <code>v&lt;myversion&gt;</code> as the tag. It's important this is the same as the version you specified to the <code>prepare_release.sh</code> script, with the <code>v</code> prefix added.</li>
<li>Select the <code>release</code> branch as the target.</li>
<li>Under the description, paste the contents of the release notes from <code>CHANGELOG.md</code>.</li>
</ol>
</li>
<li>
<p>Wait for the CI build to complete for the tag.</p>
<ul>
<li>You can check <a href="https://circleci.com/gh/mozilla/glean">on CircleCI for the running build</a>.</li>
</ul>
</li>
<li>
<p>Release the Rust crates:````
cd glean-core
cargo publish --verbose
cd ffi
cargo publish --verbose````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Send a pull request to merge back the specific release branch to the development branch: <a href="https://github.com/mozilla/glean/compare/master...release-v25.0.0?expand=1">https://github.com/mozilla/glean/compare/master...release-v25.0.0?expand=1</a></p>
<ul>
<li>This is important so that no changes are lost.</li>
<li>This might have merge conflicts with the <code>master</code> branch, which you need to fix before it is merged.</li>
</ul>
</li>
<li>
<p>Once the above pull request lands, delete the specific release branch.</p>
</li>
</ol>
<h2><a class="header" href="#hotfix-release-for-latest-version" id="hotfix-release-for-latest-version">Hotfix release for latest version</a></h2>
<p>If the latest released version requires a bug fix, a hotfix branch is used.</p>
<h3><a class="header" href="#create-a-hotfix-branch" id="create-a-hotfix-branch">Create a hotfix branch</a></h3>
<ol>
<li>
<p>Create a hotfix branch from the main release branch:````
git checkout -b hotfix-v25.0.1 release````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Run <code>bin/prepare-release.sh &lt;new version&gt;</code> to bump the version number.</p>
<ol>
<li>The new version should be the next patch version of what is currently released.</li>
<li>Let it create a commit for you.</li>
</ol>
</li>
<li>
<p>Push the hotfix branch:````
git push upstream hotfix-v25.0.1````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Create a local hotfix branch for bugfixes:````
git checkout -b bugfix hotfix-v25.0.1````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Fix the bug and commit the fix in one or more separate commits.</p>
</li>
<li>
<p>Push your bug fixes and create a pull request against the hotfix branch: <a href="https://github.com/mozilla/glean/compare/hotfix-v25.0.1...your-name:bugfix?expand=1">https://github.com/mozilla/glean/compare/hotfix-v25.0.1...your-name:bugfix?expand=1</a></p>
</li>
<li>
<p>When that pull request lands, wait for CI to finish on that branch and ensure it's green: <a href="https://circleci.com/gh/mozilla/glean/tree/hotfix-v25.0.1">https://circleci.com/gh/mozilla/glean/tree/hotfix-v25.0.1</a></p>
</li>
</ol>
<h3><a class="header" href="#finish-a-hotfix-branch" id="finish-a-hotfix-branch">Finish a hotfix branch</a></h3>
<p>When CI has finished and is green for your hotfix branch, you are ready to cut a release, similar to a normal release:</p>
<ol>
<li>
<p>Check out the main release branch:````
git checkout release````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Merge the hotfix branch:````
git merge --no-ff hotfix-v25.0.1````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Push the main release branch:````
git push upstream release````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Tag the release on GitHub:</p>
<ol>
<li><a href="https://github.com/mozilla/glean/releases/new">Draft a New Release</a> in the GitHub UI (<code>Releases &gt; Draft a New Release</code>).</li>
<li>Enter <code>v&lt;myversion&gt;</code> as the tag. It's important this is the same as the version you specified to the <code>prepare_release.sh</code> script, with the <code>v</code> prefix added.</li>
<li>Select the <code>release</code> branch as the target.</li>
<li>Under the description, paste the contents of the release notes from <code>CHANGELOG.md</code>.</li>
</ol>
</li>
<li>
<p>Wait for the CI build to complete for the tag.</p>
<ul>
<li>You can check <a href="https://circleci.com/gh/mozilla/glean">on CircleCI for the running build</a>.</li>
</ul>
</li>
<li>
<p>Release the Rust crates:````
cd glean-core
cargo publish --verbose
cd ffi
cargo publish --verbose````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Send a pull request to merge back the hotfix branch to the development branch: <a href="https://github.com/mozilla/glean/compare/master...hotfix-v25.0.1?expand=1">https://github.com/mozilla/glean/compare/master...hotfix-v25.0.1?expand=1</a></p>
<ul>
<li>This is important so that no changes are lost.</li>
<li>This might have merge conflicts with the <code>master</code> branch, which you need to fix before it is merged.</li>
</ul>
</li>
<li>
<p>Once the above pull request lands, delete the hotfix branch.</p>
</li>
</ol>
<h2><a class="header" href="#hotfix-release-for-previous-version" id="hotfix-release-for-previous-version">Hotfix release for previous version</a></h2>
<p>If you need to release a hotfix for a previously released version (that is: not the latest released version), you need a support branch.</p>
<blockquote>
<p><strong>Note</strong>: This should rarely happen. We generally support only the latest released version of Glean.</p>
</blockquote>
<h3><a class="header" href="#create-a-support-and-hotfix-branch" id="create-a-support-and-hotfix-branch">Create a support and hotfix branch</a></h3>
<ol>
<li>
<p>Create a support branch from the version tag and push it:````
git checkout -b support/v24.0 v24.0.0
git push upstream support/v24.0````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Create a hotfix branch for this support branch:````
git checkout -b hotfix-v24.0.1 support/v24.0````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Fix the bug and commit the fix in one or more separate commits into your hotfix branch.</p>
</li>
<li>
<p>Push your bug fixes and create a pull request against the support branch: <a href="https://github.com/mozilla/glean/compare/support/v24.0...your-name:hotfix-v24.0.1?expand=1">https://github.com/mozilla/glean/compare/support/v24.0...your-name:hotfix-v24.0.1?expand=1</a></p>
</li>
<li>
<p>When that pull request lands, wait for CI to finish on that branch and ensure it's green: <a href="https://circleci.com/gh/mozilla/glean/tree/support/v24.0">https://circleci.com/gh/mozilla/glean/tree/support/v24.0</a></p>
</li>
</ol>
<h3><a class="header" href="#finish-a-support-branch" id="finish-a-support-branch">Finish a support branch</a></h3>
<ol>
<li>
<p>Check out the support branch:````
git checkout support/v24.0````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Update the changelog .</p>
<ol>
<li>Add any missing important changes under the <code>Unreleased changes</code> headline.</li>
<li>Commit any changes to the changelog file due to the previous step.</li>
</ol>
</li>
<li>
<p>Run <code>bin/prepare-release.sh &lt;new version&gt;</code> to bump the version number.</p>
<ol>
<li>The new version should be the next patch version of the support branch.</li>
<li>Let it create a commit for you.</li>
</ol>
</li>
<li>
<p>Push the support branch:````
git push upstream support/v24.0````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Tag the release on GitHub:</p>
<ol>
<li><a href="https://github.com/mozilla/glean/releases/new">Draft a New Release</a> in the GitHub UI (<code>Releases &gt; Draft a New Release</code>).</li>
<li>Enter <code>v&lt;myversion&gt;</code> as the tag. It's important this is the same as the version you specified to the <code>prepare_release.sh</code> script, with the <code>v</code> prefix added.</li>
<li>Select the support branch (e.g. <code>support/v24.0</code>) as the target.</li>
<li>Under the description, paste the contents of the release notes from <code>CHANGELOG.md</code>.</li>
</ol>
</li>
<li>
<p>Wait for the CI build to complete for the tag.</p>
<ul>
<li>You can check <a href="https://circleci.com/gh/mozilla/glean">on CircleCI for the running build</a>.</li>
</ul>
</li>
<li>
<p>Release the Rust crates:````
cd glean-core
cargo publish --verbose
cd ffi
cargo publish --verbose````</p>
<pre><code>
</code></pre>
</li>
<li>
<p>Send a pull request to merge back any bug fixes to the development branch: <a href="https://github.com/mozilla/glean/compare/master...support/v24.0?expand=1">https://github.com/mozilla/glean/compare/master...support/v24.0?expand=1</a></p>
<ul>
<li>This is important so that no changes are lost.</li>
<li>This might have merge conflicts with the <code>master</code> branch, which you need to fix before it is merged.</li>
</ul>
</li>
<li>
<p>Once the above pull request lands, delete the support branch.</p>
</li>
</ol>
<h2><a class="header" href="#upgrading-android-components-to-a-new-version-of-glean" id="upgrading-android-components-to-a-new-version-of-glean">Upgrading android-components to a new version of Glean</a></h2>
<p>On Android, Mozilla products consume the Glean SDK through its wrapper in <a href="https://github.com/mozilla-mobile/android-components"><code>android-components</code></a>.
Therefore, when a new Glean SDK release is made, <code>android-components</code> must also be updated.</p>
<p>After following one of the above instructions to make a Glean SDK release:</p>
<ol>
<li>
<p>Ensure that CI has completed and the artifacts have published to <a href="https://github.com/mozilla/glean/releases/">the Glean GitHub releases page</a>.</p>
</li>
<li>
<p>Publish Glean to <a href="https://maven.mozilla.org/">Mozilla's Maven repository</a>.
This is currently a manual step that can only performed by individuals with the necessary credentials.
Ask in <code>#releaseduty-mobile</code> on Mozilla's internal Slack for assistance.</p>
</li>
<li>
<p>Create a pull request against <code>android-components</code> to update the Glean version with the following changes:</p>
<ul>
<li>
<p>The Glean version is updated in the <code>mozilla_glean</code> variable in the <a href="https://github.com/mozilla-mobile/android-components/blob/69546999739ab19d21425e9a98e107e438a3f905/buildSrc/src/main/java/Dependencies.kt#L32"><code>buildSrc/src/main/java/Dependencies.kt</code></a> file.</p>
</li>
<li>
<p>The relevant parts of the Glean changelog copied into the top part of the <a href="https://github.com/mozilla-mobile/android-components/blob/master/docs/changelog.md"><code>android-components</code> changelog</a>.
This involves copying the Android-specific changes and the general changes to Glean, but can omit other platform-specific changes.</p>
</li>
</ul>
</li>
</ol>
<p><strong>IMPORTANT:</strong> Until the <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1592947">Glean Gradle plugin work is complete</a>, all downstream consumers of android-components will also need to update their version of Glean to match the version used in android-components so that their unit tests can run correctly.</p>
<p>In Fenix, for example, the <a href="https://github.com/mozilla-mobile/fenix/blob/5e4ef202b85e273cf46ec5c7ec1b80f30ca4e77c/buildSrc/src/main/java/Dependencies.kt#L44">Glean version is specified here</a>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/cut-a-new-release.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#internal-documentation" id="internal-documentation">Internal documentation</a></h1>
<p>This chapter describes aspects of Glean that are internal implementation details.</p>
<p>This includes:</p>
<ul>
<li><a href="dev/core/internal/reserved-ping-names.html">Reserved ping names</a></li>
<li><a href="dev/core/internal/clearing.html">Clearing metrics when disabling/enabling Glean</a></li>
<li><a href="dev/core/internal/payload.html">Payload format</a></li>
<li><a href="dev/core/internal/directory-structure.html">Directory structure</a></li>
<li><a href="dev/core/internal/debug-pings.html">Debug Pings</a></li>
<li><a href="dev/core/internal/implementations.html">Implementations</a></li>
<li><a href="dev/core/internal/sdk-ndk-versions.html">Android SDK/NDK versions</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/internal/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#reserved-ping-names" id="reserved-ping-names">Reserved ping names</a></h1>
<p>The Glean SDK reserves all ping names in <code>send_in_pings</code> starting with <code>glean_</code>.</p>
<p>This currently includes, but is not limited to:</p>
<ul>
<li><code>glean_client_info</code></li>
<li><code>glean_internal_info</code></li>
</ul>
<p>Additionally, only Glean may specify <code>all-pings</code>.  This special value has no effect in the client, but indicates to the backend infrastructure that a metric may appear in any ping.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/internal/reserved-ping-names.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#clearing-metrics-when-disablingenabling-glean" id="clearing-metrics-when-disablingenabling-glean">Clearing metrics when disabling/enabling Glean</a></h1>
<p>When disabling upload (<code>Glean.setUploadEnabled(false)</code>), metrics are also cleared to prevent their storage on the local device, and lessen the likelihood
of accidentally sending them.
There are a couple of exceptions to this:</p>
<ul>
<li>
<p><code>first_run_date</code> is retained so it isn't reset if metrics are later re-enabled.</p>
</li>
<li>
<p><code>client_id</code> is set to the special value <code>&quot;c0ffeec0-ffee-c0ff-eec0-ffeec0ffeec0&quot;</code>. This should make it possible to detect the error case when metrics are sent from a client that has been disabled.</p>
</li>
</ul>
<p>When re-enabling metrics:</p>
<ul>
<li>
<p><code>first_run_date</code> is left as-is. (It should remain a correct date of first run of the application, unaffected by disabling/enabling the Glean SDK).</p>
</li>
<li>
<p>The <code>client_id</code> is set to a newly-generated random UUID. It has no connection to the <code>client_id</code> used prior to disabling the Glean SDK.</p>
</li>
<li>
<p>Application lifetime metrics owned by Glean are regenerated from scratch so that they will appear in subsequent pings. This is the same process that happens during every startup of the application when the Glean SDK is enabled. The application is also responsible for setting any application lifetime metrics that it manages at this time.</p>
</li>
<li>
<p>Ping lifetime metrics do not need special handling.  They will begin recording again after metric uploading is re-enabled.</p>
</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/internal/clearing.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#payload-format" id="payload-format">Payload format</a></h1>
<p>The main sections of a Glean ping are described in <a href="dev/core/internal/../../../user/pings/index.html#Ping-sections">Ping Sections</a>.
This <strong>Payload format</strong> chapter describes details of the ping payload that are relevant for decoding Glean pings in the pipeline.
This is less relevant for end users of the Glean SDK.</p>
<h2><a class="header" href="#json-schema" id="json-schema">JSON Schema</a></h2>
<p>Glean's ping payloads have a formal JSON schema defined in the <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas/">mozilla-pipeline-schemas</a> project.
It is written as a set of <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas/tree/master/templates/include/glean">templates</a> that are expanded by the mozilla-pipeline-schemas build infrastructure into a <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas/blob/master/schemas/glean/baseline/baseline.1.schema.json">fully expanded schema</a>.</p>
<h2><a class="header" href="#metric-types" id="metric-types">Metric types</a></h2>
<h3><a class="header" href="#boolean-1" id="boolean-1">Boolean</a></h3>
<p>A <a href="dev/core/internal/../../../user/metrics/boolean.html">Boolean</a> is represented by its boolean value.</p>
<h4><a class="header" href="#example" id="example">Example</a></h4>
<pre><code class="language-json">true
</code></pre>
<h3><a class="header" href="#counter-1" id="counter-1">Counter</a></h3>
<p>A <a href="dev/core/internal/../../../user/metrics/counter.html">Counter</a> is represented by its integer value.</p>
<h4><a class="header" href="#example-1" id="example-1">Example</a></h4>
<pre><code class="language-json">17
</code></pre>
<h3><a class="header" href="#quantity-1" id="quantity-1">Quantity</a></h3>
<p>A <a href="dev/core/internal/../../../user/metrics/quantity.html">Quantity</a> is represented by its integer value.</p>
<h4><a class="header" href="#example-2" id="example-2">Example</a></h4>
<pre><code class="language-json">42
</code></pre>
<h3><a class="header" href="#string" id="string">String</a></h3>
<p>A <a href="dev/core/internal/../../../user/metrics/string.html">String</a> is represented by its string value.</p>
<h4><a class="header" href="#example-3" id="example-3">Example</a></h4>
<pre><code class="language-json">&quot;sample string&quot;
</code></pre>
<h3><a class="header" href="#string-list-1" id="string-list-1">String list</a></h3>
<p>A <a href="dev/core/internal/../../../user/metrics/string_list.html">String List</a> is represented as an array of strings.</p>
<pre><code class="language-json">[&quot;sample string&quot;, &quot;another one&quot;]
</code></pre>
<h3><a class="header" href="#timespan-1" id="timespan-1">Timespan</a></h3>
<p>A <a href="dev/core/internal/../../../user/metrics/timespan.html">Timespan</a> is represented as an object of their duration as an integer and the time unit.</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>value</code></td><td>Integer</td><td>The value in the marked time unit.</td></tr>
<tr><td><code>time_unit</code></td><td>String</td><td>The time unit, see the <a href="dev/core/internal/../../../user/metrics/timespan.html#configuration">timespan's configuration</a> for valid values.</td></tr>
</tbody></table>
<h4><a class="header" href="#example-4" id="example-4">Example</a></h4>
<pre><code class="language-json">{
    &quot;time_unit&quot;: &quot;milliseconds&quot;,
    &quot;value&quot;: 10
}
</code></pre>
<h3><a class="header" href="#timing-distribution-1" id="timing-distribution-1">Timing Distribution</a></h3>
<p>A <a href="dev/core/internal/../../../user/metrics/timing_distribution.html">Timing distribution</a> is represented as an object with the following fields.</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sum</code></td><td>Integer</td><td>The sum of all recorded values.</td></tr>
<tr><td><code>values</code></td><td>Map&lt;String, Integer&gt;</td><td>The values in each bucket. The key is the minimum value for the range of that bucket.</td></tr>
</tbody></table>
<p>A contiguous range of buckets is always sent, so that the server can aggregate and visualize distributions, without knowing anything about the specific bucketing function used.
This range starts with the first bucket with a non-zero accumulation, and ends at one bucket beyond the last bucket with a non-zero accumulation (so that the upper bound on the last bucket is retained).</p>
<p>For example, the following shows the recorded values vs. what is sent in the payload.</p>
<pre><code>recorded:  1024: 2, 1116: 1,                   1448: 1,
sent:      1024: 2, 1116: 1, 1217: 0, 1327: 0, 1448: 1, 1579: 0
</code></pre>
<h4><a class="header" href="#example-5" id="example-5">Example:</a></h4>
<pre><code class="language-json">{
    &quot;sum&quot;: 4612,
    &quot;values&quot;: {
        &quot;1024&quot;: 2,
        &quot;1116&quot;: 1,
        &quot;1217&quot;: 0,
        &quot;1327&quot;: 0,
        &quot;1448&quot;: 1,
        &quot;1579&quot;: 0
    }
}
</code></pre>
<h3><a class="header" href="#memory-distribution-1" id="memory-distribution-1">Memory Distribution</a></h3>
<p>A <a href="dev/core/internal/../../../user/metrics/memory_distribution.html">Memory distribution</a> is represented as an object with the following fields.</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sum</code></td><td>Integer</td><td>The sum of all recorded values.</td></tr>
<tr><td><code>values</code></td><td>Map&lt;String, Integer&gt;</td><td>The values in each bucket. The key is the minimum value for the range of that bucket.</td></tr>
</tbody></table>
<p>A contiguous range of buckets is always sent.
See <a href="dev/core/internal/payload.html#timing-distribution">timing distribution</a> for more details.</p>
<h4><a class="header" href="#example-6" id="example-6">Example:</a></h4>
<pre><code class="language-json">{
    &quot;sum&quot;: 3,
    &quot;values&quot;: {
        &quot;0&quot;: 1,
        &quot;1&quot;: 3,
    }
}
</code></pre>
<h3><a class="header" href="#uuid-1" id="uuid-1">UUID</a></h3>
<p>A <a href="dev/core/internal/../../../user/metrics/uuid.html">UUID</a> is represented by the string representation of the UUID.</p>
<h4><a class="header" href="#example-7" id="example-7">Example</a></h4>
<pre><code class="language-json">&quot;29711dc8-a954-11e9-898a-eb4ea7e8fd3f&quot;
</code></pre>
<h3><a class="header" href="#datetime-1" id="datetime-1">Datetime</a></h3>
<p>A <a href="dev/core/internal/../../../user/metrics/datetime.html">Datetime</a> is represented by its ISO8601 string representation, truncated to the metric's time unit.
It always includes the timezone offset.</p>
<h4><a class="header" href="#example-8" id="example-8">Example</a></h4>
<pre><code class="language-json">&quot;2019-07-18T14:06:00.000+02:00&quot;
</code></pre>
<h3><a class="header" href="#event" id="event">Event</a></h3>
<p><a href="dev/core/internal/../../../user/metrics/event.html">Events</a> are represented as an array of objects, with one object for each event.
Each event object has the following keys:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>timestamp</code></td><td>Integer</td><td>A monotonically increasing timestamp value, in milliseconds. To avoid leaking absolute times, the first timestamp in the array is always zero, and subsequent timestamps in the array are relative to that reference point.</td></tr>
<tr><td><code>category</code></td><td>String</td><td>The event's category. This comes directly from the category under which the metric was defined in the <code>metrics.yaml</code> file.</td></tr>
<tr><td><code>name</code></td><td>String</td><td>The event's name, as defined in the <code>metrics.yaml</code> file.</td></tr>
<tr><td><code>extra</code></td><td>Object (optional)</td><td>Extra data associated with the event. Both the keys and values of this object are strings. The keys must be from the set defined for this event in the <code>metrics.yaml</code> file. The values have a maximum length of 50 bytes, when encoded as UTF-8.</td></tr>
</tbody></table>
<h4><a class="header" href="#example-9" id="example-9">Example</a></h4>
<pre><code class="language-json">[
  {
    &quot;timestamp&quot;: 0,
    &quot;category&quot;: &quot;app&quot;,
    &quot;name&quot;: &quot;ss_menu_opened&quot;
  },
  {
    &quot;timestamp&quot;: 124,
    &quot;category&quot;: &quot;search&quot;,
    &quot;name&quot;: &quot;performed_search&quot;,
    &quot;extra&quot;: {
      &quot;source&quot;: &quot;default.action&quot;
    }
  }
]
</code></pre>
<p>Also see <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas/blob/master/templates/include/glean/event.1.schema.json">the JSON schema for events</a>.</p>
<p>To avoid losing events when the application is killed by the operating system, events are queued on disk as they are recorded.
When the application starts up again, there is no good way to determine if the device has rebooted since the last run and therefore any timestamps recorded in the new run could not be guaranteed to be consistent with those recorded in the previous run.
To get around this, on application startup, any queued events are immediately collected into pings and then cleared.
These &quot;startup-triggered pings&quot; are likely to have a very short duration, as recorded in <code>ping_info.start_time</code> and <code>ping_info.end_time</code> (see <a href="dev/core/internal/../../../user/pings/index.html#The-ping_info-section">the <code>ping_info</code> section</a>).
The maximum timestamp of the events in these pings are quite likely to exceed the duration of the ping, but this is to be expected.</p>
<h3><a class="header" href="#custom-distribution-1" id="custom-distribution-1">Custom Distribution</a></h3>
<p>A <a href="dev/core/internal/../../../user/metrics/custom_distribution.html">Custom distribution</a> is represented as an object with the following fields.</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sum</code></td><td>Integer</td><td>The sum of all recorded values.</td></tr>
<tr><td><code>values</code></td><td>Map&lt;String, Integer&gt;</td><td>The values in each bucket. The key is the minimum value for the range of that bucket.</td></tr>
</tbody></table>
<p>A contiguous range of buckets is always sent, so that the server can aggregate and visualize distributions, without knowing anything about the specific bucketing function used.
This range starts with the first bucket (as specified in the <code>range_min</code> parameter), and ends at one bucket beyond the last bucket with a non-zero accumulation (so that the upper bound on the last bucket is retained).</p>
<p>For example, suppose you had a custom distribution defined by the following parameters:</p>
<ul>
<li><code>range_min</code>: 10</li>
<li><code>range_max</code>: 200</li>
<li><code>bucket_count</code>: 80</li>
<li><code>histogram_type</code>: <code>'linear'</code></li>
</ul>
<p>The following shows the recorded values vs. what is sent in the payload.</p>
<pre><code>recorded:        12: 2,                      22: 1
sent:     10: 0, 12: 2, 14: 0, 17: 0, 19: 0, 22: 1, 24: 0
</code></pre>
<h4><a class="header" href="#example-10" id="example-10">Example:</a></h4>
<pre><code class="language-json">{
    &quot;sum&quot;: 3,
    &quot;values&quot;: {
        &quot;10&quot;: 0,
        &quot;12&quot;: 2,
        &quot;14&quot;: 0,
        &quot;17&quot;: 0,
        &quot;19&quot;: 0,
        &quot;22&quot;: 1,
        &quot;24&quot;: 0
    }
}
</code></pre>
<h3><a class="header" href="#labeled-metrics-1" id="labeled-metrics-1">Labeled metrics</a></h3>
<p>Currently several labeled metrics are supported:</p>
<ul>
<li><a href="dev/core/internal/../../../user/metrics/labeled_counters.html">Labeled Counters</a>.</li>
<li><a href="dev/core/internal/../../../user/metrics/labeled_strings.html">Labeled Strings</a>.</li>
</ul>
<p>All are on the top-level represented in the same way, as an object mapping the label to the metric's value.
See the individual metric types for details on the value payload:</p>
<ul>
<li><a href="dev/core/internal/payload.html#counter">Counter</a></li>
<li><a href="dev/core/internal/payload.html#string">String</a></li>
</ul>
<h4><a class="header" href="#example-for-labeled-counters" id="example-for-labeled-counters">Example for Labeled Counters</a></h4>
<pre><code class="language-json">{
    &quot;label1&quot;: 2,
    &quot;label2&quot;: 17
}
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/internal/payload.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#directory-structure" id="directory-structure">Directory structure</a></h1>
<p>This page describes the contents of the directories where Glean stores its data.</p>
<p>All Glean data is inside a single root directory with the name <code>glean_data</code>.</p>
<p>On Android, this directory lives inside the <a href="https://developer.android.com/reference/android/content/pm/ApplicationInfo.html#dataDir"><code>ApplicationInfo.dataDir</code></a> directory associated with the application.</p>
<p>On iOS, this directory lives inside the <a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html"><code>Documents</code></a> directory associated with the application.</p>
<p>For the Python bindings, if no directory is specified, it is stored in a temporary directory and cleared at exit.</p>
<p>Within the <code>glean_data</code> directory are the following contents:</p>
<ul>
<li>
<p><code>db</code>: Contains the <a href="https://github.com/mozilla/rkv">rkv</a> database used to persist ping and user lifetime metrics.</p>
</li>
<li>
<p><code>events</code>: Contains flat files containing persisted events before they are collected into pings.</p>
</li>
<li>
<p><code>pending_pings</code>: Pings are written here before they are picked up by the ping uploader to send to the submission endpoint.</p>
</li>
<li>
<p><code>deletion_request</code>: The <code>deletion-request</code> ping is written here before it is picked up by the ping uploader. This directory is separate from the <code>pending_pings</code> directory above, in or for an uploader to pick up only <code>deletion-request</code> pings and send them after general upload is disabled.</p>
</li>
<li>
<p><code>tmp</code>: Pings are written here and then moved to the <code>pending_pings</code> directory when finished to make sure that partially-written pings to not get queued for sending.<br />
(The standard system temporary directory is not used for this because it is not guaranteed to be on the same volume as the <code>glean_data</code> directory on Android).</p>
</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/internal/directory-structure.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#debug-pings" id="debug-pings">Debug Pings</a></h1>
<p>For debugging and testing purposes Glean allows to tag pings, which are then available in the <a href="https://glean-debug-view-dev-237806.firebaseapp.com/">Debug Ping Viewer</a><sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>Pings are sent to the same endpoint as all pings, with the addition of one HTTP header:</p>
<pre><code>X-Debug-ID: &lt;tag&gt;
</code></pre>
<p><code>&lt;tag&gt;</code> is a alphanumeric string with a maximum length of 20 characters, used to identify pings in the Debug Ping Viewer.</p>
<p>See <a href="dev/core/internal/../../../user/debugging/index.html">Debugging products using the Glean SDK</a> for detailed information how to use this mechanism in applications.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Requires a Mozilla login.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/internal/debug-pings.md">Edit this file on GitHub.</a></footer></div>
<h1><a class="header" href="#upload-mechanism" id="upload-mechanism">Upload mechanism</a></h1>
<p>The <code>glean-core</code> Rust crate does not handle the ping upload directly.
Network stacks vastly differ between platforms, applications and operating systems.
The Glean SDK leverages the available platform capabilities to implement any network communication.</p>
<p>Glean core controls all upload and coordinates the platform side with its own internals.
All language bindings implement ping uploading around a common API and protocol.</p>
<h2><a class="header" href="#upload-task-api" id="upload-task-api">Upload task API</a></h2>
<p>The following diagram visualizes the communication between Glean core (the Rust crate),
a Glean language binding (e.g. the Kotlin or Swift implementation) and a Glean end point server.</p>
<pre class="mermaid">sequenceDiagram
    participant Glean core
    participant Glean wrapper
    participant Server

    Glean wrapper->>Glean core: get_upload_task()
    Glean core->>Glean wrapper: Task::Upload(task)
    Glean wrapper-->>Server: POST /submit/{task.id}
    Server-->>Glean wrapper: 200 OK
    Glean wrapper->>Glean core: upload_response(200)
    Glean wrapper->>Glean core: get_upload_task()
    Glean core->>Glean wrapper: Task::Done
</pre>
<p>Glean core will take care of file management, cleanup, rescheduling and throttling<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<blockquote>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> Note: At this point throttling is not implemented. Follow <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1543612">Bug 1543612</a> for updates.</p>
</blockquote>
<h2><a class="header" href="#available-apis" id="available-apis">Available APIs</a></h2>
<div class="tabs">
<div class="tabbar"></div>
<div class="tabcontents">
<div data-lang="Rust" class="tab">
<p>For direct Rust consumers the global <code>Glean</code> object provides these methods:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// Gets the next task for an uploader.
fn get_upload_task(&amp;self) -&gt; PingUploadTask

/// Processes the response from an attempt to upload a ping.
fn process_ping_upload_response(&amp;self, uuid: &amp;str, status: UploadResult)
<span class="boring">}
</span></code></pre></pre>
<p>See the documentation for further usage and explanation of the additional types:</p>
<ul>
<li><a href="dev/core/internal/../../../../docs/glean_core/struct.Glean.html#method.get_upload_task"><code>get_upload_task</code></a></li>
<li><a href="dev/core/internal/../../../../docs/glean_core/struct.Glean.html#method.process_ping_upload_response"><code>process_ping_upload_response</code></a></li>
<li><a href="dev/core/internal/../../../../docs/glean_core/upload/enum.PingUploadTask.html"><code>PingUploadTask</code></a></li>
<li><a href="dev/core/internal/../../../../docs/glean_core/upload/enum.UploadResult.html"><code>UploadResult</code></a></li>
</ul>
</div>
<div data-lang="FFI" class="tab">
<p>For FFI consumers (e.g. Kotlin/Swift/Python implementations) these functions are available:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// Gets the next task for an uploader. Which can be either:
extern &quot;C&quot; fn glean_get_upload_task() -&gt; FfiPingUploadTask

/// Processes the response from an attempt to upload a ping.
extern &quot;C&quot; fn glean_process_ping_upload_response(task: FfiPingUploadTask, status: u32)
<span class="boring">}
</span></code></pre></pre>
<p>See the documentation for additional information about the types:</p>
<ul>
<li><a href="dev/core/internal/../../../../docs/glean_ffi/upload/index.html"><code>glean_ffi::upload</code></a></li>
</ul>
</div>
</div>
</div>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/internal/upload.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#implementations" id="implementations">Implementations</a></h1>
<table><thead><tr><th>Project Name</th><th>Language Bindings</th><th>Operating System</th><th>App Lifecycle Type</th><th>Environment Data source</th></tr></thead><tbody>
<tr><td>glean-core</td><td>Rust</td><td>all</td><td>all</td><td>none</td></tr>
<tr><td>glean-ffi</td><td>C</td><td>all</td><td>all</td><td>none</td></tr>
<tr><td>glean-preview<sup class="footnote-reference"><a href="#1">1</a></sup></td><td>Rust</td><td>Windows/Mac/Linux</td><td>Desktop application</td><td>OS info build-time autodetected, app info passed in</td></tr>
<tr><td>Glean Android</td><td>Kotlin, Java</td><td>Android</td><td>Mobile app</td><td>Autodetected from the Android environment</td></tr>
<tr><td>Glean iOS</td><td>Swift</td><td>iOS</td><td>Mobile app</td><td>Autodetected from the iOS environment</td></tr>
<tr><td>Glean.py</td><td>Python</td><td>Windows/Mac/Linux</td><td>all</td><td>Autodetected at runtime</td></tr>
<tr><td>FOG<sup class="footnote-reference"><a href="#2">2</a></sup></td><td>Rust/C++/JavaScript</td><td>as Firefox supports</td><td>Desktop application</td><td>OS info build-time autodetected, app info passed in</td></tr>
</tbody></table>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://crates.io/crates/glean-preview">glean-preview</a> is an experimental crate for prototyping integration into Firefox. It it not recommended for general use. See Project FOG.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://firefox-source-docs.mozilla.org/toolkit/components/glean/index.html">Firefox on Glean (FOG)</a> is the name of the layer that integrates the Glean SDK into Firefox Desktop. It is currently being designed and implemented. It is being used as a test bed for how best to write a generic Rust language binding layer and so temporarily ties directly to glean-core instead of an API crate. Prospective non-mozilla-central Rust consumers of the Glean SDK should not follow its example and should instead follow <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1631768">bug 1631768</a> for updates on when the proper language binding crate will be available.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/internal/implementations.md">Edit this file on GitHub.</a></footer></div>
<h1><a class="header" href="#android-sdk--ndk-versions" id="android-sdk--ndk-versions">Android SDK / NDK versions</a></h1>
<p>The Glean SDK implementation is currently build against the following versions:</p>
<ul>
<li>SDK API 28
<ul>
<li>Look for <code>android-28</code> in the SDK manager</li>
<li>or install with: <code>sdkmanager --verbose &quot;platforms;android-28&quot;</code></li>
</ul>
</li>
<li>Android build tools 28.0.3
<ul>
<li>Download link: <a href="https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip">https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip</a></li>
</ul>
</li>
<li>NDK r20
<ul>
<li>Download link: <a href="https://dl.google.com/android/repository/android-ndk-r20-linux-x86_64.zip">https://dl.google.com/android/repository/android-ndk-r20-linux-x86_64.zip</a></li>
</ul>
</li>
</ul>
<p>For the full setup see <a href="dev/core/internal/../../android/setup-android-build-environment.html">Setup the Android Build Environment</a>.</p>
<p>The versions are defined in the following files.
All locations need to be updated on upgrades:</p>
<ul>
<li>Documentation
<ul>
<li>this file (<code>docs/dev/core/internal/sdk-ndk-versions.md</code>)</li>
<li><code>dev/android/setup-android-build-environment.md</code></li>
</ul>
</li>
<li>CI configuration
<ul>
<li><code>.circleci/config.yml</code>
<ul>
<li><code>sdkmanager 'build-tools;28.0.3'</code></li>
<li><code>image: circleci/android:api-28-ndk</code></li>
</ul>
</li>
<li><code>taskcluster/docker/linux/Dockerfile</code>.
<ul>
<li><code>ENV ANDROID_BUILD_TOOLS &quot;28.0.3&quot;</code></li>
<li><code>ENV ANDROID_SDK_VERSION &quot;3859397&quot;</code></li>
<li><code>ENV ANDROID_PLATFORM_VERSION &quot;28&quot;</code></li>
<li><code>ENV ANDROID_NDK_VERSION &quot;r20&quot;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/core/internal/sdk-ndk-versions.md">Edit this file on GitHub.</a></footer><footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/howtos/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#working-on-unreleased-glean-code-in-android-components" id="working-on-unreleased-glean-code-in-android-components">Working on unreleased Glean code in android-components</a></h1>
<p>This is a companion to the <a href="https://mozilla-mobile.github.io/android-components/contributing/testing-components-inside-app">equivalent instructions for the android-components repository</a>.</p>
<p>Modern Gradle supports <a href="https://docs.gradle.org/current/userguide/composite_builds.html">composite builds</a>, which allows to substitute on-disk projects for binary publications.  Composite builds transparently accomplish what is usually a frustrating loop of:</p>
<ol>
<li>change library</li>
<li>publish library snapshot to the local Maven repository</li>
<li>consume library snapshot in application</li>
</ol>
<h2><a class="header" href="#preparation" id="preparation">Preparation</a></h2>
<p>Clone the Glean SDK and android-components repositories:</p>
<pre><code class="language-sh">git clone https://github.com/mozilla/glean
git clone https://github.com/mozilla-mobile/android-components
</code></pre>
<h2><a class="header" href="#cargo-build-targets" id="cargo-build-targets">Cargo build targets</a></h2>
<p>By default when building Android Components using gradle, the gradle-cargo plugin will compile Glean for every possible platform,
which might end up in failures.
You can customize which targets are built in <code>glean/local.properties</code>
(<a href="https://github.com/ncalexan/rust-android-gradle/blob/master/README.md#specifying-local-targets">more information</a>):</p>
<pre><code># For physical devices:
rust.targets=arm

# For unit tests:
# rust.targets=darwin # Or linux-*, windows-* (* = x86/x64)

# For emulator only:
rust.targets=x86
</code></pre>
<h2><a class="header" href="#substituting-projects" id="substituting-projects">Substituting projects</a></h2>
<p>android-components has custom build logic for dealing with composite builds,
so you should be able to configure it by simply adding the path to the Glean repository in the correct <code>local.properties</code> file:</p>
<p>In <code>android-components/local.properties</code>:</p>
<pre><code class="language-groovy">substitutions.glean.dir=../glean
</code></pre>
<p>If this doesn't seem to work, or if you need to configure composite builds for a project that does not contain this custom logic,
add the following to <code>settings.gradle</code>:</p>
<p>In <code>android-components/settings.gradle</code>:</p>
<pre><code class="language-groovy">includeBuild('../glean') {
  dependencySubstitution {
    substitute module('org.mozilla.telemetry:glean') with project(':glean')
    substitute module('org.mozilla.telemetry:glean-forUnitTests') with project(':glean')
  }
}
</code></pre>
<p>Composite builds will ensure the Glean SDK is build as part of tasks inside <code>android-components</code>.</p>
<h2><a class="header" href="#caveat" id="caveat">Caveat</a></h2>
<p>There's a big gotcha with library substitutions: the Gradle build computes lazily, and AARs don't include their transitive dependencies' JNI libraries.
This means that in <code>android-components</code>, <code>./gradlew :service-glean:assembleDebug</code> <strong>does not</strong> invoke <code>:glean:cargoBuild</code>,
even though <code>:service-glean</code> depends on the substitution for <code>:glean</code> and even if the inputs to Cargo have changed!
It's the final consumer of the <code>:service-glean</code> project (or publication) that will incorporate the JNI libraries.</p>
<p>In practice that means <em>you should always be targeting something that produces an APK</em>: a test or a sample module.
Then you should find that the <code>cargoBuild</code> tasks are invoked as you expect.</p>
<p>Inside the <code>android-components</code> repository <code>./gradlew :samples-glean:connectedAndroidTest</code> should work.
Other tests like <code>:service-glean:testDebugUnitTest</code> or <code>:support-sync-telemetry:testDebugUnitTest</code> will currently fail, because the JNI libraries are not included.</p>
<h2><a class="header" href="#notes" id="notes">Notes</a></h2>
<p>This document is based on the equivalent documentation for application-services:
<a href="https://github.com/mozilla/application-services/blob/master/docs/howtos/working-with-reference-browser.md">Development with the Reference Browser</a></p>
<ol>
<li>Transitive substitutions (as shown above) work but require newer Gradle versions (4.10+).</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/howtos/development-with-android-components.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#using-locally-published-glean-in-fenix" id="using-locally-published-glean-in-fenix">Using locally-published Glean in Fenix</a></h1>
<blockquote>
<p>Note: This is a bit tedious, and you might like to try the substitution-based &gt; approach documented in
<a href="dev/howtos/./development-with-android-components.html">Working on unreleased Glean code in android-components</a>.
That approach is still fairly new, and the local-publishing approach in this document is necessary if it fails.</p>
</blockquote>
<blockquote>
<p>Note: This is Fenix-specific only in that some links on the page go to the <code>mozilla-mobile/fenix</code> repository,
however these steps should work for e.g. <code>reference-browser</code>, as well.
(Same goes for Lockwise, or any other consumer of Glean, but they may use a different structure -- Lockwise has no Dependencies.kt, for example)</p>
</blockquote>
<h2><a class="header" href="#preparation-1" id="preparation-1">Preparation</a></h2>
<p>Clone the Glean SDK, android-components and Fenix repositories:</p>
<pre><code class="language-sh">git clone https://github.com/mozilla/glean
git clone https://github.com/mozilla-mobile/android-components
git clone https://github.com/mozilla-mobile/fenix/
</code></pre>
<h2><a class="header" href="#local-publishing" id="local-publishing">Local publishing</a></h2>
<ol>
<li>
<p>Inside the <code>glean</code> repository root:</p>
<ol>
<li>
<p>In <a href="https://github.com/mozilla/glean/blob/master/.buildconfig.yml#L1"><code>.buildconfig.yml</code></a>, change
<code>libraryVersion</code> to end in <code>-TESTING$N</code><sup class="footnote-reference"><a href="#1">1</a></sup>,
where <code>$N</code> is some number that you haven't used for this before.</p>
<p>Example: <code>libraryVersion: 22.0.0-TESTING1</code></p>
</li>
<li>
<p>Check your <code>local.properties</code> file,
and add <code>rust.targets=x86</code> if you're testing on the emulator,
<code>rust.targets=arm</code> if you're testing on 32-bit arm (arm64 for 64-bit arm, etc).
This will make the build that's done in the next step much faster.</p>
</li>
<li>
<p>Run <code>./gradlew publishToMavenLocal</code>. This may take a few minutes.</p>
</li>
</ol>
</li>
<li>
<p>Inside the <code>android-components</code> repository root:</p>
<ol>
<li>
<p>In <a href="https://github.com/mozilla-mobile/android-components/blob/master/.buildconfig.yml#L1"><code>.buildconfig.yml</code></a>, change
<code>componentsVersion</code> to end in <code>-TESTING$N</code><sup class="footnote-reference"><a href="#1">1</a></sup>,
where <code>$N</code> is some number that you haven't used for this before.</p>
<p>Example: <code>componentsVersion: 24.0.0-TESTING1</code></p>
</li>
<li>
<p>Inside <a href="https://github.com/mozilla-mobile/android-components/blob/50a2f28027f291bf1c6056d42b55e75ba3c050db/buildSrc/src/main/java/Dependencies.kt#L32"><code>buildSrc/src/main/java/Dependencies.kt</code></a>,
change <code>mozilla_glean</code> to reference the <code>libraryVersion</code> you published in step 2 part 1.</p>
<p>Example: <code>const val mozilla_glean = &quot;22.0.0-TESTING1&quot;</code></p>
</li>
<li>
<p>Inside <a href="https://github.com/mozilla-mobile/android-components/blob/b98206cf8de818499bdc87c00de942a41f8aa2fb/build.gradle#L28"><code>build.gradle</code></a>, add
<code>mavenLocal()</code> inside <code>allprojects { repositories { &lt;here&gt; } }</code>.</p>
</li>
<li>
<p>Add the following block in the <a href="https://github.com/mozilla-mobile/android-components/blob/d67f83af679a2e847e5bd284ea4a30b412403241/settings.gradle#L7"><code>settings.gradle</code></a> file, before any other statement in the script, in order to have the Glean Gradle plugin loaded from the local Maven repository.</p>
</li>
</ol>
<pre><code>pluginManagement {
  repositories {
      mavenLocal()
      gradlePluginPortal()
  }
}
</code></pre>
<ol start="5">
<li>
<p>Inside the android-component's <code>local.properties</code> file, ensure
<code>substitutions.glean.dir</code> is <em>NOT</em> set.</p>
</li>
<li>
<p>Run <code>./gradlew publishToMavenLocal</code>.</p>
</li>
</ol>
</li>
<li>
<p>Inside the <code>fenix</code> repository root:</p>
<ol>
<li>
<p>Inside <a href="https://github.com/mozilla-mobile/fenix/blob/f897c2e295cd1b97d4024c7a9cb45dceb7a2fa89/build.gradle#L26"><code>build.gradle</code></a>, add
<code>mavenLocal()</code> inside <code>allprojects { repositories { &lt;here&gt; } }</code>.</p>
</li>
<li>
<p>Inside <a href="https://github.com/mozilla-mobile/fenix/blob/8a330d413c1d55d14446abe3cfd57a5494884396/buildSrc/src/main/java/Dependencies.kt#L48"><code>buildSrc/src/main/java/Dependencies.kt</code></a>, change
<code>mozilla_android_components</code> to the version you defined in step 3 part 1.</p>
<p>Example: <code>const val mozilla_android_components = &quot;24.0.0-TESTING1&quot;</code></p>
<p>In the same file change <code>mozilla_glean</code> to the version you defined in step 1 part 1.</p>
<p>Example: <code>const val mozilla_glean = &quot;22.0.0-TESTING1&quot;</code></p>
</li>
<li>
<p>Change the <code>Versions.mozilla_android_components.endsWith('-SNAPSHOT')</code> line in <a href="https://github.com/mozilla-mobile/fenix/blob/1f250a730d4f1bbd42bc15079eb98d1b01a34cf0/app/build.gradle#L628"><code>app/build.gradle</code></a> to <code>Versions.mozilla_android_components.endsWith('-TESTING$N')</code> where <code>$N</code> is the number to reference the version you published in part 2.</p>
</li>
</ol>
</li>
</ol>
<p>You should now be able to build and run Fenix (assuming you could before all this).</p>
<h2><a class="header" href="#caveats" id="caveats">Caveats</a></h2>
<ol>
<li>This assumes you have followed the <a href="dev/howtos/../android/setup-android-build-environment.html">android/rust build setup</a></li>
<li>Make sure you're fully up to date in all repositories, unless you know you need to not be.</li>
<li>This omits the steps if changes needed because, e.g. Glean made a breaking change to an API used in android-components.
These should be understandable to fix, you usually should be able to find a PR with the fixes somewhere in the android-component's list of pending PRs
(or, failing that, a description of what to do in the Glean changelog).</li>
<li>Ask in the <a href="https://chat.mozilla.org/#/room/#glean:mozilla.org">#glean channel on chat.mozilla.org</a>.</li>
</ol>
<h2><a class="header" href="#notes-1" id="notes-1">Notes</a></h2>
<p>This document is based on the equivalent documentation for application-services:
<a href="https://github.com/mozilla/application-services/blob/master/docs/howtos/locally-published-components-in-fenix.md">Using locally-published components in Fenix</a></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>It doesn't have to end with <code>-TESTING$N</code>, it only needs to have the format <code>-someidentifier</code>.
<code>-SNAPSHOT$N</code> is also very common to use, however without the numeric suffix, this has specific meaning to gradle,
so we avoid it.
Additionally, while the <code>$N</code> we have used in our running example has matched
(e.g. all of the identifiers ended in <code>-TESTING1</code>, this is not required, so long as you match everything up correctly at the end).</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/dev/howtos/locally-published-components-in-fenix.md">Edit this file on GitHub.</a></footer></div>
<p>The following language-specific API docs are available:</p>
<ul>
<li><a href="api/../../javadoc/glean/index.html">Kotlin API docs</a></li>
<li><a href="api/../../swift/index.html">Swift API docs</a></li>
<li><a href="api/../../python/glean/index.html">Python API docs</a></li>
<li><a href="api/../../docs/index.html">Rust core (internal) API docs</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/api/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>The following sections contain other material related to Glean.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/appendix/index.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<p>A glossary with explanations and background for wording used in the Glean project.</p>
<h2><a class="header" href="#glean" id="glean">Glean</a></h2>
<p>According to the <a href="https://www.merriam-webster.com/dictionary/glean">dictionary</a> the word glean means:</p>
<blockquote>
<p>to gather information or material bit by bit</p>
</blockquote>
<p>Glean is the combination of the Glean SDK, the Glean pipeline &amp; Glean tools.</p>
<p>See also: <a href="https://docs.telemetry.mozilla.org/concepts/glean/glean.html">Glean - product analytics &amp; telemetry</a>.</p>
<h2><a class="header" href="#glean-pipeline" id="glean-pipeline">Glean Pipeline</a></h2>
<p>The general data pipeline is the infrastructure that collects, stores, and analyzes telemetry data from our products and logs from various services.
See <a href="https://docs.telemetry.mozilla.org/concepts/pipeline/gcp_data_pipeline.html">An overview of Mozillas Data Pipeline</a>.</p>
<p>The Glean pipeline additionally consists of</p>
<ul>
<li>the <a href="https://github.com/mozilla/probe-scraper#glean-metrics-data-files">Probe Info Service</a>,</li>
<li>the <a href="https://github.com/mozilla/mozilla-schema-generator/">schema generator</a>,</li>
<li>the <a href="https://github.com/mozilla/jsonschema-transpiler">JSON Schema transpiler</a>,</li>
<li>the <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas">ping schemas</a>.</li>
</ul>
<h2><a class="header" href="#glean-sdk-1" id="glean-sdk-1">Glean SDK</a></h2>
<p>The Glean SDK is the bundle of libraries with support for different platforms.
The source code is available at <a href="https://github.com/mozilla/glean">https://github.com/mozilla/glean</a>.</p>
<h2><a class="header" href="#glean-sdk-book" id="glean-sdk-book">Glean SDK book</a></h2>
<p>This documentation.</p>
<h2><a class="header" href="#glean-tools" id="glean-tools">Glean tools</a></h2>
<p>Glean provides additional tools for its usage:</p>
<ul>
<li><a href="https://mozilla.github.io/glean_parser/">Glean parser</a> (Source code: <a href="https://github.com/mozilla/glean_parser/">https://github.com/mozilla/glean_parser/</a>)</li>
</ul>
<h2><a class="header" href="#metric" id="metric">Metric</a></h2>
<p>Metrics are the individual things being measured using Glean.
They are defined in <a href="https://mozilla.github.io/glean_parser/metrics-yaml.html">metrics.yaml</a> files, also known as <em>registry files</em>.</p>
<p>Glean itself provides <a href="appendix/../user/collected-metrics/metrics.html">some metrics out of the box</a>.</p>
<h2><a class="header" href="#ping" id="ping">Ping</a></h2>
<p>A ping is an entity used to bundle related metrics.
The Glean SDK provides default pings and allows for custom ping, see <a href="appendix/../user/pings/index.html">Glean Pings</a>.</p>
<h2><a class="header" href="#submission" id="submission">Submission</a></h2>
<p>&quot;To submit&quot; means to collect &amp; to upload a ping.</p>
<p>The Glean SDK stores locally all the metrics set by it or by its clients.
Each ping has its own schedule to gather all its locally saved metrics and create a JSON payload with them. This is called &quot;collection&quot;.</p>
<p>Upon successful collection, the payload is queued for upload, which may not happen immediately or at all (in case network connectivity is not available).</p>
<p>Unless the user has defined their own custom pings, they dont need to worry too much about submitting pings.
All the default pings have their scheduling and submission handled by the SDK.</p>
<h2><a class="header" href="#this-week-in-glean-twig" id="this-week-in-glean-twig">This Week in Glean (TWiG)</a></h2>
<p><a href="appendix/twig.html">This Week in Glean</a> is a series of blog posts that the Glean Team at Mozilla is using to try to communicate better about our work.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/appendix/glossary.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#unreleased-changes" id="unreleased-changes">Unreleased changes</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v30.0.0...master">Full changelog</a></p>
<h1><a class="header" href="#v3000-2020-05-13" id="v3000-2020-05-13">v30.0.0 (2020-05-13)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v29.1.0...v30.0.0">Full changelog</a></p>
<ul>
<li>General:
<ul>
<li>We completely replaced how the upload mechanism works.
glean-core (the Rust part) now controls all upload and coordinates the platform side with its own internals.
All language bindings implement ping uploading around a common API and protocol.
There is no change for users of Glean, the language bindings for Android and iOS have been adopted to the new mechanism already.</li>
<li>Expose <code>RecordedEvent</code> and <code>DistributionData</code> types to Rust consumers (<a href="https://github.com/mozilla/glean/pull/876">#876</a>)</li>
<li>Log crate version at initialize (<a href="https://github.com/mozilla/glean/pull/873">#873</a>)</li>
</ul>
</li>
<li>Android:
<ul>
<li>Refactor the ping uploader to use the new upload mechanism.</li>
</ul>
</li>
<li>iOS:
<ul>
<li>Refactor the ping uploader to use the new upload mechanism.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2910-2020-05-11" id="v2910-2020-05-11">v29.1.0 (2020-05-11)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v29.0.0...v29.1.0">Full changelog</a></p>
<ul>
<li>General:
<ul>
<li>The version of glean_parser has been upgraded to v1.20.4
<ul>
<li>BUGFIX: <code>yamllint</code> errors are now reported using the correct file name.</li>
</ul>
</li>
<li>The minimum and maximum values of a timing distribution can now be controlled by the <code>time_unit</code> parameter. See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1630997">bug 1630997</a> for more details.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2900-2020-05-05" id="v2900-2020-05-05">v29.0.0 (2020-05-05)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v28.0.0...v29.0.0">Full changelog</a></p>
<ul>
<li>General:
<ul>
<li>The version of glean_parser has been upgraded to v1.20.2 (<a href="https://github.com/mozilla/glean/pull/827">#827</a>):
<ul>
<li><strong>Breaking change:</strong> glinter errors found during code generation will now return an error code.</li>
<li><code>glean_parser</code> now produces a linter warning when <code>user</code> lifetime metrics are set to expire. See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1604854">bug 1604854</a> for additional context.</li>
</ul>
</li>
</ul>
</li>
<li>Android:
<ul>
<li>The <code>PingType.submit()</code> can now be called without a <code>null</code> by Java consumers (<a href="https://github.com/mozilla/glean/pull/853">#853</a>).</li>
</ul>
</li>
<li>Python:
<ul>
<li>BUGFIX: Fixed a race condition in the <code>atexit</code> handler, that would have resulted in the message &quot;No database found&quot; (<a href="https://github.com/mozilla/glean/pull/854">#854</a>).</li>
<li>The Glean FFI header is now parsed at build time rather than runtime. Relevant for packaging in <code>PyInstaller</code>, the wheel no longer includes <code>glean.h</code> and adds <code>_glean_ffi.py</code> (<a href="https://github.com/mozilla/glean/pull/852">#852</a>).</li>
<li>The minimum versions of many secondary dependencies have been lowered to make the Glean SDK compatible with more environments.</li>
<li>Dependencies that depend on the version of Python being used are now specified using the <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-platform-specific-dependencies">Declaring platform specific dependencies syntax in setuptools</a>. This means that more recent versions of dependencies are likely to be installed on Python 3.6 and later, and unnecessary backport libraries won't be installed on more recent Python versions.</li>
</ul>
</li>
<li>iOS:
<ul>
<li>Glean for iOS is now being built with Xcode 11.4.1 (<a href="https://github.com/mozilla/glean/pull/856">#856</a>)</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2800-2020-04-23" id="v2800-2020-04-23">v28.0.0 (2020-04-23)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v27.1.0...v28.0.0">Full changelog</a></p>
<ul>
<li>General:
<ul>
<li>The baseline ping is now sent when the application goes to foreground, in addition to background and dirty-startup.</li>
</ul>
</li>
<li>Python:
<ul>
<li>BUGFIX: The ping uploader will no longer display a trace back when the upload fails due to a failed DNS lookup, network outage, or related issues that prevent communication with the telemetry endpoint.</li>
<li>The dependency on <code>inflection</code> has been removed.</li>
<li>The Python bindings now use <code>subprocess</code> rather than <code>multiprocessing</code> to perform ping uploading in a separate process. This should be more compatible on all of the platforms Glean supports.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2710-2020-04-09" id="v2710-2020-04-09">v27.1.0 (2020-04-09)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v27.0.0...v27.1.0">Full changelog</a></p>
<ul>
<li>General:
<ul>
<li>BUGFIX: baseline pings sent at startup with the <code>dirty_startup</code> reason will now include application lifetime metrics (<a href="https://github.com/mozilla/glean/pull/810">#810</a>)</li>
</ul>
</li>
<li>iOS:
<ul>
<li><strong>Breaking change:</strong> Change Glean iOS to use Application Support directory <a href="https://github.com/mozilla/glean/pull/815">#815</a>. No migration code is included. This will reset collected data if integrated without migration. Please <a href="https://github.com/mozilla/glean#contact">contact the Glean SDK team</a> if this affects you.</li>
</ul>
</li>
<li>Python
<ul>
<li>BUGFIX: Fixed a race condition between uploading pings and deleting the temporary directory on shutdown of the process.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2700-2020-04-08" id="v2700-2020-04-08">v27.0.0 (2020-04-08)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v26.0.0...v27.0.0">Full changelog</a></p>
<ul>
<li>General
<ul>
<li>Glean will now detect when the upload enabled flag changes outside of the application, for example due to a change in a config file. This means that if upload is disabled while the application wasn't running (e.g. between the runs of a Python command using the Glean SDK), the database is correctly cleared and a deletion request ping is sent. See <a href="https://github.com/mozilla/glean/pull/791">#791</a>.</li>
<li>The <code>events</code> ping now includes a reason code: <code>startup</code>, <code>background</code> or <code>max_capacity</code>.</li>
</ul>
</li>
<li>iOS:
<ul>
<li>BUGFIX: A bug where the metrics ping is sent immediately at startup on the last day of the month has been fixed.</li>
<li>Glean for iOS is now being built with Xcode 11.4.0</li>
<li>The <code>measure</code> convenience function on timing distributions and time spans will now cancel the timing if the measured function throws, then rethrow the exception (<a href="https://github.com/mozilla/glean/pull/808">#808</a>)</li>
<li>Broken doc generation has been fixed (<a href="https://github.com/mozilla/glean/pull/805">#805</a>).</li>
</ul>
</li>
<li>Kotlin
<ul>
<li>The <code>measure</code> convenience function on timing distributions and time spans will now cancel the timing if the measured function throws, then rethrow the exception (<a href="https://github.com/mozilla/glean/pull/808">#808</a>)</li>
</ul>
</li>
<li>Python:
<ul>
<li>Glean will now wait at application exit for up to one second to let its worker thread complete.</li>
<li>Ping uploading now happens in a separate child process by default. This can be disabled with the <code>allow_multiprocessing</code> configuration option.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2600-2020-03-27" id="v2600-2020-03-27">v26.0.0 (2020-03-27)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v25.1.0...v26.0.0">Full changelog</a></p>
<ul>
<li>General:
<ul>
<li>The version of <code>glean_parser</code> has been updated to 1.19.0:
<ul>
<li><strong>Breaking change:</strong> The regular expression used to validate labels is
stricter and more correct.</li>
<li>Add more information about pings to markdown documentation:
<ul>
<li>State whether the ping includes client id;</li>
<li>Add list of data review links;</li>
<li>Add list of related bugs links.</li>
</ul>
</li>
<li><code>glean_parser</code> now makes it easier to write external translation functions for
different language targets.</li>
<li>BUGFIX: glean_parser now works on 32-bit Windows.</li>
</ul>
</li>
</ul>
</li>
<li>Android:
<ul>
<li><code>gradlew clean</code> will no longer remove the Miniconda installation in
<code>~/.gradle/glean</code>. Therefore <code>clean</code> can be used without reinstalling
Miniconda afterward every time.</li>
</ul>
</li>
<li>Python:
<ul>
<li><strong>Breaking Change</strong>: The <code>glean.util</code> and <code>glean.hardware</code> modules, which
were unintentionally public, have been made private.</li>
<li>Most Glean work and I/O is now done on its own worker thread. This brings the parallelism Python in line with the other platforms.</li>
<li>The timing distribution, memory distribution, string list, labeled boolean and labeled string metric types are now supported in Python (<a href="https://github.com/mozilla/glean/pull/762">#762</a>, <a href="https://github.com/mozilla/glean/pull/763">#763</a>, <a href="https://github.com/mozilla/glean/pull/765">#765</a>, <a href="https://github.com/mozilla/glean/pull/766">#766</a>)</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2510-2020-02-26" id="v2510-2020-02-26">v25.1.0 (2020-02-26)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v25.0.0...v25.1.0">Full changelog</a></p>
<ul>
<li>Python:
<ul>
<li>The Boolean, Datetime and Timespan metric types are now supported in Python (<a href="https://github.com/mozilla/glean/pull/731">#731</a>, <a href="https://github.com/mozilla/glean/pull/732">#732</a>, <a href="https://github.com/mozilla/glean/pull/737">#737</a>)</li>
<li>Make public, document and test the debugging features (<a href="https://github.com/mozilla/glean/pull/733">#733</a>)</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2500-2020-02-17" id="v2500-2020-02-17">v25.0.0 (2020-02-17)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v24.2.0...v25.0.0">Full changelog</a></p>
<ul>
<li>General:
<ul>
<li><code>ping_type</code> is not included in the <code>ping_info</code> any more (<a href="https://github.com/mozilla/glean/pull/653">#653</a>), the pipeline takes the value from the submission URL.</li>
<li>The version of <code>glean_parser</code> has been upgraded to 1.18.2:
<ul>
<li><strong>Breaking Change (Java API)</strong> Have the metrics names in Java match the names in Kotlin.
See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1588060">Bug 1588060</a>.</li>
<li>The reasons a ping are sent are now included in the generated markdown documentation.</li>
</ul>
</li>
</ul>
</li>
<li>Android:
<ul>
<li>The <code>Glean.initialize</code> method runs mostly off the main thread (<a href="https://github.com/mozilla/glean/pull/672">#672</a>).</li>
<li>Labels in labeled metrics now have a correct, and slightly stricter, regular expression.
See <a href="https://mozilla.github.io/glean/user/metrics/index.html#label-format">label format</a> for more information.</li>
</ul>
</li>
<li>iOS:
<ul>
<li>The baseline ping will now include <code>reason</code> codes that indicate why it was
submitted. If an unclean shutdown is detected (e.g. due to force-close), this
ping will be sent at startup with <code>reason: dirty_startup</code>.</li>
<li>Per <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1614785">Bug 1614785</a>, the
clearing of application lifetime metrics now occurs after the metrics ping is
sent in order to preserve values meant to be included in the startup metrics
ping.</li>
<li><code>initialize()</code> now performs most of its work in a background thread.</li>
</ul>
</li>
<li>Python:
<ul>
<li>When the pre-init task queue overruns, this is now recorded in the metric
<code>glean.error.preinit_tasks_overflow</code>.</li>
<li>glinter warnings are printed to <code>stderr</code> when loading <code>metrics.yaml</code> and
<code>pings.yaml</code> files.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2420-2020-02-11" id="v2420-2020-02-11">v24.2.0 (2020-02-11)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v24.1.0...v24.2.0">Full changelog</a></p>
<ul>
<li>General:
<ul>
<li>Add <code>locale</code> to <code>client_info</code> section.</li>
<li><strong>Deprecation Warning</strong> Since <code>locale</code> is now in the <code>client_info</code> section, the one
in the baseline ping (<a href="https://github.com/mozilla/glean/blob/c261205d6e84d2ab39c50003a8ffc3bd2b763768/glean-core/metrics.yaml#L28-L42"><code>glean.baseline.locale</code></a>)
is redundant and will be removed by the end of the quarter.</li>
<li>Drop the Glean handle and move state into glean-core (<a href="https://github.com/mozilla/glean/pull/664">#664</a>)</li>
<li>If an experiment includes no <code>extra</code> fields, it will no longer include <code>{&quot;extra&quot;: null}</code> in the JSON payload.</li>
<li>Support for ping <code>reason</code> codes was added.</li>
<li>The metrics ping will now include <code>reason</code> codes that indicate why it was
submitted.</li>
<li>The version of <code>glean_parser</code> has been upgraded to 1.17.3</li>
</ul>
</li>
<li>Android:
<ul>
<li>Collections performed before initialization (preinit tasks) are now dispatched off
the main thread during initialization.</li>
<li>The baseline ping will now include <code>reason</code> codes that indicate why it was
submitted. If an unclean shutdown is detected (e.g. due to force-close), this
ping will be sent at startup with <code>reason: dirty_startup</code>.</li>
</ul>
</li>
<li>iOS:
<ul>
<li>Collections performed before initialization (preinit tasks) are now dispatched off
the main thread and not awaited during initialization.</li>
<li>Added recording of <code>glean.error.preinit_tasks_overflow</code> to report when
the preinit task queue overruns, leading to data loss. See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1609734">bug
1609734</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2410-2020-01-16" id="v2410-2020-01-16">v24.1.0 (2020-01-16)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v24.0.0...v24.1.0">Full changelog</a></p>
<ul>
<li>General:
<ul>
<li>Stopping a non started measurement in a timing distribution will now be reported
as an <code>invalid_state</code> error.</li>
</ul>
</li>
<li>Android:
<ul>
<li>A new metric <code>glean.error.preinit_tasks_overflow</code> was added to report when
the preinit task queue overruns, leading to data loss. See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1609482">bug
1609482</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2400-2020-01-14" id="v2400-2020-01-14">v24.0.0 (2020-01-14)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v23.0.1...v24.0.0">Full changelog</a></p>
<ul>
<li>General:
<ul>
<li><strong>Breaking Change</strong> An <code>enableUpload</code> parameter has been added to the <code>initialize()</code>
function. This removes the requirement to call <code>setUploadEnabled()</code> prior to calling
the <code>initialize()</code> function.</li>
</ul>
</li>
<li>Android:
<ul>
<li>The metrics ping scheduler will now only send metrics pings while the
application is running. The application will no longer &quot;wake up&quot; at 4am
using the Work Manager.</li>
<li>The code for migrating data from Glean SDK before version 19 was removed.</li>
<li>When using the <code>GleanTestLocalServer</code> rule in instrumented tests, pings are
immediately flushed by the <code>WorkManager</code> and will reach the test endpoint as
soon as possible.</li>
</ul>
</li>
<li>Python:
<ul>
<li>The Python bindings now support Python 3.5 - 3.7.</li>
<li>The Python bindings are now distributed as a wheel on Linux, macOS and
Windows.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2301-2020-01-08" id="v2301-2020-01-08">v23.0.1 (2020-01-08)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v23.0.0...v23.0.1">Full changelog</a></p>
<ul>
<li>Android:
<ul>
<li>BUGFIX: The Glean Gradle plugin will now work if an app or library doesn't
have a metrics.yaml or pings.yaml file.</li>
</ul>
</li>
<li>iOS:
<ul>
<li>The released iOS binaries are now built with Xcode 11.3.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2300-2020-01-07" id="v2300-2020-01-07">v23.0.0 (2020-01-07)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v22.1.0...v23.0.0">Full changelog</a></p>
<ul>
<li>Python bindings:
<ul>
<li>Support for events and UUID metrics was added.</li>
</ul>
</li>
<li>Android:
<ul>
<li>The Glean Gradle Plugin correctly triggers docs and API updates when registry files
change, without requiring them to be deleted.</li>
<li><code>parseISOTimeString</code> has been made 4x faster. This had an impact on Glean
migration and initialization.</li>
<li>Metrics with <code>lifetime: application</code> are now cleared when the application is started,
after startup Glean SDK pings are generated.</li>
</ul>
</li>
<li>All platforms:
<ul>
<li>The public method <code>PingType.send()</code> (in all platforms) have been deprecated
and renamed to <code>PingType.submit()</code>.</li>
<li>Rename <code>deletion_request</code> ping to <code>deletion-request</code> ping after glean_parser update</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2210-2019-12-17" id="v2210-2019-12-17">v22.1.0 (2019-12-17)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v22.0.0...v22.1.0">Full changelog</a></p>
<ul>
<li>Add <code>InvalidOverflow</code> error to <code>TimingDistribution</code>s (<a href="https://github.com/mozilla/glean/pull/583">#583</a>)</li>
</ul>
<h1><a class="header" href="#v2200-2019-12-05" id="v2200-2019-12-05">v22.0.0 (2019-12-05)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v21.3.0...v22.0.0">Full changelog</a></p>
<ul>
<li>Add option to defer ping lifetime metric persistence (<a href="https://github.com/mozilla/glean/pull/530">#530</a>)</li>
<li>Add a crate for the nice control API (<a href="https://github.com/mozilla/glean/pull/542">#542</a>)</li>
<li>Pending <code>deletion_request</code> pings are resent on start (<a href="https://github.com/mozilla/glean/pull/545">#545</a>)</li>
</ul>
<h1><a class="header" href="#v2130-2019-12-03" id="v2130-2019-12-03">v21.3.0 (2019-12-03)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v21.2.0...v21.3.0">Full changelog</a></p>
<ul>
<li>Timers are reset when disabled. That avoids recording timespans across disabled/enabled toggling (<a href="https://github.com/mozilla/glean/pull/495">#495</a>).</li>
<li>Add a new flag to pings: <code>send_if_empty</code> (<a href="https://github.com/mozilla/glean/pull/528">#528</a>)</li>
<li>Upgrade <code>glean_parser</code> to v1.12.0</li>
<li>Implement the deletion request ping in Glean (<a href="https://github.com/mozilla/glean/pull/526">#526</a>)</li>
</ul>
<h1><a class="header" href="#v2120-2019-11-21" id="v2120-2019-11-21">v21.2.0 (2019-11-21)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v21.1.1...v21.2.0">Full changelog</a></p>
<ul>
<li>
<p>All platforms</p>
<ul>
<li>
<p>The experiments API is no longer ignored before the Glean SDK initialized. Calls are
recorded and played back once the Glean SDK is initialized.</p>
</li>
<li>
<p>String list items were being truncated to 20, rather than 50, bytes when using
<code>.set()</code> (rather than <code>.add()</code>). This has been corrected, but it may result
in changes in the sent data if using string list items longer than 20 bytes.</p>
</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2111-2019-11-20" id="v2111-2019-11-20">v21.1.1 (2019-11-20)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v21.1.0...v21.1.1">Full changelog</a></p>
<ul>
<li>
<p>Android:</p>
<ul>
<li>Use the <code>LifecycleEventObserver</code> interface, rather than the <code>DefaultLifecycleObserver</code>
interface, since the latter isn't compatible with old SDK targets.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2110-2019-11-20" id="v2110-2019-11-20">v21.1.0 (2019-11-20)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v21.0.0...v21.1.0">Full changelog</a></p>
<ul>
<li>
<p>Android:</p>
<ul>
<li>
<p>Two new metrics were added to investigate sending of metrics and baseline pings.
See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1597980">bug 1597980</a> for more information.</p>
</li>
<li>
<p>Glean's two lifecycle observers were refactored to avoid the use of reflection.</p>
</li>
</ul>
</li>
<li>
<p>All platforms:</p>
<ul>
<li>Timespans will now not record an error if stopping after setting upload enabled to false.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2100-2019-11-18" id="v2100-2019-11-18">v21.0.0 (2019-11-18)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v20.2.0...v21.0.0">Full changelog</a></p>
<ul>
<li>
<p>Android:</p>
<ul>
<li>
<p>The <code>GleanTimerId</code> can now be accessed in Java and is no longer a <code>typealias</code>.</p>
</li>
<li>
<p>Fixed a bug where the metrics ping was getting scheduled twice on startup.</p>
</li>
</ul>
</li>
<li>
<p>All platforms</p>
<ul>
<li>Bumped <code>glean_parser</code> to version 1.11.0.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#v2020-2019-11-11" id="v2020-2019-11-11">v20.2.0 (2019-11-11)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v20.1.0...v20.2.0">Full changelog</a></p>
<ul>
<li>In earlier 20.x.x releases, the version of glean-ffi was incorrectly built
against the wrong version of glean-core.</li>
</ul>
<h1><a class="header" href="#v2010-2019-11-11" id="v2010-2019-11-11">v20.1.0 (2019-11-11)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v20.0.0...v20.1.0">Full changelog</a></p>
<ul>
<li>
<p>The version of Glean is included in the Glean Gradle plugin.</p>
</li>
<li>
<p>When constructing a ping, events are now sorted by their timestamp. In practice,
it rarely happens that event timestamps are unsorted to begin with, but this
guards against a potential race condition and incorrect usage of the lower-level
API.</p>
</li>
</ul>
<h1><a class="header" href="#v2000-2019-11-11" id="v2000-2019-11-11">v20.0.0 (2019-11-11)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v19.1.0...v20.0.0">Full changelog</a></p>
<ul>
<li>
<p>Glean users should now use a Gradle plugin rather than a Gradle script. (#421)
See <a href="https://mozilla.github.io/glean/book/user/adding-glean-to-your-project.html#integrating-with-the-build-system">integrating with the build system docs</a> for more information.</p>
</li>
<li>
<p>In Kotlin, metrics that can record errors now have a new testing method,
<code>testGetNumRecordedErrors</code>. (#401)</p>
</li>
</ul>
<h1><a class="header" href="#v1910-2019-10-29" id="v1910-2019-10-29">v19.1.0 (2019-10-29)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v19.0.0...v19.1.0">Full changelog</a></p>
<ul>
<li>Fixed a crash calling <code>start</code> on a timing distribution metric before Glean is initialized.
Timings are always measured, but only recorded when upload is enabled (<a href="https://github.com/mozilla/glean/pull/400">#400</a>)</li>
<li>BUGFIX: When the Debug Activity is used to log pings, each ping is now logged only once (<a href="https://github.com/mozilla/glean/pull/407">#407</a>)</li>
<li>New <code>invalid state</code> error, used in timespan recording (<a href="https://github.com/mozilla/glean/pull/230">#230</a>)</li>
<li>Add an Android crash instrumentation walk-through (<a href="https://github.com/mozilla/glean/pull/399">#399</a>)</li>
<li>Fix crashing bug by avoiding assert-printing in LMDB (<a href="https://github.com/mozilla/glean/pull/422">#422</a>)</li>
<li>Upgrade dependencies, including rkv (<a href="https://github.com/mozilla/glean/pull/416">#416</a>)</li>
</ul>
<h1><a class="header" href="#v1900-2019-10-22" id="v1900-2019-10-22">v19.0.0 (2019-10-22)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v0.0.1-TESTING6...v19.0.0">Full changelog</a></p>
<p>First stable release of Glean in Rust (aka glean-core).
This is a major milestone in using a cross-platform implementation of Glean on the Android platform.</p>
<ul>
<li>Fix round-tripping of timezone offsets in dates (<a href="https://github.com/mozilla/glean/pull/392">#392</a>)</li>
<li>Handle dynamic labels in coroutine tasks (<a href="https://github.com/mozilla/glean/pull/384">#394</a>)</li>
</ul>
<h1><a class="header" href="#v001-testing6-2019-10-18" id="v001-testing6-2019-10-18">v0.0.1-TESTING6 (2019-10-18)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v0.0.1-TESTING5...v0.0.1-TESTING6">Full changelog</a></p>
<ul>
<li>Ignore dynamically stored labels if Glean is not initialized (<a href="https://github.com/mozilla/glean/pull/374">#374</a>)</li>
<li>Make sure ProGuard doesn't remove Glean classes from the app (<a href="https://github.com/mozilla/glean/pull/380">#380</a>)</li>
<li>Keep track of pings in all modes (<a href="https://github.com/mozilla/glean/pull/378">#378</a>)</li>
<li>Add <code>jnaTest</code> dependencies to the <code>forUnitTest</code> JAR (<a href="https://github.com/mozilla/glean/pull/382">#382</a>)</li>
</ul>
<h1><a class="header" href="#v001-testing5-2019-10-10" id="v001-testing5-2019-10-10">v0.0.1-TESTING5 (2019-10-10)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v0.0.1-TESTING4...v0.0.1-TESTING5">Full changelog</a></p>
<ul>
<li>Upgrade to NDK r20 (<a href="https://github.com/mozilla/glean/pull/365">#365</a>)</li>
</ul>
<h1><a class="header" href="#v001-testing4-2019-10-09" id="v001-testing4-2019-10-09">v0.0.1-TESTING4 (2019-10-09)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v0.0.1-TESTING3...v0.0.1-TESTING4">Full changelog</a></p>
<ul>
<li>Take DST into account when converting a calendar into its items (<a href="https://github.com/mozilla/glean/pull/359">#359</a>)</li>
<li>Include a macOS library in the <code>forUnitTests</code> builds (<a href="https://github.com/mozilla/glean/pull/358">#358</a>)</li>
<li>Keep track of all registered pings in test mode (<a href="https://github.com/mozilla/glean/pull/363">#363</a>)</li>
</ul>
<h1><a class="header" href="#v001-testing3-2019-10-08" id="v001-testing3-2019-10-08">v0.0.1-TESTING3 (2019-10-08)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v0.0.1-TESTING2...v0.0.1-TESTING3">Full changelog</a></p>
<ul>
<li>Allow configuration of Glean through the <code>GleanTestRule</code></li>
<li>Bump <code>glean_parser</code> version to 1.9.2</li>
</ul>
<h1><a class="header" href="#v001-testing2-2019-10-07" id="v001-testing2-2019-10-07">v0.0.1-TESTING2 (2019-10-07)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/v0.0.1-TESTING1...v0.0.1-TESTING2">Full changelog</a></p>
<ul>
<li>Include a Windows library in the <code>forUnitTests</code> builds</li>
</ul>
<h1><a class="header" href="#v001-testing1-2019-10-02" id="v001-testing1-2019-10-02">v0.0.1-TESTING1 (2019-10-02)</a></h1>
<p><a href="https://github.com/mozilla/glean/compare/95b6bcc03616c8d7c3e3e64e99ee9953aa06a474...v0.0.1-TESTING1">Full changelog</a></p>
<h3><a class="header" href="#general" id="general">General</a></h3>
<p>First testing release.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/appendix/changelog.md">Edit this file on GitHub.</a></footer><h1><a class="header" href="#this-week-in-glean-twig-1" id="this-week-in-glean-twig-1">This Week in Glean (TWiG)</a></h1>
<p>This Week in Glean is a series of blog posts that the Glean Team at Mozilla is using to try to communicate better about our work.
They could be release notes, documentation, hopes, dreams, or whatever: so long as it is inspired by Glean.</p>
<h2><a class="header" href="#blog-posts" id="blog-posts">Blog posts</a></h2>
<ul>
<li>2019-10-17: <a href="https://chuttenblog.wordpress.com/2019/10/17/this-week-in-glean-glean-on-desktop-project-fog/">Glean on Desktop (Project FOG)</a></li>
<li>2019-10-24: <a href="https://fnordig.de/2019/10/24/this-week-in-glean/">A Release</a></li>
<li>2019-11-01: <a href="http://droettboom.com/blog/2019/11/01/this-week-in-glean-november-1-2019/">A detective story</a></li>
<li>2019-11-08: <a href="https://blogoftravis.wordpress.com/2019/11/08/this-week-in-glean-2019-11-08/">Instrumenting Android Crashes with Glean</a></li>
<li>2019-11-19: <a href="https://www.a2p.it/wordpress/tech-stuff/mozilla/geckoview-glean-fenix-performance-metrics/">GeckoView + Glean = Fenix performance metrics</a></li>
<li>2019-11-21: <a href="https://dianaciufo.wordpress.com/2019/10/11/glean-graphic-identity-for-mozilla-firefox/">What is the Glean logo about?</a></li>
<li>2019-11-22: <a href="https://chuttenblog.wordpress.com/2019/11/22/this-week-in-glean-glean-in-private/">Glean in Private</a></li>
<li>2019-11-29: <a href="https://fnordig.de/2019/11/29/this-week-in-glean/">Differences</a></li>
<li>2019-12-06: <a href="https://brizental.github.io/2019/12/06/this-week-in-glean-migrations.html">Migrations</a></li>
<li>2020-01-10: <a href="https://brizental.github.io/2020/01/10/this-week-in-glean-glossary.html">Glossary</a></li>
<li>2020-02-03: <a href="https://fnordig.de/2020/02/03/this-week-in-glean/">Cargo features - an investigation</a></li>
<li>2020-02-14: <a href="https://www.a2p.it/wordpress/tech-stuff/mozilla/extending-glean-build-re-usable-types-for-new-use-cases/">Extending Glean: build re-usable types for new use-cases</a></li>
<li>2020-02-21: <a href="https://chuttenblog.wordpress.com/2020/02/21/this-week-in-glean-a-distributed-team-echoes-distributed-workflow/">A Distributed Team Echoes Distributed Workflow</a></li>
<li>2020-02-28: <a href="https://wlach.github.io/blog/2020/02/this-week-in-glean-special-guest-post-mozregression-telemetry-part-1/">mozregression telemetry (part 1)</a></li>
<li>2020-03-09: <a href="https://blog.mozilla.org/data/2020/03/09/this-week-in-glean-metric-lifetimes/">Metric lifetimes</a></li>
<li>2020-03-13: <a href="https://blog.mozilla.org/data/2020/03/13/this-week-in-glean-adding-support-for-glam-on-glean/">Adding support for GLAM on Glean</a></li>
<li>2020-03-25: <a href="https://blog.mozilla.org/data/2020/03/25/this-week-in-glean-comparing-apples-to-oranges/">Comparing Apples to Oranges</a></li>
<li>2020-04-15: <a href="https://chuttenblog.wordpress.com/2020/04/15/this-week-in-glean-how-much-does-that-data-cost/">How Much Does That Data Cost</a></li>
<li>2020-04-27: <a href="https://blog.mozilla.org/data/2020/04/27/this-week-in-glean-glean-for-python-on-windows/">Glean for Python on Windows</a></li>
<li>2020-05-04: <a href="https://fnordig.de/2020/05/04/this-week-in-glean/">Bytes in Memory (on Android)</a></li>
<li>2020-05-08: <a href="https://wlach.github.io/blog/2020/05/this-week-in-glean-mozregression-telemetry-part-2/">mozregression telemetry (part 2)</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/glean/edit/master/docs/appendix/twig.md">Edit this file on GitHub.</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="tabs.js"></script>
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
